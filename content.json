[{"title":"JavaScript简明教程（4）","date":"2016-03-05T05:26:28.000Z","path":"2016/03/05/js-04/","text":"本章节主要讲解了原型链及相关方法。 六.原型链及相关属性方法简单说明1.原型链代码示例1234567891011121314151617&lt;script&gt; //01 提供Person构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置Person的原型对象 Person.prototype.showName = function () &#123; console.log(this.name); &#125; //03 创建Student构造函数 function Student(number) &#123; this.numer = number &#125; //04 设置Student的原型对象 Student.prototype = new Person();&lt;/script&gt; 原型链图示例 2.Object对象Object构造函数01 使用Object构造函数创建字符串对象12345678//01 创建字符串对象var str1 = new String(\"测试字符串\");var str2 = new Object(\"测试字符串\");var str3 = str1;//注意:对象比较相等(需要引用[地址]相等)console.log(str1 == str2); //falseconsole.log(str1 === str2); //falseconsole.log(str1 === str3); //true 02 使用Object构造函数创建数字对象12var num = new Object(10);console.log(typeof num); //object 03 使用Object构造函数创建布尔类型对象12var bool = new Object(true); console.log(typeof bool); //object js中所有的内置或自定义对象都继承自Object对象,几乎所有的对象都可以使用Object.prototype上面的属性和方法 3.Object.prototype01 因为js中所有的对象都继承自Obejct,都可以使用Object对象的原型属性和方法,因此不要轻易的扩展Object.prototype。02 Object.property中的属性和方法 ① constructor 指向原型相关联的构造函数，为Object ② hasOwnProperty 判断对象中是否拥有某个实例属性(不包括原型链上面的属性) ③ isPrototypeOf 校验某个对象是否是指定对象的原型对象(整条原型链) ④ propertyIsEnumerable 属性是否存在且可枚举(使用for循环可以遍历,即目标属性能否在for循环中显示出来) ⑤ toString() 返回一个描述目标对象的字符串,对象则返回[object object] toString(参数) 参数出可以传入一个用于进制数的参数,该参数的默认值为10(主要针对Number类型有效) ⑥ toLocaleString 同toString,但是会做一些本地化的处理。 ⑦ valueOf() 如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。 Date对象调用该方法会返回一个时间戳。 constructor说明：该属性指向创建该对象的构造函数，在这里为Object123456function Person() &#123; &#125; var p = new Person(); console.log(p.constructor); //function Person() &#123;&#125; console.log(Person.prototype.constructor); //function Person() &#123;&#125; console.log(Object.prototype.constructor); //function Object() &#123; [native code] &#125; hasOwnProperty说明：判断对象中是否拥有某个实例属性(不包括原型链上面的属性)12345678function Person() &#123; this.name = \"默认的姓名\"&#125;//检查对象中是否拥有指定的属性(实例属性)var p1 = new Person();p1.hasOwnProperty(\"name\"); //truep1.hasOwnProperty(\"age\"); //falsep1.hasOwnProperty(\"constructor\"); //对象的constructor是从原型对象上继承的 isPrototypeOf说明：校验某个对象是否是指定对象的原型对象(整条原型链);1234567891011121314&lt;script&gt; var obj = &#123; name:\"张三\", age:20, hello:function () &#123; console.log(\"hello\"); &#125;, showName:function () &#123; console.log(this.name); &#125; &#125; //属性是否存在且可以枚举 console.log(obj.propertyIsEnumerable(\"name\")); //true&lt;/script&gt; toString说明：返回一个描述目标对象的字符串,对象则返回[object object]12345678910111213&lt;script&gt; var obj = &#123;&#125;; console.log(obj.toString()); //打印[object Object] var arr = [1,2,3,4,5]; console.log(arr.toString()); //打印1,2,3,4,5 var num = 10; console.log(num.toString()); //10 var date = new Date(); console.log(date.toString()); //Mon Feb 13 2017 19:00:13 GMT+0800 (CST) //toString方法可以传入参数,在处理Number类型数据的时候,可以传入指定的进制 console.log(num.toString(2)); //1010 == 1*2*2*2+0*2*2+1*2+1*1 = 10 console.log(num.toString(3)); //101 == 1*3*3 + 0*3 + 1*1 = 10&lt;/script&gt; toLocaleString说明：作用同toString方法一致，但是会做一些本地化的处理. valueOf说明：① 如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。② 如果是Date类型，则返回时间戳。123456789&lt;script&gt; var obj = &#123;&#125;; console.log(obj + 1); //[object Object]1 //说明:如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。 var o = &#123;name:\"张三\"&#125;; console.log(o + 1); //[object Object]1 var date = new Date(); console.log(date.valueOf()); //1486984088998&lt;/script&gt; 4.静态成员和实例成员静态成员 定义在构造函数上面的成员(属性和方法) 实例成员 定义在实例对象上面的成员(属性和方法) 建议 ① 把工具类的方法写成静态方法 ② 把和对象相关的方法写成实例方法(成员) 代码示例12345678910111213141516&lt;script&gt; function Person() &#123; this.name = \"张三\"; //实例属性 this.showName = function () &#123; console.log(this.name); &#125;; &#125; //为Person构造函数添加静态成员 Person.des = \"描述信息\"; Person.add = function (msg) &#123; console.log(\"添加信息\" + msg); &#125;; Person.add(\"这是一个+操作\"); var p1 = new Person(); p1.showName();&lt;/script&gt; 5.Function构造函数函数创建的几种方式 12301 函数声明02 字面量的方式创建03 使用new Function的形式创建 函数创建代码示例 12345678function func01() &#123; console.log(\"函数声明\"); &#125; var func02 = function () &#123; console.log(\"字面量方式创建\"); &#125; //使用Function构造函数创建 var func03 = new Function(); Function构造函数创建函数 参数说明:可以传入多个参数 最后一个参数:传入的最后一个参数为函数的函数体内容 其他参数:创建出来的函数的参数 如果只有一个参数,则表示这是该函数的函数体内容 传递参数的格式:以字符串的方式进行传参代码示例123456//需求01 使用Function构造函数创建一个函数对象,该函数执行一行打印操作var funcName01 = new Function(\"console.log('让我掉下眼泪的,不止昨夜的酒')\");funcName01();//需求02 使用Function构造函数创建一个函数对象,该函数需要接受两个参数,要求返回他们的和var funcName02 = new Function(\"a\",\"b\",\"return a + b;\");console.log(funcName02(10, 20)); //30 解决函数体代码过长的问题（1）使用转义字符，写在一行中（2）使用+操作符来拼接字符串（3）使用``操作符来管理字符串（4）使用模板先处理字符串，然后在js中获得模板中的内容 6.arguments、length和calleearguments参数说明：在js中的函数中，有两个隐藏的参数分别是this和arguments1234arguments 是一个类似数组的结构,可以通过下标来操作函数的参数,但并非数组类型的。在函数调用的时候,会将函数的所有参数都传入arguments对象中保存,因此我们可以通过操作arguments属性来操作参数形参的数量大于实参的数量,则依次传入,未传入的设置为undefined形参的数量小于实参的数量,则arguments中保存实际的值 length 函数内部的arguments数组拥有length属性,可以通过该属性获取用户调用时传入的实参的个数 函数本身有一个length属性,可以通过该属性来获取形式参数的个数 callee方法 函数内部的arguments对象中,有一个callee方法,该方法指向函数自身,常用于匿名函数的递归调用。 代码示例12345678910111213141516171819&lt;script&gt; function func() &#123; console.log(arguments); console.log(arguments.length); //调用函数时实际传入的参数数量 &#125; func(1,2,3,4,5); console.log(func.length); //预期的参数数量 —— 函数的形参数量 function func02(a,b) &#123; console.log(a, b); console.log(arguments); &#125; func02(1,2,3); //实参的数量 &gt; 形参的数量 则arguments保存实参的值 func02(1); //实参的数量 &lt; 形参的数量 则不足的补undefined //匿名函数调用 (function () &#123; //如果需要在该函数中调用自身,则可以使用arguments.callee方法 arguments.callee(); &#125;)();&lt;/script&gt; 7.Function的应用01 数组去重123456789101112 var func = new Function(\"arr\",` var array = []; for(var i = 0 ; i&lt;arr.length; i++) &#123; if(array.indexOf(arr[i]) == -1) &#123; array.push(arr[i]); &#125; &#125; return array;`); console.log(func([1, 2, 3, 4, 5, 3, 4, 2]));; 02 返回传入函数中所有数据的最大值123456789101112var func = function () &#123; var maxNumber = arguments[0]; for(var i = 0;i&lt;arguments.length;i++) &#123; if (maxNumber &lt; arguments[i]) &#123; maxNumber = arguments[i]; &#125; &#125; return maxNumber;&#125;console.log(func(1, 2, 3, 45, 5, 6, 7, 8, 30, 21)); 8.eval 简单说明eval 的基本使用eval函数用来讲字符串转换为JS的代码,并执行 eval 处理JSON数据代码示例123456&lt;script&gt; var jsonData = '&#123;\"name\":\"张三\",\"age\":18&#125;'; //把json的数据转换为对象 var obj = JSON.parse(jsonData); console.log(obj);&lt;/script&gt; 12345678910111213&lt;script&gt; var jsonData = '&#123;\"name\":\"张三\",\"age\":18&#125;'; //var obj = eval(jsonData); //注意:如果直接这样写代码则会报错 //正确的处理方式 //方式一 eval(\"var obj = \" + jsonData); console.log(obj); //方式二 //说明:使用eval来解析json格式字符串的时候,会将&#123;&#125;解析为代码块,而不是字面量 // 在使用的时候为了避免这种错误,需要在JSO的最外面加上(),如此则会把大括号当做一条语句来解析 var o = eval(\"(\"+jsonData+\")\"); console.log(o);&lt;/script&gt; eval 注意事项 ① eval函数本身功能强大,但它的特性也为程序带来了很大的不确定性,因此在开发中并不推荐使用。 ② eval函数是动态的执行代码,因此其效率不如直接执行静态脚本高。 eval和Function比较12相同点:都能够把字符串转换为Javascript的代码不同点:eval转换为js的代码之后马上就执行,而Function需要先创建函数,调用函数之后才会执行。 9.Function.prototype原型链关于Function和自定义构造函数的原型对象 Function.prototype 是一个空的函数 自定义构造函数的原型对象是一个空的对象 说明 Function也可以被当做是一个构造函数 通过new Function创建出来的函数,可以认为是Function的实例化对象。 Function的原型对象是一个空的函数,这个空的函数也是一个对象,它的原型对象是Object.prototype。 在JS中,Object的原型对象是所有对象的祖宗。 Function是构造函数,则其原型对象为空的函数 空的函数的原型对象为Object.prototype Function本身也是对象,则其构造函数为:function Function() { [native code] } 是自身 同Object类型 Object本身是构造函数,其原型对象是Object.prototype Object本身也是对象,其构造函数为:function Function() { [native code] 代码示例123456789101112131415//01 提供Person构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置Person的原型对象 Person.prototype.showName = function () &#123; console.log(this.name); &#125; //03 创建Student构造函数 function Student(number) &#123; this.numer = number &#125; //04 设置Student的原型对象 Student.prototype = new Person(); 完整的原型链示意图Object和Function的关系01 Object构造函数是通过Function构造函数实例化出来的02 Function构造函数也是通过Function构造函数实例化出来的 代码示例12345678&lt;script&gt; //检查对象是否是某个构造函数的实例 console.log(Function instanceof Function); console.log(Function instanceof Object); console.log(Object instanceof Object); console.log(Object instanceof Function); //注意:以上打印结果均为true&lt;/script&gt; 10.对象的拷贝操作浅拷贝如果对象中的属性是引用类型的值,那么存在数据共享问题,修改某个对象会对拷贝的对象产生影响代码示例123456789var o = &#123;name:\"张三\",car:&#123;number:\"2017\",type:\"火车\"&#125;&#125;;var obj = &#123;&#125;;//obj对象需要拷贝o对象中所有的属性for (var i in o )&#123; obj[i] = o[i];&#125;console.log(obj);o.car.type = \"飞船\";console.log(obj); 深拷贝 如果对象中的属性是值类型,那么就直接拷贝赋值 如果对象中的属性是引用类型,那么就再次调用拷贝方法,遍历对象 代码示例123456789101112131415161718192021222324252627 var o = &#123;name:\"张三\",car:&#123;number:\"2017\",type:\"火车\"&#125;&#125;; var obj = &#123;&#125;; function deepCopy(obj,tmp) &#123; tmp = tmp || &#123;&#125;; //如果没有传入,那么就创建一个空的对象 for(var i in obj) &#123; if (obj.hasOwnProperty(i)) //只拷贝实例属性 &#123; //判断是否是引用类型 if ((typeof obj[i]) == 'object') &#123; //重新调用拷贝方法 tmp[i] = Array.isArray(obj[i]) ? [] :&#123;&#125;; deepCopy(obj[i],tmp[i]); &#125;else &#123; //直接拷贝 tmp[i] = obj[i]; &#125; &#125; &#125; &#125;deepCopy(o,obj); console.log(obj); o.car.type = \"测试的类型\"; console.log(obj); console.log(o); 注意isArray的兼容性问题isArray是ECMA5中新推出的方法,需要处理兼容性问题123456if (Array.isArray != \"function\")&#123; Array.isArray = function (obj) &#123; return Object.prototype.toString.call(obj) == '[object Array]'; &#125;&#125; 11.Number原型扩展小案例：在Number的原型对象上面定义一个新的方法add(),该方法接收一个参数,并将该参数与自身的值进行相加,然后进行返回。代码实现123456789Number.prototype.add = function (num) &#123; return this + num;&#125;var n = 10;console.log(n.add(3));//console.log(5.add(5)); 错误:解析器无法处理字面量的这种情况var num = new Number(50);console.log(num.add(20)); //70console.log((1).add(4)); //5 使用()把数字包起来 使用注意123（01）使用数字变量可以调用成功（02）使用数字表达式可以调用成功（03）直接使用数字字面量方式调用失败 js的语法解析器无法处理数字字面量这种情况。 12.With语句with语句简单介绍123with语句是js中一个强大但有争议的特性。with语句允许我们将一个对象的所有属性引用到当前的作用域允许我们无需使用拥有者对象的前缀，就可以直接对这些属性进行引用和赋值操作。 注意：ECMAScript5规范在严格模式下已经禁用了该语句，在开发中不推荐使用，但是要求能够看懂with的代码。 with语句内部细节说明： with语句会创建一个作用域，在该作用域内，在引用特定对象的属性时，可以不使用前缀。应用场景：对深层级对象的引用进行缩短。 在with作用域内部引用属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //[01] 测试with语句作用域内对对象属性的引用 //01 提供全局变量,名称为testValue var testValue = '测试使用的全局变量'; //02 提供对象,对象内部提供属性 var testObject = &#123; name:'对象的名称属性', testValue:'对象内部的属性' &#125;; //03 使用with语句引用 with(testObject) &#123; console.log(name); //对象的名称属性 console.log(testValue); //对象内部的属性 console.log(this); //window &#125; console.log(testValue); //测试使用的全局变量``` 总结：(1) 在with语句作用域内,对象属性的优先级绝对高于在更层级作用域内定义的同名变量(2) this(函数上下文)依然指向window,并不会收到with作用域的影响**在with作用域内进行赋值操作**```js //01 提供一个对象,在内部提供属性 var obj = &#123; name:'对象的内部属性', &#125; //02 with语句测试对对象属性的赋值操作 with(obj) &#123; name = '修正对象中name的值'; //在作用域内部添加变量(思考?该变量是添加为全局作用域还是当前obj对象的属性?) age = '25'; showName = function () &#123; console.log('name == ' + name); &#125;; &#125;; //测试修改对象属性操作 console.log(obj.name); //测试添加对象属性操作 console.log(obj.age); //undefined //obj.showName(); //obj.showName is not a function console.log('____________________'); console.log(this.name); //== name == window.name console.log(window.name); console.log(name); showName(); //==this.showName() ==window.showName() 总结：（1）在with作用域的内部我们可以使用无前缀引用对象的属性进行读取和赋值的操作 但是 不能使用无前缀的方式添加属性（2）如果使用无前缀的方式来添加属性[对不存在的属性进行赋值操作],那么属性将被添加到全局上下文[window|this]（3）可能产生的错误:意外的引入一个全局变量,而非为with作用域对象添加属性 with语句的问题（1）with作用域内操作优先级混乱（2）性能不好，会大大降低js代码的执行性能（3）ECMAScript5规定在严格模式下禁用with特性 with语句简化代码的替代方案使用即时调用函数来替代with语句，通过函数传参的方式使用更短的引用来替代冗长的引用前缀比使用with语句消除前缀的方式更好。123456789101112with(this.style)&#123; width = '200px'; height = '200px'; backgroundColor = '#ca3'; console.log(width); //要访问的本应该是外部的字符串变量 \"错误哈哈\",但是这里被解释为200px&#125;(function (s) &#123; s.width = '200px'; s.height = '200px'; s.backgroundColor = '#ca3';&#125;)(this.style); 使用面向过程的方式处理1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; var bookList = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ]; //增加操作 bookList.push(&#123;name:\"城堡\",author:\"卡夫卡\"&#125;); //查询操作 for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == \"飞鸟集\") &#123; console.log(obj); break; &#125; &#125; //修改操作 for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == \"飞鸟集\") &#123; obj.author = \"泰戈尔-戈尔泰\" &#125; &#125; //删除操作 for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == \"飞鸟集\") &#123; //删除该对象 bookList.splice(i, 1); &#125; &#125; console.log(bookList);&lt;/script&gt; 使用函数来封装图书管理操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script&gt; var bookList = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ]; //增加操作 function addBook(bookObj) &#123; bookList.push(bookObj); &#125; addBook(&#123;name:\"城堡\",author:\"卡夫卡\"&#125;); //查询操作 function getBook(name) &#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; return obj; &#125; &#125; return null; &#125; console.log(getBook(\"什么是批判\")); //修改操作 function updateBookData(name,authorName)&#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; obj.author = authorName; &#125; &#125; &#125; updateBookData(\"飞鸟集\",\"泰戈尔斯坦\"); //删除操作 function removeBook(name) &#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; //删除该对象 bookList.splice(i, 1); &#125; &#125; &#125; console.log(bookList);&lt;/script&gt; 数封装-复用形式12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; var bookList = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ]; //增加操作 function addBook(bookObj) &#123; bookList.push(bookObj); &#125; addBook(&#123;name:\"城堡\",author:\"卡夫卡\"&#125;); //查询操作 function getBook(name) &#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; return obj; &#125; &#125; return null; &#125; console.log(getBook(\"什么是批判\")); //修改操作 function updateBookData(name,authorName)&#123; var obj = getBook(name); obj.author = authorName; &#125; updateBookData(\"飞鸟集\",\"泰戈尔斯坦\"); //删除操作 function removeBook(name) &#123; var obj = getBook(name); var index = bookList.indexOf(obj); bookList.splice(index,1); &#125; addBook(&#123;name:\"东京人\",author:\"川端康成\"&#125;); console.log(bookList);&lt;/script&gt; 面向对象的方式管理图书123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;scrip&gt; var obj = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ];泰 function BookManager() &#123; this.bookList = null; &#125; BookManager.prototype = &#123; constructor:BookManager, init:function (arr) &#123; this.bookList = arr || []; &#125;, addBook:function (bookObj) &#123; this.bookList.push(bookObj) &#125;, getBook:function (name) &#123; for (var i = 0; i &lt; this.bookList.length; i++) &#123; var obj = this.bookList[i]; if (obj.name == name) &#123; return obj; &#125; &#125; return null; &#125;, updateBookData:function (name,authorName)&#123; var obj = this.getBook(name); obj.author = authorName; &#125;, removeBook:function (name) &#123; var obj = this.getBook(name); var index = this.bookList.indexOf(obj); this.bookList.splice(index,1); &#125; &#125;; //01 创建对象 var YYManager = new BookManager(); YYManager.init(obj); console.log(YYManager.bookList); //02 演示添加操作 YYManager.addBook(&#123;name:\"花田半亩\",author:\"田维\"&#125;); console.log(YYManager.bookList); //03 演示查询操作 console.log(YYManager.getBook(\"花田半亩\")); //04 演示更新操作 YYManager.updateBookData(\"花田半亩\",\"甜田\"); console.log(YYManager.getBook(\"花田半亩\"));; //05 演示删除操作 YYManager.removeBook(\"什么是批判\"); console.log(YYManager.bookList); //02 创建第二个人的图书管理对象 var wulitaotaoMManager = new BookManager(); wulitaotaoMManager.init([&#123;name:\"装逼速成\",author:\"六扇门\"&#125;]); console.log(wulitaotaoMManager.bookList);&lt;/script&gt; 总结01 提供构造函数，在构造函数内部设置实例化属性02 把常用的操作提取成对象的实例方法，写在原型对象身上03 提供init方法，用于初始化数据04 注意：如果切断了原型对象那么需要修正内部的构造器属性指向","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.1oveit.club/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"}]},{"title":"JavaScript简明教程（3）","date":"2016-02-18T03:55:29.000Z","path":"2016/02/18/js-3/","text":"关于继承，通俗说子继父业。在JavaScript中，Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。 五.继承5.1相关方法在讲继承之前，我们必须先了解一些相关的方法。 1.hasOwnProperty和in属性操作in关键字作用：用来检查对象中是否存在某个属性(不区分实例属性和原型属性)。语法：“属性名” in 对象。代码示例:12345678910111213141516&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; this.name = name; &#125; //02 设置构造函数的原型对象的属性 Person.prototype.sayHello = function () &#123; console.log(\"hello\"); &#125; //03 创建对象 var p1 = new Person(); //04 使用in关键字判断对象中是否存在以下属性:name age sayHello console.log(\"age\" in p1); //false console.log(\"name\" in p1); //true console.log(\"sayHello\" in p1); //true&lt;/script&gt; 对象的hasOwnProperty方法作用：用来检查对象中是否存在指定的属性(只检查实例属性)语法：对象.hasOwnProperty(“属性名”)代码示例123456789101112131415161718&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; this.name = name; &#125; //02 设置构造函数的原型对象的属性 Person.prototype.sayHello = function () &#123; console.log(\"hello\"); &#125; Person.prototype.des = \"默认的描述信息\"; //03 创建对象 var p1 = new Person(); //04 使用hasOwnProperty方法判断该属性是否是对象的实例属性 console.log(p1.hasOwnProperty(\"age\")); //false console.log(p1.hasOwnProperty(\"name\")); //true console.log(p1.hasOwnProperty(\"sayHello\")); //false console.log(p1.hasOwnProperty(\"des\")); //false&lt;/script&gt; 判断某对象中存在且只存在某个原型属性123function isProperty(obj, property) &#123; return !obj.hasOwnProperty(property) &amp;&amp; (property in obj); &#125; 2.constructor构造器属性说明 使用构造函数创建对象,则 原型对象中的constructor属性指向对应的构造函数 实例对象中的constructor指向对应的构造函数,其中这里的constructor就是从原型中获取的即constructor时实例对象中的原型属性,而非实例属性 代码验证123456789101112131415//01 提供一个构造函数 function Person(name) &#123; this.name = name; &#125; //02 设置构造函数的原型对象的属性 Person.prototype.sayHello = function () &#123; console.log(\"hello\"); &#125;; Person.prototype.des = \"默认的描述信息\"; //03 创建对象 var p1 = new Person(); function isProperty(obj, property) &#123; return !obj.hasOwnProperty(property) &amp;&amp; (property in obj); &#125; console.log(isProperty(p1, \"constructor\")); //true 3.isprotoTypeOf和instanceisprotoTypeOf作用：判断是否是某个实例对象的原型对象语法:构造函数.protoType.isPrototypeOf(对象)用法示例123456789&lt;script&gt; function Person() &#123;&#125; function Dog() &#123;&#125; Person.prototype.name = \"嘿嘿\"; var p1 = new Person(); console.log(Person.prototype.isPrototypeOf(p1));//rue console.log(Object.prototype.isPrototypeOf(p1));//true console.log(Dog.prototype.isPrototypeOf(p1));//false&lt;/script&gt; instance作用：用于检查对象是否是某个构造函数(类型)的实例语法：对象 instance 构造函数注意：所有的对象都是Object构造函数（类型）的实例用法示例12345678&lt;script&gt; var arr = [1,2,3]; console.log(arr instanceof Array); //true console.log(Array instanceof Object); //true console.log(arr instanceof Object); //true //instanceOf在判断的时候,算上整条原型链 //arr 是Array 和Object 任何一个类的示例&lt;/script&gt; 5.2继承1.继承基本概念继承：即通过一定的方式实现让某个类型A获取另外一个类型B的属性或方法。其中类型A称之为子类型，类型B称之为父类型或超类型。 javaScript中的继承Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。继承有两种方式：接口继承和实现继承，在js中只支持实现继承，实现继承主要依赖原型链来完成。JavaScript中实现继承的几种方式：说明:其他语言中继承通常通过类来实现，js中没有类的概念，js中的继承是某个对象继承另外一个对象，是基于对象的。123401 原型式继承02 原型链继承03 经典继承(借用构造函数)04 组合继承 2.原型式继承原型链继承的方式A1234567891011121314151617&lt;script&gt; //01 提供一个构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置原型对象的属性 Person.prototype.className = \"逍遥派1班\"; //03 使用构造函数来创建原型对象 var p1 = new Person(\"张三\",10); var p2 = new Person(\"李四\",20); //04 打印p1和p2对象中的className属性 console.log(p1.className); console.log(p2.className); //结论:对象p1和p2继承了构造函数原型对象中的属性className //但是这并不是严格意义上的继承&lt;/script&gt; 原型链继承的方式B1234567891011121314151617181920&lt;script&gt; //01 提供一个构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置原型对象的属性 Person.prototype = &#123; constructor:Person, className:\"逍遥派1班\" &#125;; //03 使用构造函数来创建原型对象 var p1 = new Person(\"张三\",10); var p2 = new Person(\"李四\",20); //04 打印p1和p2对象中的className属性 console.log(p1.className); console.log(p2.className); //结论:对象p1和p2继承了构造函数原型对象中的属性className //注意:使用原型替换的方式实现继承的时候,原有原型对象中的属性和方法会丢失&lt;/script&gt; 原型链继承的方式C1234567891011121314151617181920212223//01 提供超类型|父类型构造函数function SuperClass() &#123; this.name = 'SuperClass的名称'; this.showName = function () &#123; console.log(this.name); &#125;&#125;//02 设置父类型的原型属性和原型方法SuperClass.prototype.info = 'SuperClass的信息';SuperClass.prototype.showInfo = function () &#123; console.log(this.info);&#125;;//03 提供子类型function SubClass() &#123;&#125;//04 设置继承(原型对象继承)SubClass.prototype = SuperClass.prototype;SubClass.prototype.constructor = SubClass;var sub = new SubClass();console.log(sub.name); //undefinedconsole.log(sub.info); //SuperClass的信息sub.showInfo(); //SuperClass的信息sub.showName(); //sub.showName is not a function 点评：上面的方法可以可以继承超类型中的原型属性和原型方法，但是无法继承实例属性和实例方法 3.原型链继承实现思想：利用原型（链）让一个对象继承另一个对象的属性和方法实现本质：重写原型对象 原型链123456① 每个构造函数都有原型对象② 每个对象都有自己的构造函数③ 每个构造函数的原型都是一个对象④ 那么这个构造函数的原型对象也有自己的构造函数⑤ 那么这个构造函数的原型对象的构造函数也有自己的原型对象以上形成一个链式的结构,称之为原型链 原型链中的属性搜索原则12345当访问某个对象的成员的时候,会先在自身中查找,如果找到则直接使用如果在自身中没有找到,则去当前创建当前对象的构造函数的原型对象中查找,如果找到了则直接使用如果在该原型对象中没有找到,则继续查找原型对象的原型对象(创建该原型对象的构造函数所对应的原型对象),如果找到则直接使用如果在原型对象的原型对象中也没有找到,则继续向上搜索....直到Object的原型对象,若还是没有,则返回undefined(属性)或报错(方法)。 基本写法·代码示例1234567891011121314151617181920212223//01 提供超类型|父类型function SuperClass() &#123; this.name = 'SuperClass的名称'; this.showName = function () &#123; console.log(this.name); &#125;&#125;//02 设置父类型的原型属性和原型方法SuperClass.prototype.info = 'SuperClass的信息';SuperClass.prototype.showInfo = function () &#123; console.log(this.info);&#125;;//03 提供子类型function SubClass() &#123;&#125;//04 设置继承(原型对象继承)SubClass.prototype = new SuperClass();SubClass.prototype.constructor = SubClass;var sub = new SubClass();console.log(sub.name); //SuperClass的名称console.log(sub.info); //SuperClass的信息sub.showInfo(); //SuperClass的信息sub.showName(); //SuperClass的名称 点评：可以继承父类型中的原型属性|原型方法,以及实例属性和实例方法 原型链继承的注意点和问题注意点① 确定原型和实例的关系 instanceof + isPrototypeOf()② 注意重写原型对象的位置，必须先实现原型继承，然后再设置子对象的原型属性和原型方法③ 完成继承之后，不能使用字面量的方式来创建原型[因为会切断原型] 问题① 父对象的实例属性会转换为子类型原型的原型属性，而如果父类型是实例属性是引用类型则会存在共享问题② 在创建子类型的实例时，不能向父类型的构造函数中传递参数1234567891011121314151617//01 提供父对象的构造函数function SuperType() &#123; //02 在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈'];&#125;;//03 提供子对象的构造函数function SubType() &#123;&#125;;//04 设置原型继承SubType.prototype = new SuperType();//05 创建父对象构造函数的实例对象,并对内部的实例化属性进行修改var subDemo1 = new SubType();var subDemo2 = new SubType();alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈subDemo1.family.push('爷爷','奶奶');alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶 4.经典继承（借用构造函数）经典继承又称为借用构造函数|伪造继承 基本思想在子类型构造函数的内部调用超类型|父类型构造函数说明：需要借助call|apply方法代码示例1234567891011121314151617181920212223242526//01 提供父类型(对象)的构造函数 function SuperType(name) &#123; //02 在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈']; //实例属性 this.name = name; &#125;; SuperType.prototype.info = '父类型的原型属性'; //03 提供子类型（对象）的构造函数 function SubType() &#123; //经典继承|借用构造函数|伪造对象继承 //SuperType.call(this); //构造参数传递参数 SuperType.call(this,'张老汉'); &#125;; //04 创建父类型的实例对象,并对内部的实例化属性进行修改 var subDemo1 = new SubType(); var subDemo2 = new SubType(); alert(subDemo1.info); //undefined alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈 alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈 subDemo1.family.push('爷爷','奶奶'); alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶 alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈 //测试构造函数传递参数 alert(subDemo1.name); 点评：能够继承父类型的实例属性,但是无法继承父类型的原型属性和原型方法 经典继承的优点① 解决实例对象共享问题，通过调用父对象的构造函数来实现每个子类型（对象）的实例对象均拥有一份父类型实例属性和方法的副本② 可以在调用call方法的时候向构造函数传递参数 经典继承的问题① 冒充继承的方法无法实现函数的重用② 无法继承父对象的原型属性和原型方法 5.组合继承组合继承|伪经典继承 基本思想① 使用原型链实现对原型属性和方法的继承② 通过伪造(冒充)构造函数来实现对实例属性的继承代码示例1234567891011121314151617181920212223242526272829//01 提供父类型的构造函数function SuperType(name) &#123; //在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈']; //实例属性 this.name = name;&#125;;//原型方法SuperType.prototype.showName = function () &#123; console.log(this.name);&#125;//02 提供子类型的构造函数function SubType(name) &#123; //冒充|伪造 构造参数传递参数 SuperType.call(this,name);&#125;;SubType.prototype = SuperType.prototype;//SubType.prototype = new SuperType();//02 创建父类型的实例对象,并对内部的实例化属性进行修改var subDemo1 = new SubType('张三');var subDemo2 = new SubType('张四');alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈subDemo1.family.push('爷爷','奶奶');alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈//测试构造函数传递参数subDemo1.showName(); //张三subDemo2.showName(); //张四 6.基本包装类型基本类型：字符串 + 数值 + null + undefined + 布尔值为了便于操作基本类型，ECMAScript提供了三个特殊的引用类型：Boolean + Number + String。上述类型和其他的引用类型类似，同时也具备与各自的基本类型相应的特殊行为，每当我们读取一个基本类型的值的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。123var str = '测试字符串';console.log(str.length); //5console.log(str.substring(2)); //字符串 思考：属性和方法本是对象的特征，字符串如何能够拥有length属性以及其他类似subString等方法，内部怎么实现的？基本类型值并不是对象，因此从逻辑上讨论他们不应该有属性和方法。 内部的具体处理:123（1）创建String类型的一个实例对象（2）在实例对象上面读取指定的属性（length）,调用指定的方法（subString）（3）销毁该对象 NumberNumber是与数字值相对应的引用类型。创建Number类型的对象：var num = new Number(10); String String是字符串的对象包装类型。创建字符串类型的对象：var str = new String(‘hello World’); BooleanBoolean是与布尔值对象的引用类型。可以通过调用Boolean构造函数传递参数来创建boolean类型的对象。var bool = new Boolean(true); 基本包装类型的代码示例1234567891011121314//001 Stringvar str = '测试字符串';console.log(str.length); //5console.log(str.substring(2)); //字符串//002 Numbervar num = new Number(10);console.log(num); //Number &#123;[[PrimitiveValue]]: 10&#125;console.log(typeof num); //objectconsole.log(typeof 10); //number//003 Booleanvar bool = new Boolean(true);console.log(bool); //Boolean &#123;[[PrimitiveValue]]: true&#125;console.log(typeof bool); //objectconsole.log(typeof true); //boolean 基本包装类型的注意点[1] 对象还是基本数据类型值？对象：通过new 调用构造函数创建出来的是对象基本数据类型值：直接通过字面量方式赋值|通过省略new关键字调用构造函数方式创建的是基本数据类型值。12345ex: var str1 = new String('hello'); var str2 = 'hello'; var str3 = String('hello'); 说明：以上代码中，str1是对象，而str2和str3是字符串（基本数据类型值） [2] 相等问题基本类型值判断相等=&gt;值相等引用类型值判断相等=&gt;值相等且引用相等对象是引用类型，因此在判断相等的时候有诸多的注意点和容易出错的地方123456789101112131415161718ex var str1 = '这是一个字符串'; //基本数据类型 var str2 = String('这是一个字符串'); //基本数据类型 console.log(str1 == str2); //true 相等 var str3 = new String('这是一个字符串'); //引用类型-对象 console.log(str1 == str3); //true //值相等 console.log(str2 == str3); //true //值相等 console.log(str1 === str3); //false //值相等,但是引用不相等 console.log(str2 === str3); //false //值相等,但是引用不相等 //判断下面的变量是否相等 var num1 = 10; //基本数据类型 var num2 = new Number(10); //对象 console.log(num1 == num2); //true console.log(num1 === num2); //false var bool1 = true; var bool2 = new Boolean(true); console.log(bool1 == bool2); //true console.log(bool1 === bool2); //false","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.1oveit.club/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"}]},{"title":"JavaScript简明教程（2）","date":"2016-02-01T05:15:15.000Z","path":"2016/02/01/js-02/","text":"面向对象方法被人谈论了二十多年了，直到今天，我们还一直在谈对象。 三.面向对象编程1.面向层过程和面向对象编程01 面向对象编程和面向过程编程是一种编程思想,和具体的语言关系不大。02 面向过程编程和面向对象编程的主要区别1234567891011121314151617181920面向过程编程: 关注点在于解决问题需要的每一个详细的步骤 示例: 自己洗衣服的过程 ① 收集需要洗的脏衣服 ② 准备洗衣粉、洗衣液等 ③ 把衣服放到一个盆里 ④ 接水 ⑤ 把洗衣粉放到盆里 ⑥ 摩擦,摩擦,不断的摩擦 ⑦ 把洗好的衣服用清水冲洗干净 ⑧ 尽量把把洗好的衣服的水分拧干 ⑨ 晾晒 面向对象编程: 关注点在于解决问题需要的对象身上 示例: 使用洗衣机洗衣服的过程 ① 收集需要洗的脏衣服 ② 找到合适的洗衣机 ③ 设定洗衣服和烘干的程序 03 面向过程和面向对象他们的区别就类似于自己洗衣服和使用洗衣机洗衣服|自己做饭吃和去餐馆吃饭 2.面向对象编程的相关概念01 对象 什么是对象? 所有的一切都是对象,在开发中有一项重要的工作就是对象的划分。一般来说,我们所指的对象是某个具体的事物,而非泛泛的类别。02 对象的特征(静态描述信息) 所谓特征就是一些特定的描述信息 如:学生(性别、年龄、班级、专业、籍贯、家庭住址) 如:汽车(颜色、车牌、品牌、价格等)03 对象的行为(动态特性) 如:人(吃饭、睡觉、玩游戏、奔跑、运动等) 如:狗(吃、睡、咬人、叫、流口水)04 js中的对象 键-值对(key-value)的集合。05 现实生活中的对象和js对象的对应关系 静态的描述信息 - js对象中的属性(属性就是定义在对象内部的变量) 动态的行为特征 - js对象中的方法(方法就是定义在对象内部的函数)06 代码示例：12345678910111213141516171819202122232425 var zhangsan = &#123; name:\"张三\", sex:\"男\", age:18, address:\"天上人间1号公馆\", eat:function () &#123; console.log('能吃'); &#125;, sleep:function () &#123; console.log(\"能睡\"); &#125;, say:function () &#123; console.log(\"能说话\"); &#125;, run:function () &#123; console.log(\"能运动\"); &#125;, song:function () &#123; console.log(\"能唱歌\"); &#125; &#125;; //打印对象的属性并调用相关的方法console.log(zhangsan.name,zhangsan.age,zhangsan.address); zhangsan.say(); zhangsan.sleep(); 3.面向对象的三大特性面向对象的三大特性:封装、继承、多态01 封装:复用|信息隐蔽代码示例123456789101112131415161718192021//01 封装的简单说明//001 观察以下杂乱无关的语句,它们仅仅只是一堆无意义的全局变量var name = \"乘风波浪会有时\";var actors = [\"彭于晏\",\"邓超\"];var showTime = \"2016-1-28 - 2016-2-28\";var director = \"韩寒\";var type = \"喜剧\";var play = function () &#123; //播放......&#125;;//002 把上面的变量封装到对象中(更具有意义)var film = &#123; name:\"乘风破浪会有时\", actors:[\"彭于晏\",\"邓超\"], showTime:\"2016-1-28 - 2016-2-28\", director:\"韩寒\", type:\"喜剧\", play:function () &#123; //播放...... &#125;&#125; 02 继承:获取已经存在的对象已有属性和方法的一种方式(获取他人已有财富和资源的一种方式)。代码示例123456789101112131415//继承的简单示例//001 创建一个空的对象var nullObj = &#123;&#125;;// 上面的对象film拥有了很多的属性和方法//002 设法让nullObj拥有film中所有的属性和方法//方法一:自己重新写一遍//方法二:通过某种方式来获得,比如遍历该对象,然后完成赋值for(var k in film)&#123; nullObj[k] = film[k];&#125;for(var k in nullObj)&#123; console.log(nullObj[k]);&#125; 03 多态(polymorphism) 多态:polymorphism = poly(复数) + morph(形态) + ism 多用于强类型语言中，JavaScript具备与生俱来的多态特性。 多态表现为: ① 同一操作,作用于不同的对象,会产生不同的解释和行为。 ② 隐藏不同。 四.创建对象的方法1.字面量方式创建对象基本写法123456789var book1 = &#123; name:\"声名狼藉者的生活\", price:42.00, author:\"福柯\", press:\"北京大学出版社\", read:function () &#123; console.log(\"我的书名为:声名狼藉者的的生活,作者为福柯....\"); &#125; &#125;; 存在的问题[01] 代码复用性差[02] 如果要创建大量的同类型对象，则需要些大量重复性代码 2.内置构造函数创建对象JS中的内置构造函数123456789StringNumberBoolean 注意：(区别于string number boolean)DateArrayFunctionObjectRegExp 基本写法12345678var book1 = new Object();book1.name = \"声名狼藉者的生活\";book1.price = 42.00;book1.author = \"福柯\";book1.press = \"北京大学出版社\";book1.read = function () &#123; console.log(\"我的书名为:声名狼藉者的的生活,作者为福柯....\");&#125;; 问题01 创建的对象无法复用,复用性差02 如果需要创建多个同类型的对象,如(书籍)则需要写大量重复的代码,代码的冗余度高 3.工厂函数创建对象基本写法12345678910111213141516171819202122function createBookNew (name,price,author,press) &#123; var book = new Object(); book.name = name; book.price = price; book.author = author; book.press = press; book.read = function () &#123; console.log(\"我的书名为:\"+book.name+\",作者为\"+book.author+\"....\"); &#125;; return book;&#125;//使用工厂函数来创建对象var book1 = createBookNew(\"声名狼藉者的的生活\",\"42.00\",\"福柯\",\"北京大学出版社\");var book2 = createBookNew(\"人性的枷锁\",\"49.00\",\"毛姆\",\"华东师范大学出版社\");var book3 = createBookNew(\"悟空传\",\"28.00\",\"今何在\",\"湖南文艺出版社\");//打印对象的属性,调用对象的方法console.log(book1.name);console.log(book2.name);console.log(book3.name);book1.read();book2.read();book3.read(); 工厂函数说明:001 工厂函数方式创建对象其本质是对内置构造函数创建对象的过程进行了封装002 适用于大规模“批量生产”同类型的对象1234567891011121314function createBook (name,price,author,press) &#123; //001 参数 = 原料 var book = new Object(); //002 创建对象并设置对象的属性和方法 = 对原料进行加工 book.name = name; book.price = price; book.author = author; book.press = press; book.read = function () &#123; console.log(\"我的书名为:\"+book.name+\",作者为\"+book.author+\"....\"); &#125;; //003 把处理好的对象返回给我们 == 产品出厂 return book;&#125; 封装思路:使用函数把固定不变的部分封装起来，变化的部分提取为函数的参数。工厂函数创建对象的实现过程:① 提供一个创建对象的函数（参数）② 在该函数内部使用new 关键字和Object构造器创建对象③ 设置对象的属性④ 设置对象的方法⑤ 返回对象 4.自定义构造函数创建对象基本写法123456789101112131415function 构造函数名(参数1,参数2,参数3...) &#123; //设置对象的属性 this.属性01 = 参数1; this.属性02 = 参数2; //设置对象的方法 this.方法01 = function () &#123; //..... &#125;; this.方法02 = function () &#123; //..... &#125;&#125;//自定义构造函数方式创建对象var 对象01 = new 构造函数名(实参01,实参02,实参03...);var 对象02 = new 构造函数名(实参01,实参02,实参03...); 代码示例12345678910111213141516171819function CreateBook (name,price,author,press) &#123; this.name = name; this.price = price; this.author = author; this.press = press; this.read = function () &#123; console.log(\"我的书名为:\"+this.name+\",作者为\"+this.author+\"....\"); &#125;;&#125;var b1 = new CreateBook(\"声名狼藉者的的生活\",\"42.00\",\"福柯\",\"北京大学出版社\");var b2 = new CreateBook(\"人性的枷锁\",\"49.00\",\"毛姆\",\"华东师范大学出版社\");var b3 = new CreateBook(\"悟空传\",\"28.00\",\"今何在\",\"湖南文艺出版社\");//打印对象的属性,并调用对象的方法测试console.log(b1.author);console.log(b2.author);console.log(b3.author);b1.read();b2.read();b3.read(); 构造函数与new关键字:new关键字的作用：用于创建对象（Object类型）。构造函数和普通函数的区别：函数的首字母大写。构造函数的作用:用于完成对象的初始化。 自定义构造函数和简单工厂函数的对比：1234① 函数的首字母大写(用于区别构造函数和普通函数)② 创建对象的过程是由new关键字实现③ 在构造函数内部会自动的创建新对象,并赋值给this指针④ 自动返回创建出来的对象 构造函数的执行过程① 使用new关键字创建对象② 把新创建出来的对象赋值给this③ 在构造函数内部,使用this为新创建出来的对象设置属性和方法④ 默认返回新创建的对象(普通函数如果不显示的return则默认返回undefined)。 构造函数的返回值01 如果在构造函数中没有显示的return,则默认返回的是新创建出来的对象02 如果在构造函数中显示的return,则依照具体的情况处理 [01] return 的是对象,则直接返回该对象,取而代之本该默认返回的新对象 [02] return 的是null或基本数据类型值,则返回新创建的对象 构造函数方式创建对象存在的问题每次创建对象,都会重新创建函数，那么如果创建的对象数量很多,而对象方法内部的实现一模一样,则造成了资源浪费。 构造函数的使用注意函数传值：可以把构造函数的对象方法抽取为参数。代码示例：1234567891011121314151617//001 创建一个构造函数function Person(name,age,toDoSomeThing) &#123; //002 在构造函数内部设置对象的属性和方法 this.name = name; this.age = age; this.sayName = function () &#123; console.log(this.name); &#125;; this.toDoSomeThing = toDoSomeThing;&#125;//003 使用构造函数创建对象var zhangsan = new Person(\"张三\",18,function () &#123; console.log(\"张三在读书\");&#125;);var lisi = new Person(\"李四\",20,function () &#123; console.log(\"李四在玩耍\");&#125;); 对象类型:01 检查对象的类型：instanceOf02 获取对象的类型：Object.prototype.toString.call(dog) 对象的构造器属性12345function Dog(name) &#123; this.name = name; this.color = \"黄色\"; &#125;console.log(dog.constructor); 属性的名称：constructor属性的作用：指向创建该对象的构造函数，类似于现实生活中所有的产品都标有生产厂家一样。 构造函数的调用01 构造函数可以像普通函数一样不通过new关键字直接调用02 在使用构造函数创建对象的时候，如果没有传递参数，则（）可以省略代码示例:1234567891011//01 创建构造函数function Person() &#123; this.name = \"张三\"; this.age = 20; this.sayName = function () &#123; console.log(this.name); &#125;&#125;//02 使用构造函数创建对象var p1 = new Person();var p2 = new Person; //说明:如果不需要传递参数,则在调用构造函数的时候()可以省略 this指向01 如果使用new 构造函数的方式调用，则this指向内部默认创建出来的空对象02 如果像调用普通函数一样调用构造函数，则this指向全局对象window(不要这样使用) 5.原型对象原型对象概念 在构造函数创建出来的时候,系统会默认帮构造函数创建并关联的一个新对象 自定义构造函数的原型对象默认是一个空对象。 原型对象的作用 构造函数中的原型对象中的属性和方法可以被使用该构造函数创建出来的对象使用。 即以自定义构造函数方式创建出来的所有对象,自动拥有和共享该构造函数的原型对象中的所有属性和方法。 如何访问构造函数的原型对象① 构造函数.protoType② 对象.__proto__（不推荐） 设置原型对象的属性和方法① 利用对象的动态特性来为构造函数的原型对象添加属性和方法② 替换原型对象 实例和实例化：实例化:通过构造函数创建具体对象的过程。实例:通过构造函数实例化出来的对象,我们称之为该构造函数的一个实例。注意:在说实例的时候,一定要指定是某个具体构造函数的实例。 原型的使用方法① 利用对象的动态特性给原型添加属性|方法，如果要添加的方法过多,则有大量重复代码。② 直接替换原型对象：01 替换前后创建的对象所指向的原型对象不一致02 替换原型对象会切断和之前的原型对象之间的关系 原型对象的使用注意1234567① 访问属性:构造函数创建出来的对象在访问属性的时候,会先在实例内查找,如果没有找到则进一步到对应的原型对象中查找。② 设置属性:在使用点语法进行赋值的时候,无法操作到对应的原型对象,如果该属性在对象中已经存在，则修改该属性的值。如果该属性在对象中尚未存在,则新增该属性。③ 设置原型对象的属性:[01] 设置原型对象的属性,只能通过构造函数.Prototype的方式替换原型对象的方式设置。[02] 如果原型对象的属性是值类型，那么只能通过Person.prototype.属性的方式修改其值。如果原型对象的属性是引用类型,那么可以通过对象名.引用对象.属性名的方式设置修改： (001) 使用构造函数创建出来的多个对象的原型对象中的该属性指向的是同一块数据。 (002) 某个对象对该原型对象属性进行了修改会影响到其他的对象。 __proto__属性说明：__proto__是一个非标准属性,即ECMAScript中并不包含该属性,这只是某些浏览器为了方便开发人员开发和调试而提供的一个属性,不具备通用性。建议:在调试的时候可以使用该属性,但不能出现在正式的代码中。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.1oveit.club/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"}]},{"title":"JavaScript简明教程（1）","date":"2016-01-15T08:36:35.000Z","path":"2016/01/15/01/","text":"JavaScript与Java没有半毛钱关系，网景公司员工Brendan Eich用了10天时间设计了JavaScript语言。 一.JavaScript的范围JavaScript的范围：BOM + DOM + ECMAScript 1.BOM简单说明123456BOM即Browser Object Mode,浏览器对象模型。BOM提供了独立于内容而与浏览器窗口进行交互的对象。BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。因为BOM主要用于管理窗口与窗口之间的通信，因此其核心对象是window。BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C。BOM结构体系 2.DOM简单说明12345DOM即Document Object Model，文档对象模型。当网页被加载时，浏览器会创建页面的文档对象模型，即DOM。DOM(文档对象模型)被构造为对象的树。DOM由一系列相关的对象构成，引申为Document对象。DOM的标准化组织是W3C。 3.ECMAScript简单说明123456789ECMAScript指代JavaScript的核心语法。JavaScript 由 Brendan Eich 发明。JavaScript于1995 年出现在 Netscape 中于 1997 年被 ECMA（一个标准协会）采纳。语法核心：变量基本数据类型对象类型结构(循环|条件|判断)面向对象 二.javascript语法1.javascript数据类型基本类型（简单数据类型） * string * number * boolean * undefined * null 复杂类型（复杂数据类型） * Object * Array * Date * RegExp * Function * String * Number * Boolean * null * Math 2.javascript部分操作符的说明2.1一元操作符只能够操作一个值的操作符叫做一元操作符。① 递增和递减操作符:12345678910[01] 前置型,递增和递减操作在包含他们的语句被求值之前就执行。[02] 后置型,递增和递减操作在包含他们的语句被求值之后才执行。var num1 = 2;var num2 = 20;var num3 = --num1 + num2; //21var num4 = num1 + num2; //21var num1 = 2;var num2 = 20;var num3 = num1-- + num2; //22var num4 = num1 + num2; //21 ② 一元加和减操作符:一元加操作符对结果不会有任何的影响。一元减操作符主要用于表示负数。 2.2位操作符01 按位非(NOT):使用 ~ 表示，执行按位非的结果就是返回数值的反码。操作数的负值减去1。123var num1 = 25;var num2 = -num1 - 1; //-26consol.log(~num1) //-26 02 按位与(AND):使用&amp;表示，操作两个操作数。只要有0就为0。03 按位或(OR):使用|表示，操作两个操作数。只要有1就为1。04 按位异或(XOR):使用 ^ 表示，操作两个操作数。相同则为0，不同则为1。05 左移|右移(|有符号|无符号)。 2.3布尔操作符 布尔操作符一共有三个，分别是：非、与、或。 01 逻辑非，符号：！ 说明：取反，可应用于任何值，！！相当于没有操作。02 逻辑与，符号：&amp;&amp; 说明：两个值都为真的时候，结果为真。属于短路操作，如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。03 逻辑或，符号：||说明：两个值只要有一个为真，那么结果为真。属于短路操作，如果第一个操作数为真，那么就不会再对第二个操作数求值了。技巧：可以利用逻辑或短路操作的特点来避免为变量赋null或undefined值。123var myObject = refObject || backupObject;//如果refObject的值不是null,那么它的值将被赋值给myObject//如果是null,那么就将backupObject的值赋值给myObject。 2.4乘性操作符乘 *除 /模 % 2.5加性操作符加 +减 - 说明：上述五种操作符在操作数为非数值的时候内部会执行自动的类型转换。 2.6关系操作符大于 &gt;小于 &lt;小于等于 &lt;=大于等于 &gt;=说明：返回布尔类型的值，要么为false，要么为true。 2.7相等操作符01 相等和不相等[先转换再比较]，符号是 == 和！=比较的规则:[01] 如果操作数中有布尔值，则先转换为数值再比较。[02] 如果是字符串和数值比较，则先将字符串转换为数值再比较。[03] 如果是对象和其他类型的值比较，则先调用对象的valueOf方法，然后用得到的基本类型值去比较。[04] null和undefined是相等的。[05] NaN和NaN不相等。[06] 如果两个操作符都是对象，则比较他们是不是同一个对象，如果指向的是同一个对象则返回true，否则返回false。02 全等和不全等[仅比较不转换],符号是===和!==比较的规则:[01] null和undefined是不全等的，因为它们是不同类型的值。[02] 类型相同，且值相等，则返回true，否则返回false。 2.8条件操作符符号：表达式1 ? 字面量1 ：字面量2说明：如果表达式1的结果为true，则使用字面量1，否则使用字面量2。 2.9赋值操作符符号：=、+=、-=、*=、&lt;&lt;=等等说明：使用赋值操作符对性能而言，没有任何的提升，只是简化了赋值操作而已。 3.值类型和引用类型01 值类型和引用类型简单说明值类型主要有：12345数值字符串布尔类型undefinednull 引用类型主要有：123对象（Object类型）数组（Array）函数 (Function) 值类型：保存为简单的数据值，赋值只是简单的数据值的复制引用类型:保存为对象，其本质是指向内存位置的引用(地址)，赋值是对地址的复制值类型代码示例1234567var num1 = 10;var num2 = num1; //把num1的值复制一份给num2,num1和num2的值相等,除此之外没有任何其他关系console.log(num1,num2); //10,10console.log(num1 == num2); //truenum2 = 20; //修改num2的值为20,不会对num1产生任何的影响console.log(num1,num2); //10,20console.log(num1 == num2); //false 引用类型代码示例12345678910111213var arr1 = [1,2,3];var arr2 = arr1;console.log(arr1,arr2); //[1,2,3],[1,2,3]console.log(arr1 == arr2); //truevar arr3 = [1,2,3];console.log(arr3); //[1,2,3]console.log(arr1 == arr3,arr2 == arr3); //false,false/** * 代码说明: * arr1和arr2在比较的时候,值相等(都是[1,2,3]),且引用相等(都指向堆中同一块数据),因此arr1和arr2相等 * arr3和arr1以及arr2比较的时候,值相等([1,2,3]),但是引用不相等(arr3指向的是堆中另外一块数据),因此不等 * 总结:引用类型在比较相等的时候,只有值和引用都相等才相等 * */ 02 值类型和引用类型的赋值赋值操作(=):把当前变量存储的值复制一份给接收的变量。值类型的赋值:把当前变量存储的值(具体的数据)复制一份给接收的变量。引用类型的赋值:把当前变量存储的值(具体数据的引用即地址)复制一份给接收的变量。12345678//引用类型使用注意 console.log(arr1,arr2); //[1,2,3],[1,2,3]; console.log(arr1 == arr2); //true arr1.push(4); console.log(arr1,arr2); //[1,2,3,4],[1,2,3,4] /** * 代码说明:因为arr1和arr2内部的引用指向的是同一块数据,所以修改了arr1会对arr2也产生影响 * */ 03 值类型和引用类型作为函数参数处理形参:占位用的参数,用来接收数据的参数而已。实参:实际传递的参数。函数的调用:在函数调用的时候,函数默认会把实参的值赋值给形参。值类型作为参数：在函数内部对形参变量进行修改不会影响到实参的值。引用类型作为参数：在函数内部对形参变量进行修改会影响到实参的值，因为他们的引用指向同一个对象。04 值类型和引用类型的相关图示基本类型的赋值12var str1 = \"hello zhangsan\";var str2 = str1; 引用类型的结构和赋值123456789var car = &#123; color:\"黑色\", number:\"B99\"&#125;;var p1 = &#123; name:\"王宝宝\", age:30, car:car&#125;; 12345var obj1 = &#123; name:\"lisi\", age:18 &#125;; var obj2 = obj1; 4.对象的动态特性在js中可以动态的对对象属性进行增加、修改和删除；代码示例12345678910111213141516171819//01 创建对象var obj = &#123; name:\"刘德华\", age:60&#125;;//02 动态的为对象添加属性obj.height = \"180cm\";console.log(obj.height);//03 动态的为对象添加方法obj.maiMeng = function () &#123; console.log(\"华仔会卖萌噢\");&#125;;obj.maiMeng();//04 修改属性的值:如果设置的属性以前不存在,那么就是添加,如果设置的属性已经存在了,那么就是修改obj.name = \"王宝强\";console.log(obj.name)//05 删除属性delete obj.name;console.log(obj.name); //undefined 访问对象的方法01 可以使用点语法访问02 可以使用[]语法访问，注意对象的属性必须是字符串 5.关键字in和delete的使用01 in关键字01 判断属性是否存在于对象中，注意所有的key都是字符串02 for in循环中 遍历对象的 键代码示例12345678910var obj = &#123; name:\"张三\", age:18&#125;;for(k in obj)&#123; console.log(k,obj[k]);&#125;//检测obj对象中是否存在name这个属性console.log(\"name\" in obj); 注意：in关键字操作数组的时候检测的是索引值并非数组元素02 delete关键字01 删除对象的属性02 删除未使用var声明的变量03 返回值为boolean类型，true则表示是否删除成功注意1201 删除的属性如果不存在，返回true02 删除的如果是原型中的属性，返回true 但是删除不成功 6.循环和分支循环结构1234forwhiledo...whilefor..in 分支结构12if...else..swith..case break和continue对比break:终止循环，循环中后面的代码不再执行continue:结束当前循环，循环后面的代码不再执行，继续下一次循环 7.调试工具的使用开启调试窗口 windows 平台: f12; Mac: option+command+i;调试窗口介绍 指针: 选择页面中的元素 手机: 使用移动端界面调试 Elements: 查看页面 DOM 树 Console: 控制台(注意, 控制台与该页面是一个整体, 在控制台中的任何操作, 会影响到页面) Source: 代码调试调试工具的使用 逐过程运行, 一次运行一个函数 单步运行(逐步运行), 一次运行一句, 如果是函数, 进入函数体内运行 继续运行. 从当前状态运行下去, 直到出现断点, 如果没有断点则运行结束设置断点技巧 逐步与逐过程混合 断点加继续运行 条件断点(右键添加 add contitional breakpoint)利用 watch 监视窗口可以查看对象成员 8.异常处理常见的异常分类运行环境的多样性导致的异常（浏览器）语法错误，代码错误异常的特征:一旦代码出现异常，后面的代码就不会再执行异常捕获使用try-catch语句捕获异常123456try&#123; //这里写可能出现异常的代码&#125;catch(e)&#123; //这里的e就是捕获的异常对象 //可以在这里写，出现异常后的处理代码&#125; 异常捕获语句执行的过程为：01 代码正常运行, 如果在try中出现了错误, try 里面出现错误的语句后面的代码都不再执行, 直接跳转到 catch 中02 在catch中处理错误信息03 继续执行后面的代码04 如果 try 中没有出现错误, 那么不走 catch 直接执行后面的代码捕获异常的优点：通过try-catch语句进行异常捕获之后，代码将会继续执行，而不会中断。注意：语法错误异常用try-catch语句无法捕获，因为在预解析阶段，语法错误会直接检测出来，而不会等到运行的时候才报错。try..catch使用示例1234567891011121314151617//01 try ... catch结构的使用//a(); 若直接调用则爆出:Uncaught ReferenceError: a is not defined错误//在开发中,我们对于可能会报错或者是发生异常的代码用try结构进行处理try&#123; a(); //如果发生异常,那么至少不会到正程序中断&#125;catch(e)&#123; //如果try语句中发生了异常,那么会执行此处的代码块 //参数e.为具体的异常信息,可以打印进行查看 console.log(e);&#125;function functionTest() &#123; console.log(\"functionTest\");&#125;;functionTest();//结论:使用try...catch结构,如果发生了异常,那么不会影响后面代码的执行,且我们可以在发生异常信息之后做出具体的处理 手动抛出异常案例：自己写的一个函数，需要一个参数，如果用户不传参数，此时想直接给用户抛出异常，就需要了解如何抛出异常。抛出异常使用throw关键字，语法如下：手动抛出异常信息（字符串）:123456789101112131415try&#123; //a(); //如果发生异常,那么至少不会到正程序中断 //不使用系统默认的异常信息,尝试手动抛出 throw \"对不起,您调用了尚未定义的方法\";&#125;catch(e)&#123; //如果try语句中发生了异常,那么会执行此处的代码块 //参数e.为具体的异常信息,可以打印进行查看 console.log(e);&#125;function functionTest() &#123; console.log(\"functionTest\");&#125;;functionTest(); 手动抛出异常信息（对象）:1234567891011121314151617181920212223try&#123; //a(); //如果发生异常,那么至少不会到正程序中断 //不使用系统默认的异常信息,尝试手动抛出 throw &#123; errMsg:\"具体的错误信息提示\", errCode:\"指定错误类型的代号,如1001等\" &#125;;&#125;catch(e)&#123; //如果try语句中发生了异常,那么会执行此处的代码块 //参数e.为具体的异常信息,可以打印进行查看 console.log(e); //在try语句中抛出的错误信息是什么,那么得到的异常信息就是什么 //如果抛出的是字符串,那么得到的就是字符串 //如果抛出的是对象,那么此处得到的就是对象 console.log(e.errMsg); console.log(e.errCode);&#125;function functionTest() &#123; console.log(\"functionTest\");&#125;;functionTest(); 异常捕获语句的完整模式异常捕获语句的完整模式为try-catch-finally123456789101112131415try&#123; //在执行的时候可能发生异常的代码 b();&#125;catch (e)&#123; //如果try代码块中的代码在执行中发生了异常,那么就会执行该代码块的代码 //通过打印e对象可以查看具体的异常信息 console.log(e); //打印异常信息&#125;finally &#123; //不论try语句中的代码是否会发生异常,都一定会执行此处的代码块 //一般在前端开发中很少使用,常用语后台开发的资源释放工作 console.log(\"无论如何总要执行的代码\");&#125; finally中的代码，不管是否发生异常，都会执行。一般用在后端语言中，用来释放资源，JavaScript中很少会用到。 9.DOM操作获取元素操作123getElementByIdgetElementsByTagNamegetElementsByClassName 元素节点操作1234567appendChildinsertBeforeremoveChildreplaceChildcloneNodecreateElementcreateTextNode（创建文本节点） 属性节点操作123getAttributesetAttributeremoveAttribute 常用DOM属性1234classNameinnerHTMLinnerText/textContent valuechildren 代码示例12345678910111213141516//0 获取页面中指定的标签,并设置其样式 var divID = document.getElementById(\"divId\"); divID.style.backgroundColor = \"pink\"; divID.style.height = \"40px\"; divID.style.width = \"200px\"; //01 创建新的标签 var div = document.createElement(\"div\"); //02 设置标签的样式 div.style.backgroundColor = \"red\"; div.style.height = \"100px\"; div.style.width = \"300px\"; div.style.fontSize = \"20\"; //03 设置标签的内容 div.innerText = \"这是一个自己创建的标签\"; //04 把标签插入到页面中 document.body.appendChild(div);","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.1oveit.club/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"}]},{"title":"JSONP跨域","date":"2016-01-07T16:55:40.000Z","path":"2016/01/08/JSONP跨域/","text":"Asynchronous JavaScript and XML (Ajax) 是Web2.0的关键技术。AJAX与服务器交换数据刷新局部网页,不需重载。 因为浏览器及同源策略的限制，ajax不允许跨域通信。同源是指协议、域名和端口都一致的情况。同源策略保证一个源的动态脚本不能读取或操作其他源的http响应和cookie，使浏览器隔离不同源的内容之间互相操作。 Access-Control-Allow-Origin解决跨域问题可以在第三方网站开启HTTP的Access-Control-Allow-Origin参数，当目标页面的response包含Access-Control-Allow-Origin 这个header，而且还包含我们的域名时，浏览器就允许拿到它页面的数据：1Access-Control-Allow-Origin: http://www.1oveit.club 当值为 * 表示匹配所有，都能用：1Access-Control-Allow-Origin: * 但是此时的主动权不在我们手里。 JSONP解决跨域还可以使用更为主动的方法，使用JSONP解决跨域问题。分为以下几步：我们知道多个不同的script标签中的数据是可以相互访问的，而script的src的本质就是将导入文件中的内容拷贝到当前script标签中，我们拿到百度搜索URL地址：1https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=ab&amp;cb=jQuery11020672211218553074_1491468814655 搜索之后的结果：1jQuery11020672211218553074_1491468814655(&#123;q:&quot;ab&quot;,p:false,s:[&quot;abs&quot;,&quot;ab胶&quot;,&quot;abc&quot;,&quot;abac形式的成语&quot;,&quot;abcc形式的成语&quot;,&quot;abab式的词语&quot;,&quot;abo&quot;,&quot;abp&quot;,&quot;abstract&quot;,&quot;abs塑料&quot;]&#125;); 从而可以引出跨域(jsonP)原理：1.src可以拿到非当前域的数据。2.script的src的本质就是将导入文件中的内容拷贝到当前script标签中。3.如果src返回的数据符合 函数名称(参数); 格式, 那么就可以实现跨域。具体例子：在本地的文件的script准备回调函数say,123function say(obj) &#123; console.log(obj); &#125; 通过script的src属性拿到百度要搜索的URL并且拼接?wd=ab&amp;cb=say参数，如下：1&lt;script src=&quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=ab&amp;cb=say&quot;&gt;&lt;/script&gt; 最后，调用say方法，1say(&#123;q:&quot;ab&quot;,p:false,s:[&quot;abs&quot;,&quot;ab胶&quot;,&quot;abc&quot;,&quot;abac形式的成语&quot;,&quot;abcc形式的成语&quot;,&quot;abab式的词语&quot;,&quot;abo&quot;,&quot;abp&quot;,&quot;abstract&quot;,&quot;abs塑料&quot;]&#125;); 具体例子： //1.使用src，请求数据 &lt;script src=\"http://datainfo.duapp.com/shopdata/getGoods.php?callback=callback\"&gt; //2.在本地声明一个方法 function callback(args) { console.log(args); } //3.要在服务端要处理跨域 $res = $_GET['callback']; echo $res.\"('我是服务的数据')\"; function callback(args) { console.log(args); } &lt;/script&gt; &lt;!-- 如果服务器返回的是js代码，那么浏览器就会直接执行js代码 借助浏览器的特性来实现跨域 --&gt; &lt;script src=\"http://datainfo.duapp.com/shopdata/getGoods.php?call6‘back=callback\"&gt;&lt;/script&gt; 总体的流程大概就是这样子，不过实际开发中要与后台定好接口，希望能够帮到你。","tags":[{"name":"JSONP跨域","slug":"JSONP跨域","permalink":"http://www.1oveit.club/tags/JSONP跨域/"}]},{"title":"可能是最简单的js原型继承","date":"2015-12-08T07:35:45.000Z","path":"2015/12/08/js原型继承/","text":"JavaScript是一门奇妙的弱类型语言，原型继承与其它语言的类继承有所区别，下面通过一个简单的例子展示js的原型继承。 1.你有对象吗？你有对象吗？没有，赶紧就new一个吧！首先，创建构造函数Parent然后，new出一个Parent的实例对象child此时，构造函数Parent拥有以下属性aString、aNumber、anObject,构造函数Parent的原型对象有aFunction方法。12345678910function Parent() &#123; this.aString = 'string'; this.aNumber = 'number'; this.anObject = 'object'&#125;Parent.prototype = &#123; constructor: Parent, aFunction: function()&#123; alert('i am function'); &#125; 然后，new出一个Parent的实例对象child1var child = new Parent(); 简单的原型继承图如下： 2.实现继承实例对象默认拥有构造函数本身的属性和方法。但是，要知道构造函数荷构造函数的原型对象是俩个不同的函数（对象），原型对象拥有的属性和方法可以被实例化对象所共享。也就是说实例对象child此时拥有属性aString、aNumber、anObject，this指向实例对象。child本身并没有aFunction方法。但是你调用此方法时，却发现能调用，这是怎么回事呢？1child.aFunction(); 这就是我们所说的原型对象原拥有的属性和方法可以被实例化对象所共享的原因。通过简单的例子，希望能帮到你，如果想深入学习javascript，请深戳MDZ开发者","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.1oveit.club/tags/javascript/"},{"name":"原型继承机制","slug":"原型继承机制","permalink":"http://www.1oveit.club/tags/原型继承机制/"}]},{"title":"有趣的Chrome DevTools","date":"2015-11-11T13:46:45.000Z","path":"2015/11/11/有趣的ChromeDevTools/","text":"Chrome 自带开发者工具很有趣，怎么个有趣法呢？Chrome的JS控制台有很多很多神奇而且有趣的功能。此文仅例举其中几个，一起来看看吧。 我们调试的时候控制台总会有一大堆密密麻麻的代码时，请试着输入 clear() 然后回车，清空所有，回到原始界面。 1.jq选择器第一个有趣的事情就是获取页面上的DOM元素啦！在控制台里通过jQuery选择器选取DOM元素. 如 $(&#39;tagName&#39;) $(&#39;.class&#39;) $(&#39;#id&#39;)等选择器。其实是通过document.querySelector(‘’)返回第一个匹配的DOM元素。通过 $$(&#39;tagName&#39;) $$(&#39;.className&#39;)两个$$符号来选择返回的一个相应的DOM数组。瞧： 2.获取DOM元素绑定事件其实也是一句代码搞定的事情，但是在调试的时候却非常有用。通过在控制台输入getEventListeners($(&#39;selector&#39;))返回数组对象的格式并且返回元素绑定的所有事件。然后通过getEventListeners($(&#39;selector&#39;)).click[0].listener获取元素绑定的click事件。 3.Chrome编辑器如果浏览器可以编辑，要记得导出喔。在控制台轻轻输入一句代码，然后试着编辑页面，接下来就是奇迹发生的时候！赶快试一下吧！ 4.监测事件通过输入monitorEvents($(&#39;selector&#39;)) 监测元素上绑定的所有事件，该元素某个事件被触发就会在控制台里显示出来。monitorEvents($(&#39;selector&#39;),&#39;eventName&#39;)监听元素上绑定的具体事件。第二个参数代表事件类型的名称。monitorEvents($(&#39;selector&#39;),[&#39;eventName1&#39;,&#39;eventName3&#39;,….])同时检测具体指定的多个事件类型。unmonitorEvents($(&#39;selector&#39;)) 用来停止对某个元素的事件监测。 5.表格形式输出数组先输入数组arr,然后通过输入console.table(variableName)以表格形式查看，如下图： 6.检查元素你可以直接在控制台里输入下面的方法来检查元素inspect($(&#39;selector&#39;)) 会检查所有匹配选择器的DOM元素，并返回所有选择器选择的DOM对象。inspect($(&#39;img&#39;)[1]) 检查并返回页面上第2个img元素。最后，Chrome DevTools是十分强大的调试工具，这只是冰上一角，深入了解请戳chrome-devtools","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.1oveit.club/tags/javascript/"},{"name":"Chrome DevTools","slug":"Chrome-DevTools","permalink":"http://www.1oveit.club/tags/Chrome-DevTools/"}]},{"title":"五分钟学会简单使用git","date":"2015-09-22T16:00:00.000Z","path":"2015/09/23/五分钟学会简单使用git/","text":"五分钟，简单入门。学会之后可以愉快的管理你的文件啦。 简单使用git 其实很简单，有多简单呢？ 1. git init 初始化一个仓库； 2. git add . 添加文件到暂存区； 3. git commit -m&apos;messeage&apos; 提交至版本库； 4. git push origin master 推送至远程仓库； 分支管理什么是平衡分支？实际工作中一般新建平衡分支用于开发调试等，然后再合并到主分支。 1.git checkout -b dev 新建dev分支并切换到dev分支。 相当于：git branch dev 创建dev分支； git checkout dev 切换到dev分支； 2. 开发或者调试结束后 git add * 添加所有文件到暂存区； git commit -m&apos;messeage&apos; 提交至版本库； 3.git checkout master 切换到主分支； git merge dev 合并分支； git branch -d dev 删除分支； 解决冲突什么是冲突？同一份文件同一个地方被不同的协作者修改了，最后一个推送至远程的会产生冲突。 解决冲突：git pull 更新本地仓库 打开冲突文件，找到冲突部分，协调修改。 1 TODO 2 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 3 我修改的 4 ======= 5 协作者修改的 6 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 经过协调，修改为 1 TODO 2 经过协调修改的 到这里，你已经基本上掌握了git的使用了，想再深入了解，请点击git Pro中文","tags":[{"name":"git","slug":"git","permalink":"http://www.1oveit.club/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"http://www.1oveit.club/tags/版本控制/"}]},{"title":"12年逗比如我","date":"2015-04-15T13:27:45.000Z","path":"2015/04/15/12年怀旧/","text":"12年写的乱七八遭，拿出来怀旧，权当笑话，笑笑更开心！ 一周大一秀欢迎收听一周大一秀，观众朋友们大家好。好学生就是我，我就是曾大贤。欢迎收听本节目，请大家用热烈的掌声欢迎我们今天的主角出场。他就是人见人爱，花见花开，俗称一朵海棠压梨花的帅哥。没错，你猜对了，好学生就是我，我就是曾大贤。接下来请大家千万把耳屎勾干净了，洗耳恭听嘛，哈哈。大学就是围墙啊，在外面的人都想跳进来，在里面的人都想跳出去。曾哥我真的是深深的有感触啊！此事从五百年前说起，曾哥在一个夜黑风高的晚上，血腥的风放肆嘲笑满街的横尸遍野。曾哥右持AK_47，左携一篮子地雷，嘴叼雪茄【此音乐响起上海滩】，在千军万马中杀了出来。就这样，千军万马来相见，曾哥突破了大学这道围墙，杀进了大学【此时音乐响起天空之城】。进了大学这道墙，曾哥欣喜若狂，因为按照传说，就可以不费吹灰之力拥有一切，以后开宝马，住洋房，娶洋妞都不用愁了。以为到了世外桃源，曾哥很高兴地把AK_47丢进了河里，把一篮子地雷也扔了进去【此时音乐响起乌鸦的惨叫声】，只留下嘴刁着的那根雪茄，用来扮酷讨女孩子欢心。 故事到这里，相信大家都能猜到后果了，很遗憾广告时间到了，请大家不要走开，广告之后更精彩【好敌真好，广州好敌】。欢迎大家继续收听一周大一秀，好学生就是我，我就是曾大贤。曾大贤接下来何去何从，精彩不容错过。曾大贤被传说给传说了，接下来的日子里，他就只能做这些事了，哎【MUSIC阿里路亚】 摸黑起床，叫兽整队，准备抗战。有的时候还没来得及刷牙洗脸，就匆匆忙忙赶去与英语口语决一死战。战罢方休，一个馒头一个大饼是战利品。军纪如律令，又赶忙去找营地，生怕触犯律令，有时不得不一边啃着个窝窝头一边找赶上军队去扎营。糊糊涂涂的坐在营里，听叫兽讲那些讲那些似懂非懂的军事理论知识，时间很快到了中午。战友总在催，不走快点，就要吃剩饭，呜呜，排队打饭订餐，弄得曾哥连吃饭的心情都没有了。好不容易吃完了午饭，曾哥本想舒舒服服睡上一觉，怎知社团活动来风急。曾哥可怜的午休时间那，就这么被无情的摧残了。 俗话说，中午不睡，下午崩溃。果不其然，曾哥整个下午都崩溃掉了【音乐伤不起啊伤不起】。顶着乏意，毫无生机。曾哥恹恹欲睡，却又不敢入睡。闭着眼睛也能跟着叫兽打军体拳，曾哥实在是太强大了！ 时间一晃而过，本来打算美美的洗个澡的，可是时间急迫啊。七点就要站岗放哨，又是军纪如律令，所以洗澡这事给挂了。一来省些水资源，二来嘛省钱，你懂的，哈哈。终于曾哥下岗了，夜生活真正开始了。手机上网畅无线，莺歌电影嗨翻天十一二点不算晚，就看你的肾好不好，额滴肾啊，哈哈。 大学生活就是沙场点兵，而曾哥却总还能打怪兽。一部手机可以有几多个怪兽，曾哥说菲尔普斯专用山寨机，就是牛。曾哥追师姐也真是牛，来一个杀一个，来两个杀一双。可是你懂的，曾哥最终还是情伤了【音乐响起我是个容易受伤的男人】，因为长得太帅了没办法，不知道选那一个啊。【音乐响起请你不要迷恋哥，嫂子会打你的】 曾哥受伤了，曾哥想家了。【音乐响起常回家看看】曾哥哭了【音乐男人哭吧哭吧不是罪】，曾哥想到了AK_47，想到了地雷，但只剩嘴里那根烟了，杀不回去了。 还好，周末给了曾哥继续下去的理由。叫兽说，睡觉是对周末的最起码的尊重。曾哥一向是守法的孩子，所以周末有事没事要找曾哥的孩子，请留言，曾哥已睡死，哈哈。 当然这是不可能的事，因为叫兽还说过，来到洛阳，你不去外面转转，就可惜了。河山大好，洛阳正好。老师说到曾哥就做到，所以周末成了曾哥的旅游时间。一个地方总会有一个地方的好，洛阳正是个好地方。大学你所在的城市，你对他有了解多少呢？嘿嘿，趁周末完，像曾哥一样，出去转转吧，别待在宿舍当懒虫。音乐响起许嵩的【河山大好：电脑看太久了脖子也会酸，数字时代貌似把生活节奏加快，也让人变得行动迟缓起来。忙忙忙，忙不出个所以然，地球就算累了它照样会公转自转。叹叹叹，弹指一挥人生苦短，终点不明沿途风景要好好看。你可以隐隐的期待，途中佳缘的带来，保持一个浪漫的心态，活着就不算坏】。 感谢大家一路相伴，本期节目到此结束。曾哥究竟会在大学有何作为呢？","tags":[{"name":"娱乐","slug":"娱乐","permalink":"http://www.1oveit.club/tags/娱乐/"},{"name":"怀旧","slug":"怀旧","permalink":"http://www.1oveit.club/tags/怀旧/"}]}]