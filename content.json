{"meta":{"title":"Afanail","subtitle":"Afanail,阿发奶酪","description":"前端,js,jquery,javascript,html5,开发者,程序猿","author":"Afanail","url":"http://www.1oveit.club"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2017-05-11T14:26:29.000Z","updated":"2017-05-11T14:26:29.000Z","comments":false,"path":"/404.html","permalink":"http://www.1oveit.club//404.html","excerpt":"","text":"!(神奇的鸡)[/assets/img/404.jpg]"},{"title":"about me","date":"2017-05-11T09:21:56.000Z","updated":"2017-05-11T13:07:58.000Z","comments":true,"path":"about/index.html","permalink":"http://www.1oveit.club/about/index.html","excerpt":"","text":"Afanail:email:zjfapk@163.com专注于前端主球队：Manchester UnitedGolden State Warriors七月上我欲乘风破浪，踏遍黄沙海洋。与其误会一场，也要不负勇往。我愿你是个谎，从未出现南墙.我想你就站在，站在七月之上。"},{"title":"","date":"2017-05-12T01:42:59.000Z","updated":"2017-05-12T01:42:59.000Z","comments":true,"path":"photos/data.json","permalink":"http://www.1oveit.club/photos/data.json","excerpt":"","text":"{\"list\":[{\"date\":\"2016-08\",\"arr\":{\"year\":2016,\"month\":8,\"link\":[\"2016-08-07_求婚啦.jpg\"],\"text\":[\"求婚啦\"],\"type\":[\"image\"]}},{\"date\":\"2016-06\",\"arr\":{\"year\":2016,\"month\":6,\"link\":[\"2016-06-01_我们宿舍.JPG\",\"2016-06-01_我毕业啦啦.JPG\",\"2016-06-01_毕业那件小事.JPG\",\"2016-06-01_永远的12.JPG\",\"2016-06-01_班花来啦.JPG\",\"2016-06-01_老魏啊.JPG\"],\"text\":[\"我们宿舍\",\"我毕业啦啦\",\"毕业那件小事\",\"永远的12\",\"班花来啦\",\"老魏啊\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2016-05\",\"arr\":{\"year\":2016,\"month\":5,\"link\":[\"2016-05-29_我们这群人.JPG\",\"2016-05-29_抛帽子.JPG\"],\"text\":[\"我们这群人\",\"抛帽子\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2016-02\",\"arr\":{\"year\":2016,\"month\":2,\"link\":[\"2016-02-02_校记者团.jpg\",\"2016-02-02_班集体.jpg\",\"2016-02-06_心情低谷.jpg\"],\"text\":[\"校记者团\",\"班集体\",\"心情低谷\"],\"type\":[\"image\",\"image\",\"image\"]}},{\"date\":\"2015-12\",\"arr\":{\"year\":2015,\"month\":12,\"link\":[\"2015-12-05_西安西安.jpg\"],\"text\":[\"西安西安\"],\"type\":[\"image\"]}},{\"date\":\"2015-05\",\"arr\":{\"year\":2015,\"month\":5,\"link\":[\"2015-05-01_充实的一天--七夕01.jpg\",\"2015-05-01_反正不是我贴的.jpg\",\"2015-05-01_抽奖中的——低调.jpg\"],\"text\":[\"充实的一天--七夕01\",\"反正不是我贴的\",\"抽奖中的——低调\"],\"type\":[\"image\",\"image\",\"image\"]}}]}"},{"title":"相册","slug":"photos","date":"2017-05-11T13:49:08.000Z","updated":"2017-05-11T13:49:08.000Z","comments":false,"path":"photos/index.html","permalink":"http://www.1oveit.club/photos/index.html","excerpt":"","text":"图片正在加载中… (function() { var loadScript = function(path) { var $script = document.createElement('script') document.getElementsByTagName('body')[0].appendChild($script) $script.setAttribute('src', path) } setTimeout(function() { loadScript('./ins.js') }, 0) })()"},{"title":"","date":"2017-05-11T13:40:29.000Z","updated":"2017-05-11T13:40:29.000Z","comments":true,"path":"photos/ins.css","permalink":"http://www.1oveit.club/photos/ins.css","excerpt":"","text":"#post-instagram{ padding: 30px; } #post-instagram .article-entry{ padding-right: 0; } .instagram{ position: relative; min-height: 500px; } .instagram img { width: 100%; margin-top:0; } .instagram .year { font-size: 16px; } .instagram .open-ins{ padding: 10px 0; color: #cdcdcd; } .instagram .open-ins:hover{ color: #657b83; } .instagram .year{ display: inline; } .instagram .thumb { width: 25%; height: 0; padding-bottom: 25%; position: relative; display: inline-block; text-align: center; background: #ededed; outline: 1px solid #ddd; } .instagram .thumb a { position: relative; } .instagram .album h1 em{ font-style: normal; font-size: 14px; margin-left: 10px; } .instagram .album ul{ display: flex; flex-wrap: wrap; clear: both; width: 100%; text-align: left; } .instagram .album li{ list-style: none; display: inline-block; box-sizing: border-box; padding: 0 5px; margin-bottom: -10px; height: 0; width: 25%; position: relative; padding-bottom: 25%; } .instagram .album li:before{ display: none; } .instagram .album div.img-box{ position: absolute; width: 90%; height: 90%; -webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); -moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); } .instagram .album div.img-box img{ width: 100%; height: 100%; position: absolute; z-index: 2; } .instagram .album div.img-box .img-bg{ position: absolute; top: 0; left: 0; bottom: 0px; width: 100%; margin: -5px; padding: 5px; -webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -webkit-transition: all 0.15s ease-out 0.1s; -moz-transition: all 0.15s ease-out 0.1s; -o-transition: all 0.15s ease-out 0.1s; transition: all 0.15s ease-out 0.1s; opacity: 0.2; cursor: pointer; display: block; z-index: 3; } .instagram .album div.img-box .icon { font-size: 14px; position: absolute; left: 50%; top: 50%; margin-left: -7px; margin-top: -7px; color: #999; z-index: 1; } .instagram .album div.img-box .img-bg:hover{ opacity: 0; } .photos-btn-wrap { border-bottom: 1px solid #e5e5e5; margin-bottom: 20px; } .photos-btn { font-size: 16px; color: #333; margin-bottom: -4px; padding: 5px 8px 3px; } .photos-btn.active { color: #08c; border: 1px solid #e5e5e5; border-bottom: 5px solid #fff; } @media screen and (max-width:600px) { .instagram .thumb { width: 50%; padding-bottom: 50%; } .instagram .album li { width: 100%; position: relative; padding-bottom: 100%; text-align: center; } .instagram .album div.img-box{ margin: 0; width: 90%; height: 90%; } }"},{"title":"","date":"2017-05-11T13:47:15.000Z","updated":"2017-05-11T13:47:15.000Z","comments":true,"path":"photos/ins.js","permalink":"http://www.1oveit.club/photos/ins.js","excerpt":"","text":"/******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = \"/dist/\"; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(1); var _view = __webpack_require__(2); var _view2 = _interopRequireDefault(_view); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } /** * @name impush-client * @description 这个项目让我发家致富… * @date 2016-12-1 */ var _collection = []; var _count = 0; var searchData; function addMask(elem) { var rect = elem.getBoundingClientRect(); var style = getComputedStyle(elem, null); var mask = document.createElement('i'); mask.className = 'icon-film'; mask.style.color = '#fff'; mask.style.fontSize = '26px'; mask.style.position = 'absolute'; mask.style.right = '10px'; mask.style.bottom = '10px'; mask.style.zIndex = 1; elem.parentNode.appendChild(mask); } var createVideoIncon = function createVideoIncon() { var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]'); for (var i = 0, len = $videoImg.length; i < len; i++) { addMask($videoImg[i]); } }; var render = function render(res) { var ulTmpl = \"\"; for (var j = 0, len2 = res.list.length; j < len2; j++) { var data = res.list[j].arr; var liTmpl = \"\"; for (var i = 0, len = data.link.length; i < len; i++) { var minSrc = 'https://raw.githubusercontent.com/zhengjingfa/Blog-Back-Up/master/min_photos/' + data.link[i]; var src = 'https://raw.githubusercontent.com/zhengjingfa/Blog-Back-Up/master/photos/' + data.link[i]; var type = data.type[i]; var target = src + (type === 'video' ? '.mp4' : '.jpg'); src += ''; liTmpl += '\\ \\ \\ \\ ' + data.text[i] + '\\ '; } ulTmpl = ulTmpl + '' + data.year + '年' + data.month + '月\\ ' + liTmpl + '\\ '; } document.querySelector('.instagram').innerHTML = '' + ulTmpl + ''; createVideoIncon(); _view2.default.init(); }; var replacer = function replacer(str) { var arr = str.split(\"/\"); return \"/assets/ins/\" + arr[arr.length - 1]; }; var ctrler = function ctrler(data) { var imgObj = {}; for (var i = 0, len = data.length; i < len; i++) { var y = data[i].y; var m = data[i].m; var src = replacer(data[i].src); var text = data[i].text; var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m); if (imgObj[key]) { imgObj[key].srclist.push(src); imgObj[key].text.push(text); } else { imgObj[key] = { year: y, month: m, srclist: [src], text: [text] }; } } render(imgObj); }; function loadData(success) { if (!searchData) { var xhr = new XMLHttpRequest(); xhr.open('GET', './data.json?t=' + +new Date(), true); xhr.onload = function() { if (this.status >= 200 && this.status < 300) { var res = JSON.parse(this.response); searchData = res; success(searchData); } else { console.error(this.statusText); } }; xhr.onerror = function() { console.error(this.statusText); }; xhr.send(); } else { success(searchData); } } var Ins = { init: function init() { loadData(function(data) { render(data); }); } }; Ins.init(); // export default impush; /***/ }, /* 1 */ /***/ function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */ (function(global) { 'use strict'; var inViewport = __webpack_require__(3); var lazyAttrs = ['data-src']; global.lzld = lazyload(); // Provide libs using getAttribute early to get the good src // and not the fake data-src replaceGetAttribute('Image'); replaceGetAttribute('IFrame'); function registerLazyAttr(attr) { if (indexOf.call(lazyAttrs, attr) === -1) { lazyAttrs.push(attr); } } function lazyload(opts) { opts = merge({ 'offset': 333, 'src': 'data-src', 'container': false }, opts || {}); if (typeof opts.src === 'string') { registerLazyAttr(opts.src); } var elts = []; function show(elt) { var src = findRealSrc(elt); if (src) { elt.src = src; } elt.setAttribute('data-lzled', true); elts[indexOf.call(elts, elt)] = null; } function findRealSrc(elt) { if (typeof opts.src === 'function') { return opts.src(elt); } return elt.getAttribute(opts.src); } function register(elt) { elt.onload = null; elt.removeAttribute('onload'); elt.onerror = null; elt.removeAttribute('onerror'); if (indexOf.call(elts, elt) === -1) { inViewport(elt, opts, show); } } return register; } function replaceGetAttribute(elementName) { var fullname = 'HTML' + elementName + 'Element'; if (fullname in global === false) { return; } var original = global[fullname].prototype.getAttribute; global[fullname].prototype.getAttribute = function(name) { if (name === 'src') { var realSrc; for (var i = 0, max = lazyAttrs.length; i < max; i++) { realSrc = original.call(this, lazyAttrs[i]); if (realSrc) { break; } } return realSrc || original.call(this, name); } // our own lazyloader will go through theses lines // because we use getAttribute(opts.src) return original.call(this, name); }; } function merge(defaults, opts) { for (var name in defaults) { if (opts[name] === undefined) { opts[name] = defaults[name]; } } return opts; } // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html function indexOf(value) { for (var i = this.length; i-- && this[i] !== value;) {} return i; } module.exports = lazyload; // export default impush; /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ }, /* 2 */ /***/ function(module, exports) { 'use strict'; var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) { // parse slide data (url, title, size ...) from DOM elements // (children of gallerySelector) var parseThumbnailElements = function parseThumbnailElements(el) { el = el.parentNode.parentNode; var thumbElements = el.getElementsByClassName('thumb'), numNodes = thumbElements.length, items = [], figureEl, linkEl, size, type, // video or not target, item; for (var i = 0; i < numNodes; i++) { figureEl = thumbElements[i]; // // include only element nodes if (figureEl.nodeType !== 1) { continue; } linkEl = figureEl.children[0]; // size = linkEl.getAttribute('data-size').split('x'); type = linkEl.getAttribute('data-type'); target = linkEl.getAttribute('data-target'); // create slide object item = { src: linkEl.getAttribute('href'), w: parseInt(size[0], 10), h: parseInt(size[1], 10) }; if (figureEl.children.length > 1) { item.title = figureEl.children[1].innerHTML; } if (linkEl.children.length > 0) { item.msrc = linkEl.children[0].getAttribute('src'); item.type = type; item.target = target; item.html = ''; if (type === 'video') { //item.src = null; } } item.el = figureEl; // save link to element for getThumbBoundsFn items.push(item); } return items; }; // find nearest parent element var closest = function closest(el, fn) { return el && (fn(el) ? el : closest(el.parentNode, fn)); }; // triggers when user clicks on thumbnail var onThumbnailsClick = function onThumbnailsClick(e) { e = e || window.event; e.preventDefault ? e.preventDefault() : e.returnValue = false; var eTarget = e.target || e.srcElement; // find root element of slide var clickedListItem = closest(eTarget, function(el) { return el.tagName && el.tagName.toUpperCase() === 'FIGURE'; }); if (!clickedListItem) { return; } // find index of clicked item by looping through all child nodes // alternatively, you may define index via data- attribute var clickedGallery = clickedListItem.parentNode, // childNodes = clickedListItem.parentNode.childNodes, // numChildNodes = childNodes.length, childNodes = document.getElementsByClassName('thumb'), numChildNodes = childNodes.length, nodeIndex = 0, index; for (var i = 0; i < numChildNodes; i++) { if (childNodes[i].nodeType !== 1) { continue; } if (childNodes[i] === clickedListItem) { index = nodeIndex; break; } nodeIndex++; } if (index >= 0) { // open PhotoSwipe if valid index found openPhotoSwipe(index, clickedGallery); } return false; }; // parse picture index and gallery index from URL (#&pid=1&gid=2) var photoswipeParseHash = function photoswipeParseHash() { var hash = window.location.hash.substring(1), params = {}; if (hash.length < 5) { return params; } var vars = hash.split('&'); for (var i = 0; i < vars.length; i++) { if (!vars[i]) { continue; } var pair = vars[i].split('='); if (pair.length < 2) { continue; } params[pair[0]] = pair[1]; } if (params.gid) { params.gid = parseInt(params.gid, 10); } return params; }; var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) { var pswpElement = document.querySelectorAll('.pswp')[0], gallery, options, items; items = parseThumbnailElements(galleryElement); // define options (if needed) options = { // define gallery index (for URL) galleryUID: galleryElement.getAttribute('data-pswp-uid'), getThumbBoundsFn: function getThumbBoundsFn(index) { // See Options -> getThumbBoundsFn section of documentation for more info var thumbnail = items[index].el.getElementsByTagName('img')[0], // find thumbnail pageYScroll = window.pageYOffset || document.documentElement.scrollTop, rect = thumbnail.getBoundingClientRect(); return { x: rect.left, y: rect.top + pageYScroll, w: rect.width }; } }; // PhotoSwipe opened from URL if (fromURL) { if (options.galleryPIDs) { // parse real index when custom PIDs are used // http://photoswipe.com/documentation/faq.html#custom-pid-in-url for (var j = 0; j < items.length; j++) { if (items[j].pid == index) { options.index = j; break; } } } else { // in URL indexes start from 1 options.index = parseInt(index, 10) - 1; } } else { options.index = parseInt(index, 10); } // exit if index not found if (isNaN(options.index)) { return; } if (disableAnimation) { options.showAnimationDuration = 0; } // Pass data to PhotoSwipe and initialize it gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); var $tempVideo; var stopVideoHandle = function stopVideoHandle() { if ($tempVideo) { $tempVideo.remove(); $tempVideo = null; } }; var changeHandle = function changeHandle() { var item = gallery.currItem; stopVideoHandle(); if (item.type === 'video') { var $ctn = item.container; var style = $ctn.getElementsByClassName('pswp__img')[0].style; var $video = document.createElement('video'); $video.setAttribute('autoplay', 'autoplay'); $video.setAttribute('controls', 'controls'); $video.setAttribute('src', item.target); $video.style.width = style.width; $video.style.height = style.height; $video.style.position = 'absolute'; $video.style.zIndex = 2; $tempVideo = $video; $ctn.appendChild($video); } }; gallery.listen('initialZoomIn', changeHandle); gallery.listen('afterChange', changeHandle); gallery.listen('initialZoomOut', stopVideoHandle); }; // loop through all gallery elements and bind events var galleryElements = document.querySelectorAll(gallerySelector); for (var i = 0, l = galleryElements.length; i < l; i++) { galleryElements[i].setAttribute('data-pswp-uid', i + 1); galleryElements[i].onclick = onThumbnailsClick; } // Parse URL and open gallery if it contains #&pid=3&gid=1 var hashData = photoswipeParseHash(); if (hashData.pid && hashData.gid) { openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true); } }; var Viewer = function() { function init() { initPhotoSwipeFromDOM('.photos'); } return { init: init }; }(); module.exports = Viewer; /***/ }, /* 3 */ /***/ function(module, exports) { /* WEBPACK VAR INJECTION */ (function(global) { module.exports = inViewport; var instances = []; var supportsMutationObserver = typeof global.MutationObserver === 'function'; function inViewport(elt, params, cb) { var opts = { container: global.document.body, offset: 0 }; if (params === undefined || typeof params === 'function') { cb = params; params = {}; } var container = opts.container = params.container || opts.container; var offset = opts.offset = params.offset || opts.offset; for (var i = 0; i < instances.length; i++) { if (instances[i].container === container) { return instances[i].isInViewport(elt, offset, cb); } } return instances[ instances.push(createInViewport(container)) - 1 ].isInViewport(elt, offset, cb); } function addEvent(el, type, fn) { if (el.attachEvent) { el.attachEvent('on' + type, fn); } else { el.addEventListener(type, fn, false); } } function debounce(func, wait, immediate) { var timeout; return function() { var context = this, args = arguments; var callNow = immediate && !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); function later() { timeout = null; if (!immediate) func.apply(context, args); } }; } // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708 var contains = function() { if (!global.document) { return true; } return global.document.documentElement.compareDocumentPosition ? function(a, b) { return !!(a.compareDocumentPosition(b) & 16); } : global.document.documentElement.contains ? function(a, b) { return a !== b && (a.contains ? a.contains(b) : false); } : function(a, b) { while (b = b.parentNode) { if (b === a) { return true; } } return false; }; } function createInViewport(container) { var watches = createWatches(); var scrollContainer = container === global.document.body ? global : container; var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15); addEvent(scrollContainer, 'scroll', debouncedCheck); if (scrollContainer === global) { addEvent(global, 'resize', debouncedCheck); } if (supportsMutationObserver) { observeDOM(watches, container, debouncedCheck); } // failsafe check, every 200ms we check for visible images // usecase: a hidden parent containing eleements // when the parent becomes visible, we have no event that the children // became visible setInterval(debouncedCheck, 150); function isInViewport(elt, offset, cb) { if (!cb) { return isVisible(elt, offset); } var remote = createRemote(elt, offset, cb); remote.watch(); return remote; } function createRemote(elt, offset, cb) { function watch() { watches.add(elt, offset, cb); } function dispose() { watches.remove(elt); } return { watch: watch, dispose: dispose }; } function watchInViewport(elt, offset, cb) { if (isVisible(elt, offset)) { watches.remove(elt); cb(elt); } } function isVisible(elt, offset) { if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) { return false; } // Check if the element is visible // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js if (!elt.offsetWidth || !elt.offsetHeight) { return false; } var eltRect = elt.getBoundingClientRect(); var viewport = {}; if (container === global.document.body) { viewport = { top: -offset, left: -offset, right: global.document.documentElement.clientWidth + offset, bottom: global.document.documentElement.clientHeight + offset }; } else { var containerRect = container.getBoundingClientRect(); viewport = { top: containerRect.top - offset, left: containerRect.left - offset, right: containerRect.right + offset, bottom: containerRect.bottom + offset }; } // The element must overlap with the visible part of the viewport var visible = ( (eltRect.right > viewport.left) && (eltRect.left < viewport.right) && (eltRect.bottom > viewport.top) && (eltRect.top < viewport.bottom) ); return visible; } return { container: container, isInViewport: isInViewport }; } function createWatches() { var watches = []; function add(elt, offset, cb) { if (!isWatched(elt)) { watches.push([elt, offset, cb]); } } function remove(elt) { var pos = indexOf(elt); if (pos !== -1) { watches.splice(pos, 1); } } function indexOf(elt) { for (var i = watches.length - 1; i >= 0; i--) { if (watches[i][0] === elt) { return i; } } return -1; } function isWatched(elt) { return indexOf(elt) !== -1; } function checkAll(cb) { return function() { for (var i = watches.length - 1; i >= 0; i--) { cb.apply(this, watches[i]); } }; } return { add: add, remove: remove, isWatched: isWatched, checkAll: checkAll }; } function observeDOM(watches, container, cb) { var observer = new MutationObserver(watch); var filter = Array.prototype.filter; var concat = Array.prototype.concat; observer.observe(container, { childList: true, subtree: true, // changes like style/width/height/display will be catched attributes: true }); function watch(mutations) { // some new DOM nodes where previously watched // we should check their positions if (mutations.some(knownNodes) === true) { setTimeout(cb, 0); } } function knownNodes(mutation) { var nodes = concat.call([], Array.prototype.slice.call(mutation.addedNodes), mutation.target ); return filter.call(nodes, watches.isWatched).length > 0; } } /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ } /******/ ]);"},{"title":"","date":"2017-05-05T12:07:38.000Z","updated":"2017-05-04T14:53:06.000Z","comments":true,"path":"photos/lazyload.min.js","permalink":"http://www.1oveit.club/photos/lazyload.min.js","excerpt":"","text":"/*! * An jQuery | zepto plugin for lazy loading images. * author -> jieyou * see https://github.com/jieyou/lazyload * use some tuupola's code https://github.com/tuupola/jquery_lazyload (BSD) * use component's throttle https://github.com/component/throttle (MIT) */ !function(a){\"function\"==typeof define&&define.amd?define([\"jquery\"],a):a(window.jQuery||window.Zepto)}(function(a){function g(){}function h(a,b){var e;return e=b._$container==d?(\"innerHeight\"in c?c.innerHeight:d.height())+d.scrollTop():b._$container.offset().top+b._$container.height(),e=a.offset().top+b.threshold+a.height()}function k(b,e){var f;return f=e._$container==d?a.fn.scrollLeft?d.scrollLeft():c.pageXOffset:e._$container.offset().left,f>=b.offset().left+e.threshold+b.width()}function l(a,b){var c=0;a.each(function(d){function g(){f.trigger(\"_lazyload_appear\"),c=0}var f=a.eq(d);if(!(f.width()b.failure_limit)return!1}else g()})}function m(a){return a.filter(function(b){return!a.eq(b)._lazyload_loadStarted})}function n(a,b){function h(){f=0,g=+new Date,e=a.apply(c,d),c=null,d=null}var c,d,e,f,g=0;return function(){c=this,d=arguments;var a=new Date-g;return f||(a>=b?h():f=setTimeout(h,b-a)),e}}var f,c=window,d=a(c),e={threshold:0,failure_limit:0,event:\"scroll\",effect:\"show\",effect_params:null,container:c,data_attribute:\"original\",data_srcset_attribute:\"original-srcset\",skip_invisible:!0,appear:g,load:g,vertical_only:!1,check_appear_throttle_time:300,url_rewriter_fn:g,no_fake_img_loader:!1,placeholder_data_img:\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\",placeholder_real_img:\"http://ditu.baidu.cn/yyfm/lazyload/0.0.1/img/placeholder.png\"};f=function(){var a=Object.prototype.toString;return function(b){return a.call(b).replace(\"[object \",\"\").replace(\"]\",\"\")}}(),a.fn.hasOwnProperty(\"lazyload\")||(a.fn.lazyload=function(b){var i,j,k,h=this;return a.isPlainObject(b)||(b={}),a.each(e,function(g,h){var i=f(b[g]);-1!=a.inArray(g,[\"threshold\",\"failure_limit\",\"check_appear_throttle_time\"])?\"String\"==i?b[g]=parseInt(b[g],10):\"Number\"!=i&&(b[g]=h):\"container\"==g?(b._$container=b.hasOwnProperty(g)?b[g]==c||b[g]==document?d:a(b[g]):d,delete b.container):!e.hasOwnProperty(g)||b.hasOwnProperty(g)&&i==f(e[g])||(b[g]=h)}),i=\"scroll\"==b.event,k=0==b.check_appear_throttle_time?l:n(l,b.check_appear_throttle_time),j=i||\"scrollstart\"==b.event||\"scrollstop\"==b.event,h.each(function(c){var e=this,f=h.eq(c),i=f.attr(\"src\"),k=f.attr(\"data-\"+b.data_attribute),l=b.url_rewriter_fn==g?k:b.url_rewriter_fn.call(e,f,k),n=f.attr(\"data-\"+b.data_srcset_attribute),o=f.is(\"img\");return 1==f._lazyload_loadStarted||i==l?(f._lazyload_loadStarted=!0,h=m(h),void 0):(f._lazyload_loadStarted=!1,o&&!i&&f.one(\"error\",function(){f.attr(\"src\",b.placeholder_real_img)}).attr(\"src\",b.placeholder_data_img),f.one(\"_lazyload_appear\",function(){function i(){d&&f.hide(),o?(n&&f.attr(\"srcset\",n),l&&f.attr(\"src\",l)):f.css(\"background-image\",'url(\"'+l+'\")'),d&&f[b.effect].apply(f,c?b.effect_params:[]),h=m(h)}var d,c=a.isArray(b.effect_params);f._lazyload_loadStarted||(d=\"show\"!=b.effect&&a.fn[b.effect]&&(!b.effect_params||c&&0==b.effect_params.length),b.appear!=g&&b.appear.call(e,f,h.length,b),f._lazyload_loadStarted=!0,b.no_fake_img_loader||n?(b.load!=g&&f.one(\"load\",function(){b.load.call(e,f,h.length,b)}),i()):a(\"\").one(\"load\",function(){i(),b.load!=g&&b.load.call(e,f,h.length,b)}).attr(\"src\",l))}),j||f.on(b.event,function(){f._lazyload_loadStarted||f.trigger(\"_lazyload_appear\")}),void 0)}),j&&b._$container.on(b.event,function(){k(h,b)}),d.on(\"resize load\",function(){k(h,b)}),a(function(){k(h,b)}),this})});"},{"title":"tags","date":"2017-05-11T09:21:38.000Z","updated":"2017-05-11T09:21:38.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.1oveit.club/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"nvm-Mac安装使用","slug":"nav-Mac安装使用","date":"2016-06-02T04:49:10.000Z","updated":"2017-05-13T05:23:35.000Z","comments":true,"path":"2016/06/02/nav-Mac安装使用/","link":"","permalink":"http://www.1oveit.club/2016/06/02/nav-Mac安装使用/","excerpt":"node更新太快了，版本差异各异，这时候有必要安装node版本管理工具nvm了。 安装使用homebrew安装会出现莫名其妙的问题，这里推荐使用curl方式来安装：1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash","text":"node更新太快了，版本差异各异，这时候有必要安装node版本管理工具nvm了。 安装使用homebrew安装会出现莫名其妙的问题，这里推荐使用curl方式来安装：1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash 此时nvm安装在~/.nvm下，紧接着配置环境变量。 配置环境变量推荐大家使用zsh(终端神器)，打开~/.zshrc，在最后一行加上：12export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; 此时nvm都被添加到全局环境变量，紧接着输入source ~/.zshrc重新启动一下配置。输入nvm，会输出以下信息：1234567891011121314151617181920212223242526272829303132333435363738394041➜ ~ nvmNode Version ManagerNote: &lt;version&gt; refers to any version-like string nvm understands. This includes: - full or partial version numbers, starting with an optional &quot;v&quot; (0.10, v0.1.2, v1) - default (built-in) aliases: node, stable, unstable, iojs, system - custom aliases you define with `nvm alias foo`Usage: nvm help Show this message nvm --version Print out the latest released version of nvm nvm install [-s] &lt;version&gt; Download and install a &lt;version&gt;, [-s] from source. Uses .nvmrc if available --reinstall-packages-from=&lt;version&gt; When installing, reinstall packages installed in &lt;node|iojs|node version number&gt; nvm uninstall &lt;version&gt; Uninstall a version nvm use [--silent] &lt;version&gt; Modify PATH to use &lt;version&gt;. Uses .nvmrc if available nvm exec [--silent] &lt;version&gt; [&lt;command&gt;] Run &lt;command&gt; on &lt;version&gt;. Uses .nvmrc if available nvm run [--silent] &lt;version&gt; [&lt;args&gt;] Run `node` on &lt;version&gt; with &lt;args&gt; as arguments. Uses .nvmrc if available nvm current Display currently activated version nvm ls List installed versions nvm ls &lt;version&gt; List versions matching a given description nvm ls-remote List remote versions available for install nvm version &lt;version&gt; Resolve the given description to a single local version nvm version-remote &lt;version&gt; Resolve the given description to a single remote version nvm deactivate Undo effects of `nvm` on current shell nvm alias [&lt;pattern&gt;] Show all aliases beginning with &lt;pattern&gt; nvm alias &lt;name&gt; &lt;version&gt; Set an alias named &lt;name&gt; pointing to &lt;version&gt; nvm unalias &lt;name&gt; Deletes the alias named &lt;name&gt; nvm reinstall-packages &lt;version&gt; Reinstall global `npm` packages contained in &lt;version&gt; to current version nvm unload Unload `nvm` from shell nvm which [&lt;version&gt;] Display path to installed node version. Uses .nvmrc if availableExample: nvm install v0.10.32 Install a specific version number nvm use 0.10 Use the latest available 0.10.x release nvm run 0.10.32 app.js Run app.js using node v0.10.32 nvm exec 0.10.32 node app.js Run `node app.js` with the PATH pointing to node v0.10.32 nvm alias default 0.10.32 Set default node version on a shellNote: to remove, delete, or uninstall nvm - just remove the `$NVM_DIR` folder (usually `~/.nvm`) 使用nvm上面打印的内容已经告诉我们怎么使用了。首先输入nvm ls-remote查看node远程版本：12345➜ ~ nvm ls-remote v0.1.14 v0.1.15 v0.1.16 ... 然后输入nvm install &lt;版本号&gt;比如安装4.1.0版本nvm install v4.1.0紧接着使用，输入nvm use &lt;版本号&gt;比如使用4.1.0版本，输入nvm use v4.1.0 默认nvm当你新开一个bash，输入nvm current时显示为null。可以设置默认的nvm来解决问题，输入nvm alias default v4.1.0,可以看到12➜ ~ nvm alias default v4.1.0default -&gt; v4.1.0 指定v4.1.0作为默认版本 以后新开bash输入nvm current默认显示v4.1.0。","categories":[],"tags":[{"name":"nvm","slug":"nvm","permalink":"http://www.1oveit.club/tags/nvm/"},{"name":"node","slug":"node","permalink":"http://www.1oveit.club/tags/node/"},{"name":"版本管理工具","slug":"版本管理工具","permalink":"http://www.1oveit.club/tags/版本管理工具/"}]},{"title":"JavaScript简明教程（全）","slug":"javaScript简明教程（全）","date":"2016-05-29T05:37:19.000Z","updated":"2017-05-13T10:43:40.000Z","comments":true,"path":"2016/05/29/javaScript简明教程（全）/","link":"","permalink":"http://www.1oveit.club/2016/05/29/javaScript简明教程（全）/","excerpt":"JavaScript与Java没有半毛钱关系，网景公司员工Brendan Eich用了10天时间设计了JavaScript语言。 JavaScript的范围JavaScript的范围：BOM + DOM + ECMAScript BOM简单说明123456BOM即Browser Object Mode,浏览器对象模型。BOM提供了独立于内容而与浏览器窗口进行交互的对象。BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。因为BOM主要用于管理窗口与窗口之间的通信，因此其核心对象是window。BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C。BOM结构体系","text":"JavaScript与Java没有半毛钱关系，网景公司员工Brendan Eich用了10天时间设计了JavaScript语言。 JavaScript的范围JavaScript的范围：BOM + DOM + ECMAScript BOM简单说明123456BOM即Browser Object Mode,浏览器对象模型。BOM提供了独立于内容而与浏览器窗口进行交互的对象。BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。因为BOM主要用于管理窗口与窗口之间的通信，因此其核心对象是window。BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C。BOM结构体系 DOM简单说明12345DOM即Document Object Model，文档对象模型。当网页被加载时，浏览器会创建页面的文档对象模型，即DOM。DOM(文档对象模型)被构造为对象的树。DOM由一系列相关的对象构成，引申为Document对象。DOM的标准化组织是W3C。 ECMAScript简单说明123456789ECMAScript指代JavaScript的核心语法。JavaScript 由 Brendan Eich 发明。JavaScript于1995 年出现在 Netscape 中于 1997 年被 ECMA（一个标准协会）采纳。语法核心：变量基本数据类型对象类型结构(循环|条件|判断)面向对象 javascript语法javascript数据类型基本类型（简单数据类型） * string * number * boolean * undefined * null 复杂类型（复杂数据类型） * Object * Array * Date * RegExp * Function * String * Number * Boolean * null * Math javascript部分操作符的说明一元操作符只能够操作一个值的操作符叫做一元操作符。① 递增和递减操作符:12345678910[01] 前置型,递增和递减操作在包含他们的语句被求值之前就执行。[02] 后置型,递增和递减操作在包含他们的语句被求值之后才执行。var num1 = 2;var num2 = 20;var num3 = --num1 + num2; //21var num4 = num1 + num2; //21var num1 = 2;var num2 = 20;var num3 = num1-- + num2; //22var num4 = num1 + num2; //21 ② 一元加和减操作符:一元加操作符对结果不会有任何的影响。一元减操作符主要用于表示负数。 位操作符01 按位非(NOT):使用 ~ 表示，执行按位非的结果就是返回数值的反码。操作数的负值减去1。123var num1 = 25;var num2 = -num1 - 1; //-26consol.log(~num1) //-26 02 按位与(AND):使用&amp;表示，操作两个操作数。只要有0就为0。03 按位或(OR):使用|表示，操作两个操作数。只要有1就为1。04 按位异或(XOR):使用 ^ 表示，操作两个操作数。相同则为0，不同则为1。05 左移|右移(|有符号|无符号)。 布尔操作符 布尔操作符一共有三个，分别是：非、与、或。 01 逻辑非，符号：！ 说明：取反，可应用于任何值，！！相当于没有操作。02 逻辑与，符号：&amp;&amp; 说明：两个值都为真的时候，结果为真。属于短路操作，如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。03 逻辑或，符号：||说明：两个值只要有一个为真，那么结果为真。属于短路操作，如果第一个操作数为真，那么就不会再对第二个操作数求值了。技巧：可以利用逻辑或短路操作的特点来避免为变量赋null或undefined值。123var myObject = refObject || backupObject;//如果refObject的值不是null,那么它的值将被赋值给myObject//如果是null,那么就将backupObject的值赋值给myObject。 乘性操作符乘 *除 /模 % 加性操作符加 +减 - 说明：上述五种操作符在操作数为非数值的时候内部会执行自动的类型转换。 关系操作符大于 &gt;小于 &lt;小于等于 &lt;=大于等于 &gt;=说明：返回布尔类型的值，要么为false，要么为true。 相等操作符01 相等和不相等[先转换再比较]，符号是 == 和！=比较的规则:[01] 如果操作数中有布尔值，则先转换为数值再比较。[02] 如果是字符串和数值比较，则先将字符串转换为数值再比较。[03] 如果是对象和其他类型的值比较，则先调用对象的valueOf方法，然后用得到的基本类型值去比较。[04] null和undefined是相等的。[05] NaN和NaN不相等。[06] 如果两个操作符都是对象，则比较他们是不是同一个对象，如果指向的是同一个对象则返回true，否则返回false。02 全等和不全等[仅比较不转换],符号是===和!==比较的规则:[01] null和undefined是不全等的，因为它们是不同类型的值。[02] 类型相同，且值相等，则返回true，否则返回false。 条件操作符符号：表达式1 ? 字面量1 ：字面量2说明：如果表达式1的结果为true，则使用字面量1，否则使用字面量2。 赋值操作符符号：=、+=、-=、*=、&lt;&lt;=等等说明：使用赋值操作符对性能而言，没有任何的提升，只是简化了赋值操作而已。 值类型和引用类型01 值类型和引用类型简单说明值类型主要有：12345数值字符串布尔类型undefinednull 引用类型主要有：123对象（Object类型）数组（Array）函数 (Function) 值类型：保存为简单的数据值，赋值只是简单的数据值的复制引用类型:保存为对象，其本质是指向内存位置的引用(地址)，赋值是对地址的复制值类型代码示例1234567var num1 = 10;var num2 = num1; //把num1的值复制一份给num2,num1和num2的值相等,除此之外没有任何其他关系console.log(num1,num2); //10,10console.log(num1 == num2); //truenum2 = 20; //修改num2的值为20,不会对num1产生任何的影响console.log(num1,num2); //10,20console.log(num1 == num2); //false 引用类型代码示例12345678910111213var arr1 = [1,2,3];var arr2 = arr1;console.log(arr1,arr2); //[1,2,3],[1,2,3]console.log(arr1 == arr2); //truevar arr3 = [1,2,3];console.log(arr3); //[1,2,3]console.log(arr1 == arr3,arr2 == arr3); //false,false/** * 代码说明: * arr1和arr2在比较的时候,值相等(都是[1,2,3]),且引用相等(都指向堆中同一块数据),因此arr1和arr2相等 * arr3和arr1以及arr2比较的时候,值相等([1,2,3]),但是引用不相等(arr3指向的是堆中另外一块数据),因此不等 * 总结:引用类型在比较相等的时候,只有值和引用都相等才相等 * */ 02 值类型和引用类型的赋值赋值操作(=):把当前变量存储的值复制一份给接收的变量。值类型的赋值:把当前变量存储的值(具体的数据)复制一份给接收的变量。引用类型的赋值:把当前变量存储的值(具体数据的引用即地址)复制一份给接收的变量。12345678//引用类型使用注意 console.log(arr1,arr2); //[1,2,3],[1,2,3]; console.log(arr1 == arr2); //true arr1.push(4); console.log(arr1,arr2); //[1,2,3,4],[1,2,3,4] /** * 代码说明:因为arr1和arr2内部的引用指向的是同一块数据,所以修改了arr1会对arr2也产生影响 * */ 03 值类型和引用类型作为函数参数处理形参:占位用的参数,用来接收数据的参数而已。实参:实际传递的参数。函数的调用:在函数调用的时候,函数默认会把实参的值赋值给形参。值类型作为参数：在函数内部对形参变量进行修改不会影响到实参的值。引用类型作为参数：在函数内部对形参变量进行修改会影响到实参的值，因为他们的引用指向同一个对象。04 值类型和引用类型的相关图示基本类型的赋值12var str1 = \"hello zhangsan\";var str2 = str1; 引用类型的结构和赋值123456789var car = &#123; color:\"黑色\", number:\"B99\"&#125;;var p1 = &#123; name:\"王宝宝\", age:30, car:car&#125;; 12345var obj1 = &#123; name:\"lisi\", age:18 &#125;; var obj2 = obj1; 对象的动态特性在js中可以动态的对对象属性进行增加、修改和删除；代码示例12345678910111213141516171819//01 创建对象var obj = &#123; name:\"刘德华\", age:60&#125;;//02 动态的为对象添加属性obj.height = \"180cm\";console.log(obj.height);//03 动态的为对象添加方法obj.maiMeng = function () &#123; console.log(\"华仔会卖萌噢\");&#125;;obj.maiMeng();//04 修改属性的值:如果设置的属性以前不存在,那么就是添加,如果设置的属性已经存在了,那么就是修改obj.name = \"王宝强\";console.log(obj.name)//05 删除属性delete obj.name;console.log(obj.name); //undefined 访问对象的方法01 可以使用点语法访问02 可以使用[]语法访问，注意对象的属性必须是字符串 关键字in和delete的使用01 in关键字01 判断属性是否存在于对象中，注意所有的key都是字符串02 for in循环中 遍历对象的 键代码示例12345678910var obj = &#123; name:\"张三\", age:18&#125;;for(k in obj)&#123; console.log(k,obj[k]);&#125;//检测obj对象中是否存在name这个属性console.log(\"name\" in obj); 注意：in关键字操作数组的时候检测的是索引值并非数组元素02 delete关键字01 删除对象的属性02 删除未使用var声明的变量03 返回值为boolean类型，true则表示是否删除成功注意1201 删除的属性如果不存在，返回true02 删除的如果是原型中的属性，返回true 但是删除不成功 循环和分支循环结构1234forwhiledo...whilefor..in 分支结构12if...else..swith..case break和continue对比break:终止循环，循环中后面的代码不再执行continue:结束当前循环，循环后面的代码不再执行，继续下一次循环 调试工具的使用开启调试窗口 windows 平台: f12; Mac: option+command+i;调试窗口介绍 指针: 选择页面中的元素 手机: 使用移动端界面调试 Elements: 查看页面 DOM 树 Console: 控制台(注意, 控制台与该页面是一个整体, 在控制台中的任何操作, 会影响到页面) Source: 代码调试调试工具的使用 逐过程运行, 一次运行一个函数 单步运行(逐步运行), 一次运行一句, 如果是函数, 进入函数体内运行 继续运行. 从当前状态运行下去, 直到出现断点, 如果没有断点则运行结束设置断点技巧 逐步与逐过程混合 断点加继续运行 条件断点(右键添加 add contitional breakpoint)利用 watch 监视窗口可以查看对象成员 异常处理常见的异常分类运行环境的多样性导致的异常（浏览器）语法错误，代码错误异常的特征:一旦代码出现异常，后面的代码就不会再执行异常捕获使用try-catch语句捕获异常123456try&#123; //这里写可能出现异常的代码&#125;catch(e)&#123; //这里的e就是捕获的异常对象 //可以在这里写，出现异常后的处理代码&#125; 异常捕获语句执行的过程为：01 代码正常运行, 如果在try中出现了错误, try 里面出现错误的语句后面的代码都不再执行, 直接跳转到 catch 中02 在catch中处理错误信息03 继续执行后面的代码04 如果 try 中没有出现错误, 那么不走 catch 直接执行后面的代码捕获异常的优点：通过try-catch语句进行异常捕获之后，代码将会继续执行，而不会中断。注意：语法错误异常用try-catch语句无法捕获，因为在预解析阶段，语法错误会直接检测出来，而不会等到运行的时候才报错。try..catch使用示例1234567891011121314151617//01 try ... catch结构的使用//a(); 若直接调用则爆出:Uncaught ReferenceError: a is not defined错误//在开发中,我们对于可能会报错或者是发生异常的代码用try结构进行处理try&#123; a(); //如果发生异常,那么至少不会到正程序中断&#125;catch(e)&#123; //如果try语句中发生了异常,那么会执行此处的代码块 //参数e.为具体的异常信息,可以打印进行查看 console.log(e);&#125;function functionTest() &#123; console.log(\"functionTest\");&#125;;functionTest();//结论:使用try...catch结构,如果发生了异常,那么不会影响后面代码的执行,且我们可以在发生异常信息之后做出具体的处理 手动抛出异常案例：自己写的一个函数，需要一个参数，如果用户不传参数，此时想直接给用户抛出异常，就需要了解如何抛出异常。抛出异常使用throw关键字，语法如下：手动抛出异常信息（字符串）:123456789101112131415try&#123; //a(); //如果发生异常,那么至少不会到正程序中断 //不使用系统默认的异常信息,尝试手动抛出 throw \"对不起,您调用了尚未定义的方法\";&#125;catch(e)&#123; //如果try语句中发生了异常,那么会执行此处的代码块 //参数e.为具体的异常信息,可以打印进行查看 console.log(e);&#125;function functionTest() &#123; console.log(\"functionTest\");&#125;;functionTest(); 手动抛出异常信息（对象）:1234567891011121314151617181920212223try&#123; //a(); //如果发生异常,那么至少不会到正程序中断 //不使用系统默认的异常信息,尝试手动抛出 throw &#123; errMsg:\"具体的错误信息提示\", errCode:\"指定错误类型的代号,如1001等\" &#125;;&#125;catch(e)&#123; //如果try语句中发生了异常,那么会执行此处的代码块 //参数e.为具体的异常信息,可以打印进行查看 console.log(e); //在try语句中抛出的错误信息是什么,那么得到的异常信息就是什么 //如果抛出的是字符串,那么得到的就是字符串 //如果抛出的是对象,那么此处得到的就是对象 console.log(e.errMsg); console.log(e.errCode);&#125;function functionTest() &#123; console.log(\"functionTest\");&#125;;functionTest(); 异常捕获语句的完整模式异常捕获语句的完整模式为try-catch-finally123456789101112131415try&#123; //在执行的时候可能发生异常的代码 b();&#125;catch (e)&#123; //如果try代码块中的代码在执行中发生了异常,那么就会执行该代码块的代码 //通过打印e对象可以查看具体的异常信息 console.log(e); //打印异常信息&#125;finally &#123; //不论try语句中的代码是否会发生异常,都一定会执行此处的代码块 //一般在前端开发中很少使用,常用语后台开发的资源释放工作 console.log(\"无论如何总要执行的代码\");&#125; finally中的代码，不管是否发生异常，都会执行。一般用在后端语言中，用来释放资源，JavaScript中很少会用到。 DOM操作获取元素操作123getElementByIdgetElementsByTagNamegetElementsByClassName 元素节点操作1234567appendChildinsertBeforeremoveChildreplaceChildcloneNodecreateElementcreateTextNode（创建文本节点） 属性节点操作123getAttributesetAttributeremoveAttribute 常用DOM属性1234classNameinnerHTMLinnerText/textContent valuechildren 代码示例12345678910111213141516//0 获取页面中指定的标签,并设置其样式 var divID = document.getElementById(\"divId\"); divID.style.backgroundColor = \"pink\"; divID.style.height = \"40px\"; divID.style.width = \"200px\"; //01 创建新的标签 var div = document.createElement(\"div\"); //02 设置标签的样式 div.style.backgroundColor = \"red\"; div.style.height = \"100px\"; div.style.width = \"300px\"; div.style.fontSize = \"20\"; //03 设置标签的内容 div.innerText = \"这是一个自己创建的标签\"; //04 把标签插入到页面中 document.body.appendChild(div); 面向对象编程 面向对象方法被人谈论了二十多年了，直到今天，我们还一直在谈对象。 面向层过程和面向对象编程01 面向对象编程和面向过程编程是一种编程思想,和具体的语言关系不大。02 面向过程编程和面向对象编程的主要区别1234567891011121314151617181920面向过程编程: 关注点在于解决问题需要的每一个详细的步骤 示例: 自己洗衣服的过程 ① 收集需要洗的脏衣服 ② 准备洗衣粉、洗衣液等 ③ 把衣服放到一个盆里 ④ 接水 ⑤ 把洗衣粉放到盆里 ⑥ 摩擦,摩擦,不断的摩擦 ⑦ 把洗好的衣服用清水冲洗干净 ⑧ 尽量把把洗好的衣服的水分拧干 ⑨ 晾晒 面向对象编程: 关注点在于解决问题需要的对象身上 示例: 使用洗衣机洗衣服的过程 ① 收集需要洗的脏衣服 ② 找到合适的洗衣机 ③ 设定洗衣服和烘干的程序 03 面向过程和面向对象他们的区别就类似于自己洗衣服和使用洗衣机洗衣服|自己做饭吃和去餐馆吃饭 面向对象编程的相关概念01 对象 什么是对象? 所有的一切都是对象,在开发中有一项重要的工作就是对象的划分。一般来说,我们所指的对象是某个具体的事物,而非泛泛的类别。02 对象的特征(静态描述信息) 所谓特征就是一些特定的描述信息 如:学生(性别、年龄、班级、专业、籍贯、家庭住址) 如:汽车(颜色、车牌、品牌、价格等)03 对象的行为(动态特性) 如:人(吃饭、睡觉、玩游戏、奔跑、运动等) 如:狗(吃、睡、咬人、叫、流口水)04 js中的对象 键-值对(key-value)的集合。05 现实生活中的对象和js对象的对应关系 静态的描述信息 - js对象中的属性(属性就是定义在对象内部的变量) 动态的行为特征 - js对象中的方法(方法就是定义在对象内部的函数)06 代码示例：12345678910111213141516171819202122232425 var zhangsan = &#123; name:\"张三\", sex:\"男\", age:18, address:\"天上人间1号公馆\", eat:function () &#123; console.log('能吃'); &#125;, sleep:function () &#123; console.log(\"能睡\"); &#125;, say:function () &#123; console.log(\"能说话\"); &#125;, run:function () &#123; console.log(\"能运动\"); &#125;, song:function () &#123; console.log(\"能唱歌\"); &#125; &#125;; //打印对象的属性并调用相关的方法console.log(zhangsan.name,zhangsan.age,zhangsan.address); zhangsan.say(); zhangsan.sleep(); 面向对象的三大特性面向对象的三大特性:封装、继承、多态01 封装:复用|信息隐蔽代码示例123456789101112131415161718192021//01 封装的简单说明//001 观察以下杂乱无关的语句,它们仅仅只是一堆无意义的全局变量var name = \"乘风波浪会有时\";var actors = [\"彭于晏\",\"邓超\"];var showTime = \"2016-1-28 - 2016-2-28\";var director = \"韩寒\";var type = \"喜剧\";var play = function () &#123; //播放......&#125;;//002 把上面的变量封装到对象中(更具有意义)var film = &#123; name:\"乘风破浪会有时\", actors:[\"彭于晏\",\"邓超\"], showTime:\"2016-1-28 - 2016-2-28\", director:\"韩寒\", type:\"喜剧\", play:function () &#123; //播放...... &#125;&#125; 02 继承:获取已经存在的对象已有属性和方法的一种方式(获取他人已有财富和资源的一种方式)。代码示例123456789101112131415//继承的简单示例//001 创建一个空的对象var nullObj = &#123;&#125;;// 上面的对象film拥有了很多的属性和方法//002 设法让nullObj拥有film中所有的属性和方法//方法一:自己重新写一遍//方法二:通过某种方式来获得,比如遍历该对象,然后完成赋值for(var k in film)&#123; nullObj[k] = film[k];&#125;for(var k in nullObj)&#123; console.log(nullObj[k]);&#125; 03 多态(polymorphism) 多态:polymorphism = poly(复数) + morph(形态) + ism 多用于强类型语言中，JavaScript具备与生俱来的多态特性。 多态表现为: ① 同一操作,作用于不同的对象,会产生不同的解释和行为。 ② 隐藏不同。 创建对象的方法字面量方式创建对象基本写法123456789var book1 = &#123; name:\"声名狼藉者的生活\", price:42.00, author:\"福柯\", press:\"北京大学出版社\", read:function () &#123; console.log(\"我的书名为:声名狼藉者的的生活,作者为福柯....\"); &#125; &#125;; 存在的问题[01] 代码复用性差[02] 如果要创建大量的同类型对象，则需要些大量重复性代码 内置构造函数创建对象JS中的内置构造函数123456789StringNumberBoolean 注意：(区别于string number boolean)DateArrayFunctionObjectRegExp 基本写法12345678var book1 = new Object();book1.name = \"声名狼藉者的生活\";book1.price = 42.00;book1.author = \"福柯\";book1.press = \"北京大学出版社\";book1.read = function () &#123; console.log(\"我的书名为:声名狼藉者的的生活,作者为福柯....\");&#125;; 问题01 创建的对象无法复用,复用性差02 如果需要创建多个同类型的对象,如(书籍)则需要写大量重复的代码,代码的冗余度高 工厂函数创建对象基本写法12345678910111213141516171819202122function createBookNew (name,price,author,press) &#123; var book = new Object(); book.name = name; book.price = price; book.author = author; book.press = press; book.read = function () &#123; console.log(\"我的书名为:\"+book.name+\",作者为\"+book.author+\"....\"); &#125;; return book;&#125;//使用工厂函数来创建对象var book1 = createBookNew(\"声名狼藉者的的生活\",\"42.00\",\"福柯\",\"北京大学出版社\");var book2 = createBookNew(\"人性的枷锁\",\"49.00\",\"毛姆\",\"华东师范大学出版社\");var book3 = createBookNew(\"悟空传\",\"28.00\",\"今何在\",\"湖南文艺出版社\");//打印对象的属性,调用对象的方法console.log(book1.name);console.log(book2.name);console.log(book3.name);book1.read();book2.read();book3.read(); 工厂函数说明:001 工厂函数方式创建对象其本质是对内置构造函数创建对象的过程进行了封装002 适用于大规模“批量生产”同类型的对象1234567891011121314function createBook (name,price,author,press) &#123; //001 参数 = 原料 var book = new Object(); //002 创建对象并设置对象的属性和方法 = 对原料进行加工 book.name = name; book.price = price; book.author = author; book.press = press; book.read = function () &#123; console.log(\"我的书名为:\"+book.name+\",作者为\"+book.author+\"....\"); &#125;; //003 把处理好的对象返回给我们 == 产品出厂 return book;&#125; 封装思路:使用函数把固定不变的部分封装起来，变化的部分提取为函数的参数。工厂函数创建对象的实现过程:① 提供一个创建对象的函数（参数）② 在该函数内部使用new 关键字和Object构造器创建对象③ 设置对象的属性④ 设置对象的方法⑤ 返回对象 自定义构造函数创建对象基本写法123456789101112131415function 构造函数名(参数1,参数2,参数3...) &#123; //设置对象的属性 this.属性01 = 参数1; this.属性02 = 参数2; //设置对象的方法 this.方法01 = function () &#123; //..... &#125;; this.方法02 = function () &#123; //..... &#125;&#125;//自定义构造函数方式创建对象var 对象01 = new 构造函数名(实参01,实参02,实参03...);var 对象02 = new 构造函数名(实参01,实参02,实参03...); 代码示例12345678910111213141516171819function CreateBook (name,price,author,press) &#123; this.name = name; this.price = price; this.author = author; this.press = press; this.read = function () &#123; console.log(\"我的书名为:\"+this.name+\",作者为\"+this.author+\"....\"); &#125;;&#125;var b1 = new CreateBook(\"声名狼藉者的的生活\",\"42.00\",\"福柯\",\"北京大学出版社\");var b2 = new CreateBook(\"人性的枷锁\",\"49.00\",\"毛姆\",\"华东师范大学出版社\");var b3 = new CreateBook(\"悟空传\",\"28.00\",\"今何在\",\"湖南文艺出版社\");//打印对象的属性,并调用对象的方法测试console.log(b1.author);console.log(b2.author);console.log(b3.author);b1.read();b2.read();b3.read(); 构造函数与new关键字:new关键字的作用：用于创建对象（Object类型）。构造函数和普通函数的区别：函数的首字母大写。构造函数的作用:用于完成对象的初始化。 自定义构造函数和简单工厂函数的对比：1234① 函数的首字母大写(用于区别构造函数和普通函数)② 创建对象的过程是由new关键字实现③ 在构造函数内部会自动的创建新对象,并赋值给this指针④ 自动返回创建出来的对象 构造函数的执行过程① 使用new关键字创建对象② 把新创建出来的对象赋值给this③ 在构造函数内部,使用this为新创建出来的对象设置属性和方法④ 默认返回新创建的对象(普通函数如果不显示的return则默认返回undefined)。 构造函数的返回值01 如果在构造函数中没有显示的return,则默认返回的是新创建出来的对象02 如果在构造函数中显示的return,则依照具体的情况处理 [01] return 的是对象,则直接返回该对象,取而代之本该默认返回的新对象 [02] return 的是null或基本数据类型值,则返回新创建的对象 构造函数方式创建对象存在的问题每次创建对象,都会重新创建函数，那么如果创建的对象数量很多,而对象方法内部的实现一模一样,则造成了资源浪费。 构造函数的使用注意函数传值：可以把构造函数的对象方法抽取为参数。代码示例：1234567891011121314151617//001 创建一个构造函数function Person(name,age,toDoSomeThing) &#123; //002 在构造函数内部设置对象的属性和方法 this.name = name; this.age = age; this.sayName = function () &#123; console.log(this.name); &#125;; this.toDoSomeThing = toDoSomeThing;&#125;//003 使用构造函数创建对象var zhangsan = new Person(\"张三\",18,function () &#123; console.log(\"张三在读书\");&#125;);var lisi = new Person(\"李四\",20,function () &#123; console.log(\"李四在玩耍\");&#125;); 对象类型:01 检查对象的类型：instanceOf02 获取对象的类型：Object.prototype.toString.call(dog) 对象的构造器属性12345function Dog(name) &#123; this.name = name; this.color = \"黄色\"; &#125;console.log(dog.constructor); 属性的名称：constructor属性的作用：指向创建该对象的构造函数，类似于现实生活中所有的产品都标有生产厂家一样。 构造函数的调用01 构造函数可以像普通函数一样不通过new关键字直接调用02 在使用构造函数创建对象的时候，如果没有传递参数，则（）可以省略代码示例:1234567891011//01 创建构造函数function Person() &#123; this.name = \"张三\"; this.age = 20; this.sayName = function () &#123; console.log(this.name); &#125;&#125;//02 使用构造函数创建对象var p1 = new Person();var p2 = new Person; //说明:如果不需要传递参数,则在调用构造函数的时候()可以省略 this指向01 如果使用new 构造函数的方式调用，则this指向内部默认创建出来的空对象02 如果像调用普通函数一样调用构造函数，则this指向全局对象window(不要这样使用) 原型对象原型对象概念 在构造函数创建出来的时候,系统会默认帮构造函数创建并关联的一个新对象 自定义构造函数的原型对象默认是一个空对象。 原型对象的作用 构造函数中的原型对象中的属性和方法可以被使用该构造函数创建出来的对象使用。 即以自定义构造函数方式创建出来的所有对象,自动拥有和共享该构造函数的原型对象中的所有属性和方法。 如何访问构造函数的原型对象① 构造函数.protoType② 对象.__proto__（不推荐） 设置原型对象的属性和方法① 利用对象的动态特性来为构造函数的原型对象添加属性和方法② 替换原型对象 实例和实例化：实例化:通过构造函数创建具体对象的过程。实例:通过构造函数实例化出来的对象,我们称之为该构造函数的一个实例。注意:在说实例的时候,一定要指定是某个具体构造函数的实例。 原型的使用方法① 利用对象的动态特性给原型添加属性|方法，如果要添加的方法过多,则有大量重复代码。② 直接替换原型对象：01 替换前后创建的对象所指向的原型对象不一致02 替换原型对象会切断和之前的原型对象之间的关系 原型对象的使用注意1234567① 访问属性:构造函数创建出来的对象在访问属性的时候,会先在实例内查找,如果没有找到则进一步到对应的原型对象中查找。② 设置属性:在使用点语法进行赋值的时候,无法操作到对应的原型对象,如果该属性在对象中已经存在，则修改该属性的值。如果该属性在对象中尚未存在,则新增该属性。③ 设置原型对象的属性:[01] 设置原型对象的属性,只能通过构造函数.Prototype的方式替换原型对象的方式设置。[02] 如果原型对象的属性是值类型，那么只能通过Person.prototype.属性的方式修改其值。如果原型对象的属性是引用类型,那么可以通过对象名.引用对象.属性名的方式设置修改： (001) 使用构造函数创建出来的多个对象的原型对象中的该属性指向的是同一块数据。 (002) 某个对象对该原型对象属性进行了修改会影响到其他的对象。 __proto__属性说明：__proto__是一个非标准属性,即ECMAScript中并不包含该属性,这只是某些浏览器为了方便开发人员开发和调试而提供的一个属性,不具备通用性。建议:在调试的时候可以使用该属性,但不能出现在正式的代码中。 继承 关于继承，通俗说子继父业。在JavaScript中，Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。 相关方法在讲继承之前，我们必须先了解一些相关的方法。 hasOwnProperty和in属性操作in关键字作用：用来检查对象中是否存在某个属性(不区分实例属性和原型属性)。语法：“属性名” in 对象。代码示例:12345678910111213141516&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; this.name = name; &#125; //02 设置构造函数的原型对象的属性 Person.prototype.sayHello = function () &#123; console.log(\"hello\"); &#125; //03 创建对象 var p1 = new Person(); //04 使用in关键字判断对象中是否存在以下属性:name age sayHello console.log(\"age\" in p1); //false console.log(\"name\" in p1); //true console.log(\"sayHello\" in p1); //true&lt;/script&gt; 对象的hasOwnProperty方法作用：用来检查对象中是否存在指定的属性(只检查实例属性)语法：对象.hasOwnProperty(“属性名”)代码示例123456789101112131415161718&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; this.name = name; &#125; //02 设置构造函数的原型对象的属性 Person.prototype.sayHello = function () &#123; console.log(\"hello\"); &#125; Person.prototype.des = \"默认的描述信息\"; //03 创建对象 var p1 = new Person(); //04 使用hasOwnProperty方法判断该属性是否是对象的实例属性 console.log(p1.hasOwnProperty(\"age\")); //false console.log(p1.hasOwnProperty(\"name\")); //true console.log(p1.hasOwnProperty(\"sayHello\")); //false console.log(p1.hasOwnProperty(\"des\")); //false&lt;/script&gt; 判断某对象中存在且只存在某个原型属性123function isProperty(obj, property) &#123; return !obj.hasOwnProperty(property) &amp;&amp; (property in obj); &#125; constructor构造器属性说明 使用构造函数创建对象,则 原型对象中的constructor属性指向对应的构造函数 实例对象中的constructor指向对应的构造函数,其中这里的constructor就是从原型中获取的即constructor时实例对象中的原型属性,而非实例属性 代码验证123456789101112131415//01 提供一个构造函数 function Person(name) &#123; this.name = name; &#125; //02 设置构造函数的原型对象的属性 Person.prototype.sayHello = function () &#123; console.log(\"hello\"); &#125;; Person.prototype.des = \"默认的描述信息\"; //03 创建对象 var p1 = new Person(); function isProperty(obj, property) &#123; return !obj.hasOwnProperty(property) &amp;&amp; (property in obj); &#125; console.log(isProperty(p1, \"constructor\")); //true isprotoTypeOf和instanceisprotoTypeOf作用：判断是否是某个实例对象的原型对象语法:构造函数.protoType.isPrototypeOf(对象)用法示例123456789&lt;script&gt; function Person() &#123;&#125; function Dog() &#123;&#125; Person.prototype.name = \"嘿嘿\"; var p1 = new Person(); console.log(Person.prototype.isPrototypeOf(p1));//rue console.log(Object.prototype.isPrototypeOf(p1));//true console.log(Dog.prototype.isPrototypeOf(p1));//false&lt;/script&gt; instance作用：用于检查对象是否是某个构造函数(类型)的实例语法：对象 instance 构造函数注意：所有的对象都是Object构造函数（类型）的实例用法示例12345678&lt;script&gt; var arr = [1,2,3]; console.log(arr instanceof Array); //true console.log(Array instanceof Object); //true console.log(arr instanceof Object); //true //instanceOf在判断的时候,算上整条原型链 //arr 是Array 和Object 任何一个类的示例&lt;/script&gt; 继承继承基本概念继承：即通过一定的方式实现让某个类型A获取另外一个类型B的属性或方法。其中类型A称之为子类型，类型B称之为父类型或超类型。 javaScript中的继承Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。继承有两种方式：接口继承和实现继承，在js中只支持实现继承，实现继承主要依赖原型链来完成。JavaScript中实现继承的几种方式：说明:其他语言中继承通常通过类来实现，js中没有类的概念，js中的继承是某个对象继承另外一个对象，是基于对象的。123401 原型式继承02 原型链继承03 经典继承(借用构造函数)04 组合继承 原型式继承原型链继承的方式A1234567891011121314151617&lt;script&gt; //01 提供一个构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置原型对象的属性 Person.prototype.className = \"逍遥派1班\"; //03 使用构造函数来创建原型对象 var p1 = new Person(\"张三\",10); var p2 = new Person(\"李四\",20); //04 打印p1和p2对象中的className属性 console.log(p1.className); console.log(p2.className); //结论:对象p1和p2继承了构造函数原型对象中的属性className //但是这并不是严格意义上的继承&lt;/script&gt; 原型链继承的方式B1234567891011121314151617181920&lt;script&gt; //01 提供一个构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置原型对象的属性 Person.prototype = &#123; constructor:Person, className:\"逍遥派1班\" &#125;; //03 使用构造函数来创建原型对象 var p1 = new Person(\"张三\",10); var p2 = new Person(\"李四\",20); //04 打印p1和p2对象中的className属性 console.log(p1.className); console.log(p2.className); //结论:对象p1和p2继承了构造函数原型对象中的属性className //注意:使用原型替换的方式实现继承的时候,原有原型对象中的属性和方法会丢失&lt;/script&gt; 原型链继承的方式C1234567891011121314151617181920212223//01 提供超类型|父类型构造函数function SuperClass() &#123; this.name = 'SuperClass的名称'; this.showName = function () &#123; console.log(this.name); &#125;&#125;//02 设置父类型的原型属性和原型方法SuperClass.prototype.info = 'SuperClass的信息';SuperClass.prototype.showInfo = function () &#123; console.log(this.info);&#125;;//03 提供子类型function SubClass() &#123;&#125;//04 设置继承(原型对象继承)SubClass.prototype = SuperClass.prototype;SubClass.prototype.constructor = SubClass;var sub = new SubClass();console.log(sub.name); //undefinedconsole.log(sub.info); //SuperClass的信息sub.showInfo(); //SuperClass的信息sub.showName(); //sub.showName is not a function 点评：上面的方法可以可以继承超类型中的原型属性和原型方法，但是无法继承实例属性和实例方法 原型链继承实现思想：利用原型（链）让一个对象继承另一个对象的属性和方法实现本质：重写原型对象 原型链123456① 每个构造函数都有原型对象② 每个对象都有自己的构造函数③ 每个构造函数的原型都是一个对象④ 那么这个构造函数的原型对象也有自己的构造函数⑤ 那么这个构造函数的原型对象的构造函数也有自己的原型对象以上形成一个链式的结构,称之为原型链 原型链中的属性搜索原则12345当访问某个对象的成员的时候,会先在自身中查找,如果找到则直接使用如果在自身中没有找到,则去当前创建当前对象的构造函数的原型对象中查找,如果找到了则直接使用如果在该原型对象中没有找到,则继续查找原型对象的原型对象(创建该原型对象的构造函数所对应的原型对象),如果找到则直接使用如果在原型对象的原型对象中也没有找到,则继续向上搜索....直到Object的原型对象,若还是没有,则返回undefined(属性)或报错(方法)。 基本写法·代码示例1234567891011121314151617181920212223//01 提供超类型|父类型function SuperClass() &#123; this.name = 'SuperClass的名称'; this.showName = function () &#123; console.log(this.name); &#125;&#125;//02 设置父类型的原型属性和原型方法SuperClass.prototype.info = 'SuperClass的信息';SuperClass.prototype.showInfo = function () &#123; console.log(this.info);&#125;;//03 提供子类型function SubClass() &#123;&#125;//04 设置继承(原型对象继承)SubClass.prototype = new SuperClass();SubClass.prototype.constructor = SubClass;var sub = new SubClass();console.log(sub.name); //SuperClass的名称console.log(sub.info); //SuperClass的信息sub.showInfo(); //SuperClass的信息sub.showName(); //SuperClass的名称 点评：可以继承父类型中的原型属性|原型方法,以及实例属性和实例方法 注意点① 确定原型和实例的关系 instanceof + isPrototypeOf()② 注意重写原型对象的位置，必须先实现原型继承，然后再设置子对象的原型属性和原型方法③ 完成继承之后，不能使用字面量的方式来创建原型[因为会切断原型] 问题① 父对象的实例属性会转换为子类型原型的原型属性，而如果父类型是实例属性是引用类型则会存在共享问题② 在创建子类型的实例时，不能向父类型的构造函数中传递参数1234567891011121314151617//01 提供父对象的构造函数function SuperType() &#123; //02 在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈'];&#125;;//03 提供子对象的构造函数function SubType() &#123;&#125;;//04 设置原型继承SubType.prototype = new SuperType();//05 创建父对象构造函数的实例对象,并对内部的实例化属性进行修改var subDemo1 = new SubType();var subDemo2 = new SubType();alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈subDemo1.family.push('爷爷','奶奶');alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶 经典继承（借用构造函数）经典继承又称为借用构造函数|伪造继承 基本思想在子类型构造函数的内部调用超类型|父类型构造函数说明：需要借助call|apply方法代码示例1234567891011121314151617181920212223242526//01 提供父类型(对象)的构造函数 function SuperType(name) &#123; //02 在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈']; //实例属性 this.name = name; &#125;; SuperType.prototype.info = '父类型的原型属性'; //03 提供子类型（对象）的构造函数 function SubType() &#123; //经典继承|借用构造函数|伪造对象继承 //SuperType.call(this); //构造参数传递参数 SuperType.call(this,'张老汉'); &#125;; //04 创建父类型的实例对象,并对内部的实例化属性进行修改 var subDemo1 = new SubType(); var subDemo2 = new SubType(); alert(subDemo1.info); //undefined alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈 alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈 subDemo1.family.push('爷爷','奶奶'); alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶 alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈 //测试构造函数传递参数 alert(subDemo1.name); 点评：能够继承父类型的实例属性,但是无法继承父类型的原型属性和原型方法 经典继承的优点① 解决实例对象共享问题，通过调用父对象的构造函数来实现每个子类型（对象）的实例对象均拥有一份父类型实例属性和方法的副本② 可以在调用call方法的时候向构造函数传递参数 经典继承的问题① 冒充继承的方法无法实现函数的重用② 无法继承父对象的原型属性和原型方法 组合继承组合继承|伪经典继承 基本思想① 使用原型链实现对原型属性和方法的继承② 通过伪造(冒充)构造函数来实现对实例属性的继承代码示例1234567891011121314151617181920212223242526272829//01 提供父类型的构造函数function SuperType(name) &#123; //在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈']; //实例属性 this.name = name;&#125;;//原型方法SuperType.prototype.showName = function () &#123; console.log(this.name);&#125;//02 提供子类型的构造函数function SubType(name) &#123; //冒充|伪造 构造参数传递参数 SuperType.call(this,name);&#125;;SubType.prototype = SuperType.prototype;//SubType.prototype = new SuperType();//02 创建父类型的实例对象,并对内部的实例化属性进行修改var subDemo1 = new SubType('张三');var subDemo2 = new SubType('张四');alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈subDemo1.family.push('爷爷','奶奶');alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈//测试构造函数传递参数subDemo1.showName(); //张三subDemo2.showName(); //张四 基本包装类型基本类型：字符串 + 数值 + null + undefined + 布尔值为了便于操作基本类型，ECMAScript提供了三个特殊的引用类型：Boolean + Number + String。上述类型和其他的引用类型类似，同时也具备与各自的基本类型相应的特殊行为，每当我们读取一个基本类型的值的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。123var str = '测试字符串';console.log(str.length); //5console.log(str.substring(2)); //字符串 思考：属性和方法本是对象的特征，字符串如何能够拥有length属性以及其他类似subString等方法，内部怎么实现的？基本类型值并不是对象，因此从逻辑上讨论他们不应该有属性和方法。 内部的具体处理:123（1）创建String类型的一个实例对象（2）在实例对象上面读取指定的属性（length）,调用指定的方法（subString）（3）销毁该对象 NumberNumber是与数字值相对应的引用类型。创建Number类型的对象：var num = new Number(10); String String是字符串的对象包装类型。创建字符串类型的对象：var str = new String(‘hello World’); BooleanBoolean是与布尔值对象的引用类型。可以通过调用Boolean构造函数传递参数来创建boolean类型的对象。var bool = new Boolean(true); 基本包装类型的代码示例1234567891011121314//001 Stringvar str = '测试字符串';console.log(str.length); //5console.log(str.substring(2)); //字符串//002 Numbervar num = new Number(10);console.log(num); //Number &#123;[[PrimitiveValue]]: 10&#125;console.log(typeof num); //objectconsole.log(typeof 10); //number//003 Booleanvar bool = new Boolean(true);console.log(bool); //Boolean &#123;[[PrimitiveValue]]: true&#125;console.log(typeof bool); //objectconsole.log(typeof true); //boolean 基本包装类型的注意点[1] 对象还是基本数据类型值？对象：通过new 调用构造函数创建出来的是对象基本数据类型值：直接通过字面量方式赋值|通过省略new关键字调用构造函数方式创建的是基本数据类型值。12345ex: var str1 = new String('hello'); var str2 = 'hello'; var str3 = String('hello'); 说明：以上代码中，str1是对象，而str2和str3是字符串（基本数据类型值） [2] 相等问题基本类型值判断相等=&gt;值相等引用类型值判断相等=&gt;值相等且引用相等对象是引用类型，因此在判断相等的时候有诸多的注意点和容易出错的地方123456789101112131415161718ex var str1 = '这是一个字符串'; //基本数据类型 var str2 = String('这是一个字符串'); //基本数据类型 console.log(str1 == str2); //true 相等 var str3 = new String('这是一个字符串'); //引用类型-对象 console.log(str1 == str3); //true //值相等 console.log(str2 == str3); //true //值相等 console.log(str1 === str3); //false //值相等,但是引用不相等 console.log(str2 === str3); //false //值相等,但是引用不相等 //判断下面的变量是否相等 var num1 = 10; //基本数据类型 var num2 = new Number(10); //对象 console.log(num1 == num2); //true console.log(num1 === num2); //false var bool1 = true; var bool2 = new Boolean(true); console.log(bool1 == bool2); //true console.log(bool1 === bool2); //false 原型链及相关属性方法简单说明原型链代码示例1234567891011121314151617&lt;script&gt; //01 提供Person构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置Person的原型对象 Person.prototype.showName = function () &#123; console.log(this.name); &#125; //03 创建Student构造函数 function Student(number) &#123; this.numer = number &#125; //04 设置Student的原型对象 Student.prototype = new Person();&lt;/script&gt; 原型链图示例 Object对象Object构造函数01 使用Object构造函数创建字符串对象12345678//01 创建字符串对象var str1 = new String(\"测试字符串\");var str2 = new Object(\"测试字符串\");var str3 = str1;//注意:对象比较相等(需要引用[地址]相等)console.log(str1 == str2); //falseconsole.log(str1 === str2); //falseconsole.log(str1 === str3); //true 02 使用Object构造函数创建数字对象12var num = new Object(10);console.log(typeof num); //object 03 使用Object构造函数创建布尔类型对象12var bool = new Object(true); console.log(typeof bool); //object js中所有的内置或自定义对象都继承自Object对象,几乎所有的对象都可以使用Object.prototype上面的属性和方法 Object.prototype01 因为js中所有的对象都继承自Obejct,都可以使用Object对象的原型属性和方法,因此不要轻易的扩展Object.prototype。02 Object.property中的属性和方法 ① constructor 指向原型相关联的构造函数，为Object ② hasOwnProperty 判断对象中是否拥有某个实例属性(不包括原型链上面的属性) ③ isPrototypeOf 校验某个对象是否是指定对象的原型对象(整条原型链) ④ propertyIsEnumerable 属性是否存在且可枚举(使用for循环可以遍历,即目标属性能否在for循环中显示出来) ⑤ toString() 返回一个描述目标对象的字符串,对象则返回[object object] toString(参数) 参数出可以传入一个用于进制数的参数,该参数的默认值为10(主要针对Number类型有效) ⑥ toLocaleString 同toString,但是会做一些本地化的处理。 ⑦ valueOf() 如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。 Date对象调用该方法会返回一个时间戳。 constructor说明：该属性指向创建该对象的构造函数，在这里为Object123456function Person() &#123; &#125; var p = new Person(); console.log(p.constructor); //function Person() &#123;&#125; console.log(Person.prototype.constructor); //function Person() &#123;&#125; console.log(Object.prototype.constructor); //function Object() &#123; [native code] &#125; hasOwnProperty说明：判断对象中是否拥有某个实例属性(不包括原型链上面的属性)12345678function Person() &#123; this.name = \"默认的姓名\"&#125;//检查对象中是否拥有指定的属性(实例属性)var p1 = new Person();p1.hasOwnProperty(\"name\"); //truep1.hasOwnProperty(\"age\"); //falsep1.hasOwnProperty(\"constructor\"); //对象的constructor是从原型对象上继承的 isPrototypeOf说明：校验某个对象是否是指定对象的原型对象(整条原型链);1234567891011121314&lt;script&gt; var obj = &#123; name:\"张三\", age:20, hello:function () &#123; console.log(\"hello\"); &#125;, showName:function () &#123; console.log(this.name); &#125; &#125; //属性是否存在且可以枚举 console.log(obj.propertyIsEnumerable(\"name\")); //true&lt;/script&gt; toString说明：返回一个描述目标对象的字符串,对象则返回[object object]12345678910111213&lt;script&gt; var obj = &#123;&#125;; console.log(obj.toString()); //打印[object Object] var arr = [1,2,3,4,5]; console.log(arr.toString()); //打印1,2,3,4,5 var num = 10; console.log(num.toString()); //10 var date = new Date(); console.log(date.toString()); //Mon Feb 13 2017 19:00:13 GMT+0800 (CST) //toString方法可以传入参数,在处理Number类型数据的时候,可以传入指定的进制 console.log(num.toString(2)); //1010 == 1*2*2*2+0*2*2+1*2+1*1 = 10 console.log(num.toString(3)); //101 == 1*3*3 + 0*3 + 1*1 = 10&lt;/script&gt; toLocaleString说明：作用同toString方法一致，但是会做一些本地化的处理. valueOf说明：① 如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。② 如果是Date类型，则返回时间戳。123456789&lt;script&gt; var obj = &#123;&#125;; console.log(obj + 1); //[object Object]1 //说明:如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。 var o = &#123;name:\"张三\"&#125;; console.log(o + 1); //[object Object]1 var date = new Date(); console.log(date.valueOf()); //1486984088998&lt;/script&gt; 静态成员和实例成员静态成员 定义在构造函数上面的成员(属性和方法) 实例成员 定义在实例对象上面的成员(属性和方法) 建议 ① 把工具类的方法写成静态方法 ② 把和对象相关的方法写成实例方法(成员) 代码示例12345678910111213141516&lt;script&gt; function Person() &#123; this.name = \"张三\"; //实例属性 this.showName = function () &#123; console.log(this.name); &#125;; &#125; //为Person构造函数添加静态成员 Person.des = \"描述信息\"; Person.add = function (msg) &#123; console.log(\"添加信息\" + msg); &#125;; Person.add(\"这是一个+操作\"); var p1 = new Person(); p1.showName();&lt;/script&gt; Function构造函数函数创建的几种方式 12301 函数声明02 字面量的方式创建03 使用new Function的形式创建 函数创建代码示例 12345678function func01() &#123; console.log(\"函数声明\"); &#125; var func02 = function () &#123; console.log(\"字面量方式创建\"); &#125; //使用Function构造函数创建 var func03 = new Function(); Function构造函数创建函数 参数说明:可以传入多个参数 最后一个参数:传入的最后一个参数为函数的函数体内容 其他参数:创建出来的函数的参数 如果只有一个参数,则表示这是该函数的函数体内容 传递参数的格式:以字符串的方式进行传参代码示例123456//需求01 使用Function构造函数创建一个函数对象,该函数执行一行打印操作var funcName01 = new Function(\"console.log('让我掉下眼泪的,不止昨夜的酒')\");funcName01();//需求02 使用Function构造函数创建一个函数对象,该函数需要接受两个参数,要求返回他们的和var funcName02 = new Function(\"a\",\"b\",\"return a + b;\");console.log(funcName02(10, 20)); //30 解决函数体代码过长的问题（1）使用转义字符，写在一行中（2）使用+操作符来拼接字符串（3）使用``操作符来管理字符串（4）使用模板先处理字符串，然后在js中获得模板中的内容 arguments、length和calleearguments参数说明：在js中的函数中，有两个隐藏的参数分别是this和arguments1234arguments 是一个类似数组的结构,可以通过下标来操作函数的参数,但并非数组类型的。在函数调用的时候,会将函数的所有参数都传入arguments对象中保存,因此我们可以通过操作arguments属性来操作参数形参的数量大于实参的数量,则依次传入,未传入的设置为undefined形参的数量小于实参的数量,则arguments中保存实际的值 length 函数内部的arguments数组拥有length属性,可以通过该属性获取用户调用时传入的实参的个数 函数本身有一个length属性,可以通过该属性来获取形式参数的个数 callee方法 函数内部的arguments对象中,有一个callee方法,该方法指向函数自身,常用于匿名函数的递归调用。 代码示例12345678910111213141516171819&lt;script&gt; function func() &#123; console.log(arguments); console.log(arguments.length); //调用函数时实际传入的参数数量 &#125; func(1,2,3,4,5); console.log(func.length); //预期的参数数量 —— 函数的形参数量 function func02(a,b) &#123; console.log(a, b); console.log(arguments); &#125; func02(1,2,3); //实参的数量 &gt; 形参的数量 则arguments保存实参的值 func02(1); //实参的数量 &lt; 形参的数量 则不足的补undefined //匿名函数调用 (function () &#123; //如果需要在该函数中调用自身,则可以使用arguments.callee方法 arguments.callee(); &#125;)();&lt;/script&gt; Function的应用01 数组去重123456789101112 var func = new Function(\"arr\",` var array = []; for(var i = 0 ; i&lt;arr.length; i++) &#123; if(array.indexOf(arr[i]) == -1) &#123; array.push(arr[i]); &#125; &#125; return array;`); console.log(func([1, 2, 3, 4, 5, 3, 4, 2]));; 02 返回传入函数中所有数据的最大值123456789101112var func = function () &#123; var maxNumber = arguments[0]; for(var i = 0;i&lt;arguments.length;i++) &#123; if (maxNumber &lt; arguments[i]) &#123; maxNumber = arguments[i]; &#125; &#125; return maxNumber;&#125;console.log(func(1, 2, 3, 45, 5, 6, 7, 8, 30, 21)); eval 简单说明eval 的基本使用eval函数用来讲字符串转换为JS的代码,并执行 eval 处理JSON数据代码示例123456&lt;script&gt; var jsonData = '&#123;\"name\":\"张三\",\"age\":18&#125;'; //把json的数据转换为对象 var obj = JSON.parse(jsonData); console.log(obj);&lt;/script&gt; 12345678910111213&lt;script&gt; var jsonData = '&#123;\"name\":\"张三\",\"age\":18&#125;'; //var obj = eval(jsonData); //注意:如果直接这样写代码则会报错 //正确的处理方式 //方式一 eval(\"var obj = \" + jsonData); console.log(obj); //方式二 //说明:使用eval来解析json格式字符串的时候,会将&#123;&#125;解析为代码块,而不是字面量 // 在使用的时候为了避免这种错误,需要在JSO的最外面加上(),如此则会把大括号当做一条语句来解析 var o = eval(\"(\"+jsonData+\")\"); console.log(o);&lt;/script&gt; eval 注意事项 ① eval函数本身功能强大,但它的特性也为程序带来了很大的不确定性,因此在开发中并不推荐使用。 ② eval函数是动态的执行代码,因此其效率不如直接执行静态脚本高。 eval和Function比较12相同点:都能够把字符串转换为Javascript的代码不同点:eval转换为js的代码之后马上就执行,而Function需要先创建函数,调用函数之后才会执行。 Function.prototype原型链关于Function和自定义构造函数的原型对象 Function.prototype 是一个空的函数 自定义构造函数的原型对象是一个空的对象 说明 Function也可以被当做是一个构造函数 通过new Function创建出来的函数,可以认为是Function的实例化对象。 Function的原型对象是一个空的函数,这个空的函数也是一个对象,它的原型对象是Object.prototype。 在JS中,Object的原型对象是所有对象的祖宗。 Function是构造函数,则其原型对象为空的函数 空的函数的原型对象为Object.prototype Function本身也是对象,则其构造函数为:function Function() { [native code] } 是自身 同Object类型 Object本身是构造函数,其原型对象是Object.prototype Object本身也是对象,其构造函数为:function Function() { [native code] 代码示例123456789101112131415//01 提供Person构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置Person的原型对象 Person.prototype.showName = function () &#123; console.log(this.name); &#125; //03 创建Student构造函数 function Student(number) &#123; this.numer = number &#125; //04 设置Student的原型对象 Student.prototype = new Person(); 完整的原型链示意图Object和Function的关系01 Object构造函数是通过Function构造函数实例化出来的02 Function构造函数也是通过Function构造函数实例化出来的 代码示例12345678&lt;script&gt; //检查对象是否是某个构造函数的实例 console.log(Function instanceof Function); console.log(Function instanceof Object); console.log(Object instanceof Object); console.log(Object instanceof Function); //注意:以上打印结果均为true&lt;/script&gt; 对象的拷贝操作浅拷贝如果对象中的属性是引用类型的值,那么存在数据共享问题,修改某个对象会对拷贝的对象产生影响代码示例123456789var o = &#123;name:\"张三\",car:&#123;number:\"2017\",type:\"火车\"&#125;&#125;;var obj = &#123;&#125;;//obj对象需要拷贝o对象中所有的属性for (var i in o )&#123; obj[i] = o[i];&#125;console.log(obj);o.car.type = \"飞船\";console.log(obj); 深拷贝 如果对象中的属性是值类型,那么就直接拷贝赋值 如果对象中的属性是引用类型,那么就再次调用拷贝方法,遍历对象 代码示例123456789101112131415161718192021222324252627 var o = &#123;name:\"张三\",car:&#123;number:\"2017\",type:\"火车\"&#125;&#125;; var obj = &#123;&#125;; function deepCopy(obj,tmp) &#123; tmp = tmp || &#123;&#125;; //如果没有传入,那么就创建一个空的对象 for(var i in obj) &#123; if (obj.hasOwnProperty(i)) //只拷贝实例属性 &#123; //判断是否是引用类型 if ((typeof obj[i]) == 'object') &#123; //重新调用拷贝方法 tmp[i] = Array.isArray(obj[i]) ? [] :&#123;&#125;; deepCopy(obj[i],tmp[i]); &#125;else &#123; //直接拷贝 tmp[i] = obj[i]; &#125; &#125; &#125; &#125;deepCopy(o,obj); console.log(obj); o.car.type = \"测试的类型\"; console.log(obj); console.log(o); 注意isArray的兼容性问题isArray是ECMA5中新推出的方法,需要处理兼容性问题123456if (Array.isArray != \"function\")&#123; Array.isArray = function (obj) &#123; return Object.prototype.toString.call(obj) == '[object Array]'; &#125;&#125; Number原型扩展小案例：在Number的原型对象上面定义一个新的方法add(),该方法接收一个参数,并将该参数与自身的值进行相加,然后进行返回。代码实现123456789Number.prototype.add = function (num) &#123; return this + num;&#125;var n = 10;console.log(n.add(3));//console.log(5.add(5)); 错误:解析器无法处理字面量的这种情况var num = new Number(50);console.log(num.add(20)); //70console.log((1).add(4)); //5 使用()把数字包起来 使用注意123（01）使用数字变量可以调用成功（02）使用数字表达式可以调用成功（03）直接使用数字字面量方式调用失败 js的语法解析器无法处理数字字面量这种情况。 With语句with语句简单介绍123with语句是js中一个强大但有争议的特性。with语句允许我们将一个对象的所有属性引用到当前的作用域允许我们无需使用拥有者对象的前缀，就可以直接对这些属性进行引用和赋值操作。 注意：ECMAScript5规范在严格模式下已经禁用了该语句，在开发中不推荐使用，但是要求能够看懂with的代码。 with语句内部细节说明： with语句会创建一个作用域，在该作用域内，在引用特定对象的属性时，可以不使用前缀。应用场景：对深层级对象的引用进行缩短。 在with作用域内部引用属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //[01] 测试with语句作用域内对对象属性的引用 //01 提供全局变量,名称为testValue var testValue = '测试使用的全局变量'; //02 提供对象,对象内部提供属性 var testObject = &#123; name:'对象的名称属性', testValue:'对象内部的属性' &#125;; //03 使用with语句引用 with(testObject) &#123; console.log(name); //对象的名称属性 console.log(testValue); //对象内部的属性 console.log(this); //window &#125; console.log(testValue); //测试使用的全局变量``` 总结：(1) 在with语句作用域内,对象属性的优先级绝对高于在更层级作用域内定义的同名变量(2) this(函数上下文)依然指向window,并不会收到with作用域的影响**在with作用域内进行赋值操作**```js //01 提供一个对象,在内部提供属性 var obj = &#123; name:'对象的内部属性', &#125; //02 with语句测试对对象属性的赋值操作 with(obj) &#123; name = '修正对象中name的值'; //在作用域内部添加变量(思考?该变量是添加为全局作用域还是当前obj对象的属性?) age = '25'; showName = function () &#123; console.log('name == ' + name); &#125;; &#125;; //测试修改对象属性操作 console.log(obj.name); //测试添加对象属性操作 console.log(obj.age); //undefined //obj.showName(); //obj.showName is not a function console.log('____________________'); console.log(this.name); //== name == window.name console.log(window.name); console.log(name); showName(); //==this.showName() ==window.showName() 总结：（1）在with作用域的内部我们可以使用无前缀引用对象的属性进行读取和赋值的操作 但是 不能使用无前缀的方式添加属性（2）如果使用无前缀的方式来添加属性[对不存在的属性进行赋值操作],那么属性将被添加到全局上下文[window|this]（3）可能产生的错误:意外的引入一个全局变量,而非为with作用域对象添加属性 with语句的问题（1）with作用域内操作优先级混乱（2）性能不好，会大大降低js代码的执行性能（3）ECMAScript5规定在严格模式下禁用with特性 with语句简化代码的替代方案使用即时调用函数来替代with语句，通过函数传参的方式使用更短的引用来替代冗长的引用前缀比使用with语句消除前缀的方式更好。123456789101112with(this.style)&#123; width = '200px'; height = '200px'; backgroundColor = '#ca3'; console.log(width); //要访问的本应该是外部的字符串变量 \"错误哈哈\",但是这里被解释为200px&#125;(function (s) &#123; s.width = '200px'; s.height = '200px'; s.backgroundColor = '#ca3';&#125;)(this.style); 使用面向过程的方式处理1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; var bookList = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ]; //增加操作 bookList.push(&#123;name:\"城堡\",author:\"卡夫卡\"&#125;); //查询操作 for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == \"飞鸟集\") &#123; console.log(obj); break; &#125; &#125; //修改操作 for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == \"飞鸟集\") &#123; obj.author = \"泰戈尔-戈尔泰\" &#125; &#125; //删除操作 for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == \"飞鸟集\") &#123; //删除该对象 bookList.splice(i, 1); &#125; &#125; console.log(bookList);&lt;/script&gt; 使用函数来封装图书管理操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script&gt; var bookList = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ]; //增加操作 function addBook(bookObj) &#123; bookList.push(bookObj); &#125; addBook(&#123;name:\"城堡\",author:\"卡夫卡\"&#125;); //查询操作 function getBook(name) &#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; return obj; &#125; &#125; return null; &#125; console.log(getBook(\"什么是批判\")); //修改操作 function updateBookData(name,authorName)&#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; obj.author = authorName; &#125; &#125; &#125; updateBookData(\"飞鸟集\",\"泰戈尔斯坦\"); //删除操作 function removeBook(name) &#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; //删除该对象 bookList.splice(i, 1); &#125; &#125; &#125; console.log(bookList);&lt;/script&gt; 数封装-复用形式12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; var bookList = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ]; //增加操作 function addBook(bookObj) &#123; bookList.push(bookObj); &#125; addBook(&#123;name:\"城堡\",author:\"卡夫卡\"&#125;); //查询操作 function getBook(name) &#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; return obj; &#125; &#125; return null; &#125; console.log(getBook(\"什么是批判\")); //修改操作 function updateBookData(name,authorName)&#123; var obj = getBook(name); obj.author = authorName; &#125; updateBookData(\"飞鸟集\",\"泰戈尔斯坦\"); //删除操作 function removeBook(name) &#123; var obj = getBook(name); var index = bookList.indexOf(obj); bookList.splice(index,1); &#125; addBook(&#123;name:\"东京人\",author:\"川端康成\"&#125;); console.log(bookList);&lt;/script&gt; 面向对象的方式管理图书123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;scrip&gt; var obj = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ];泰 function BookManager() &#123; this.bookList = null; &#125; BookManager.prototype = &#123; constructor:BookManager, init:function (arr) &#123; this.bookList = arr || []; &#125;, addBook:function (bookObj) &#123; this.bookList.push(bookObj) &#125;, getBook:function (name) &#123; for (var i = 0; i &lt; this.bookList.length; i++) &#123; var obj = this.bookList[i]; if (obj.name == name) &#123; return obj; &#125; &#125; return null; &#125;, updateBookData:function (name,authorName)&#123; var obj = this.getBook(name); obj.author = authorName; &#125;, removeBook:function (name) &#123; var obj = this.getBook(name); var index = this.bookList.indexOf(obj); this.bookList.splice(index,1); &#125; &#125;; //01 创建对象 var YYManager = new BookManager(); YYManager.init(obj); console.log(YYManager.bookList); //02 演示添加操作 YYManager.addBook(&#123;name:\"花田半亩\",author:\"田维\"&#125;); console.log(YYManager.bookList); //03 演示查询操作 console.log(YYManager.getBook(\"花田半亩\")); //04 演示更新操作 YYManager.updateBookData(\"花田半亩\",\"甜田\"); console.log(YYManager.getBook(\"花田半亩\"));; //05 演示删除操作 YYManager.removeBook(\"什么是批判\"); console.log(YYManager.bookList); //02 创建第二个人的图书管理对象 var wulitaotaoMManager = new BookManager(); wulitaotaoMManager.init([&#123;name:\"装逼速成\",author:\"六扇门\"&#125;]); console.log(wulitaotaoMManager.bookList);&lt;/script&gt; 总结01 提供构造函数，在构造函数内部设置实例化属性02 把常用的操作提取成对象的实例方法，写在原型对象身上03 提供init方法，用于初始化数据04 注意：如果切断了原型对象那么需要修正内部的构造器属性指向 变量和函数 JavaScript中有严格模式和非严格模式两种运行环境,本章节主要讲严格模式及非严格模式下函数和变量的区别,最后简单讲诉了JavaScript作用域。 私有变量和函数 定义在构造函数内部而被this对象的变量,在外部无法访问到的变量和函数 公有变量和方法 对外暴露接口,可以通过构造函数对象创建的对象访问的属性和方法 代码示例1234567891011121314151617function Car(type,number) &#123; this.type = type; //公共的属性 this.number = number; var city = \"广州\"; //私有变量 var getNumber = function () &#123; //私有函数 return number; &#125;; var getType = function () &#123; return type; &#125;; //能够访问私有变量和函数的方法 --- 特权方法 this.getDescription = function () &#123; console.log(getNumber() + getType() + city); &#125; &#125; var car = new Car(\"汽车\",\"201718\"); car.getDescription(); 说明：能够访问构造函数内部私有变量|函数的方法称之为特权方法 构造函数的问题构造函数本身是一个函数，在调用的时候有多种调用方式。12① new 构造函数（）调用② 构造函数（）调用 以上，第二种调用方式存在作用域安全的问题 作用域安全的构造函数12345678910111213141516171819202122&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; //容错处理 if (this instanceof Person) &#123; //设置实例属性和方法 this.name = name; this.showName = function () &#123; console.log(this.name); &#125; &#125;else &#123; return new Person(name); &#125; &#125; //02 创建对象 var p1 = new Person(\"zhangsan\"); var p2 = new Person(\"lisi\"); p1.showName(); p2.showName();&lt;/script&gt; 新的问题说明:上面的代码在使用借用构造函数方式继承的时候存在问题，无法创建出的对象，原因在于通过call或者是apply函数调用的时候，内部的this绑定的子类型中的对象，因此在使用instanceOf 判断的时候，结果为假。解决：可以设置让子类型（构造函数）的原型对象为父类型的一个实例。代码示例123456789101112131415161718192021222324252627282930&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; //容错处理 if (this instanceof Person) &#123; //设置实例属性和方法 this.name = name; this.showName = function () &#123; console.log(this.name); &#125; &#125;else &#123; return new Person(name); &#125; &#125; //02 创建对象 var p1 = new Person(\"zhangsan\"); var p2 = new Person(\"lisi\"); p1.showName(); p2.showName(); // 使用借用构造函数来实现继承 function Boy(name)&#123; Person.call(this,name); &#125; //需要结合原型继承来解决 instanceOf 实例对象检测的问题 Boy.prototype = new Person(); var boy = new Boy(\"测试的名字\"); boy.showName();&lt;/script&gt; 严格模式关键字 “use strict”;实现严格模式:只需要在脚本代码中添加上上述关键字即可。 关键字具体说明12345(1) 注意区分大小写，必须全部都是小写的(2) 注意空格，整个字符串总共10个字符(3) 单引号和双引号无所谓，但是需要有双引号(4) 必须写在作用域的最顶部，注意其位置(5) 可以加分号，也可以不加，但是必须是一个字符串 注意：以下的关键字写法均是错误的123\"USE strict\";\" use strict \";\"(\"USE strict\").toLowerCase();\" 严格模式使用注意12345678910111 所有的变量必须使用var 关键字声明2 不能使用delete关键字删除全局变量 ,以前默认删除失败,严格模式下直接报错3 在对象中不允许有同名的属性4 函数的参数必须唯一(不能出现同名的参数)5 arguments对象的行为不同,在非严格模式下修改形参的值会反映到arguments中,而严格模式下则相对独立6 禁用了argument.callee和caller函数,他们一个引用函数本身,一个引用调用函数7 不能在if语句中声明函数8 禁止使用eval和arguments作为标识符9 修正this的值,在严格模式下,函数this的值始终是指定的值,无论指定的是什么值。10 禁用了with语句11 去掉了JavaScript中的八进制字面量(以0开头的八进制字面量是无效的语法) 1 所有的变量都必须使用var关键字声明12a = 10; //错误的演示console.log(10); ② 不能使用delete关键字删除全局变量1234//在非严格模式下,删除失败(静默失败) 失败了不吭声,严格模式下直接报错var a = 10;delete a;console.log(a); ③ 在对象中不允许有同名的属性1234567//在非严格模式下,会使用后面的属性赋值作为最终值,在严格模式下则直接报错var obj = &#123; name:\"张三\", name:\"李四\"&#125;console.log(obj); ④ 函数的参数必须唯一(不能出现同名的参数)123456789101112//在非严格模式下,如果函数在定义的时候,使用了多个同名的参数,则在函数内部形参的实际值为最后一个传入的实参值//在严格模式下,直接报错// function func(a,a,a) &#123;// console.log(a);// console.log(arguments);// &#125;function func(a,b,c) &#123; console.log(a); console.log(arguments);&#125;func(1,2,3); arguments对象的行为不同说明：（1）严格模式下,在函数内部修改了对象的指向,对arguments的值不会产生影响（2）在严格模式下,形参的值和arguments的值是相互独立的,在函数内部修改了形参的值对arguments不受影响（3）在非严格模式下，修改了形参的值，arguments中的数据会跟着改变123456789101112131415161718 //测试引用类型的值作为函数的参数function funcName(obj) &#123; console.log(obj); console.log(arguments[0]); //在函数内部修改形参的值 obj = &#123;age:20&#125;; console.log(obj); console.log(arguments[0]); &#125; funcName(&#123;name:\"张三\"&#125;); //测试基本类型数据作为函数的参数 function fun(str) &#123; console.log(str); console.log(arguments[0]); str = \"hello\"; console.log(arguments[0]); &#125; fun(\"hi\"); ⑥ 禁用了argument.callee和caller函数说明：argument.callee是对函数自身的引用argument.calller是对调用函数的引用12345678var num = (function (n) &#123; if (n ==1) &#123; return 1; &#125; return arguments.callee(n-1) + n; &#125;)(10); console.log(num); //55 ⑦ 不能在if语句中声明函数123456789//如果在if语句中声明函数，则会产生语法错误 if (true) &#123; console.log(\"________\"); function demo() &#123; console.log(\"呵呵呵呵\"); &#125; demo(); &#125; ⑧ 禁止使用eval和argument作为标识符1234var eval = \"测试的字符串\";console.log(eval);var arguments = \"参数列表\";console.log(arguments); ⑨ 修正this的值12345678在严格模式下,函数this的值始终是指定的值,无论指定的是什么值var name = \"测试的name\";function demoTest() &#123; //在非严格模式下,打印出来的this为全局的对象window console.log(this); //在严格模式下打印出来的this为undefined&#125;demoTest(); ⑩ 禁用了with语句1234567var o = &#123;name:\"暂时干\",age:20&#125;; with(o) &#123; name = \"lisi\"; age = 48 &#125; console.log(o); 禁用了八进制123//以0开头的数据常常引起混乱//var num = 023; //2*8 + 3 ==&gt; 19//console.log(num); //19 书写格式1234501 必须使用单引号或者是双引号括住字符串02 必须使用小写,不能出现大写字符03 必须是10个字符04 字符串后面的分号可以省略05 必须写在当前作用域的最顶上 代码示例123456789101112&lt;script&gt; //\"use strict\"; //正确写法 //\"use strict\" //正确写法 分号可以省略 //'use strict'; //正确写法 可以使用单引号 //\"use strict\"; //错误写法 必须是10个字符 //\"use Strict\"; //错误写法 所有的字符都必须小写 \"use strict\"; a = 10; // \"use strict\"; //错误写法 必须写在当前作用域的顶端 b = 20; console.log(a);&lt;/script&gt; 作用范围12① 函数的顶部(只对当前的函数有效)② script标签的顶部,只对当前的标签有效,对页面中其他的script无效 代码示例12345678910111213141516 //位置01 对func01和func02都有效 //\"use strict\"; function func01() &#123; //位置02 对func01有效,对func02无效 //\"use strict\"; a = 10; console.log(a); &#125; function func02() &#123; //位置03 对func02有效,但对func01无效 //\"use strict\"; b = 20; console.log(b); &#125;func01(); func02(); 函数的几种调用方式123401 普通函数调用 内部的this指向全局对象window02 构造函数调用 内部的this指向新创建的对象03 对象的方法调用 内部的this指向调用的对象本身04 通过call 或者是apply方式调用(函数上下文),this指向的是当前的上下文对象 this丢失demo演示123456789101112&lt;script&gt; var obj = &#123; name:\"张三\", getName:function () &#123; console.log(this.name); &#125; &#125;; //以对象的方法来进行调用 obj.getName(); //张三 var getName = obj.getName; getName(); //以普通函数的方式调用,此时内部的this指向的是window对象 打印的是window.name 为空值&lt;/script&gt; 代码示例0212345678910111213141516&lt;script&gt; //01 获取页面中id值为demo的标签 //var div = document.getElementById('demo');// var getId = document.getElementById;// var div = getId('demo'); //会报错?// console.log(div); //借用apply来修正this document.getElementById = (function (func) &#123; return function () &#123; return func.apply(document,arguments); &#125; &#125;)(document.getElementById); var getId = document.getElementById; var div = getId('demo'); //会报错? console.log(div);&lt;/script&gt; 代码说明：12301 因为document.getElementById方法的内部实现中需要使用到this,这个this本来期望指向的是document对象02 当我们以document.getElementById来调用的时候,内部的this指向document对象03 但是当我们以getId的方式调用的时候,内部的this指向的是window对象(因为我们以普通的方式进行调用) 作用域变量其作用的范围就是它的作用域 块级作用域说明：JavaScript中没有块级作用域123456for (var i = 0; i &lt; 10; i++) &#123; var num = i; &#125; console.log(i); console.log(num); //说明:如果有块级作用域,则i和num打印的结果应该为undefined 词法作用域123词法作用域:在代码写好的那一刻,变量的作用域就已经确定的动态作用域:变量的作用域由执行时的环境所决定说明:在js中不是动态作用域,当调用的时候,是往上查找的,不会到其他函数的作用域中去查找 在JavaScript中唯一能够产生作用域的东西是函数代码演示123456789101112131415161718192021222324&lt;script&gt; var a = \"这是第一个a\"; function func01() &#123; console.log(a); //先在当前作用域中查找,如果没有则访问全局的作用域 &#125; function func02() &#123; var a = \"这是第二个a\"; func01() &#125; func01(); //打印结果为:这是第一个a func02(); //打印结果为:这是第一个a&lt;/script&gt;&lt;script&gt; var a = \"这是第一个a\"; function func02() &#123; var a = \"这是第二个a\"; func01() &#125; function func01() &#123; console.log(a); //先在当前作用域中查找,如果没有则访问全局的作用域 &#125; func01(); //打印结果为:这是第一个a func02(); //打印结果为:这是第一个a&lt;/script&gt; 词法作用域的规则1234① 在函数内部允许访问外部的变量② 只有函数可以限定作用域③ 作用域规则首先使用提升规则分析④ 如果当前作用域中有该变量,则不考虑外部作用域的同名变量 变量和函数提升JS中的代码执行分为两个步骤① 预解析JavaScript在预解析阶段,会对使用var关键字声明的变量和function声明的代码块进行提升操作,提升到当前作用域的顶端② 执行 代码提升的几种情况 01 函数提升123456&lt;script&gt; func(); function func() &#123; console.log(\"测试的函数\"); &#125;&lt;/script&gt; 02 变量提升1234567&lt;script&gt; console.log(a); //打印出来的结果为undefined var a = 10; //var a; //注意:只会对变量的声明进行提升 //console.log(a); //a = 10&lt;/script&gt; 03 函数同名情况提升12345678910111213141516171819&lt;script&gt; func01(); //打印last function func01() &#123; console.log(\"first\"); &#125; func01(); //打印last function func01() &#123; console.log(\"last\"); &#125; //模拟提升后的情况 function func01() &#123; console.log(\"first\"); &#125; function func01() &#123; console.log(\"last\"); &#125; func01(); func01();&lt;/script&gt; 说明：预处理的时候，同名的函数都会进行提升，但是后面的会覆盖掉前面的 04 变量名和函数同名的情况12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; console.log(a); //打印function function a() &#123; console.log(\"我是一个函数\"); &#125; var a = 20; console.log(a); //打印20 //变量和函数提升后的结果 错误// function a() &#123;// console.log(\"我是一个函数\");// &#125;// var a ;// console.log(a);// a = 20;// console.log(a); //变量和函数提升后的结果 正确 function a() &#123; console.log(\"我是一个函数\"); &#125; console.log(a); var a = 20; console.log(a);&lt;/script&gt;```js总结:如果出现变量和函数同名的情况,则在进行提升的时候,只会提升函数到当前作用域顶端而忽略变量的提升操作**变量的提升是分作用域的**示例代码01```js&lt;script&gt; console.log(a); //undefined var a = 10; //模拟提升 var a; console.log(a); //undefined a = 10;&lt;/script&gt; 示例代码0212345678910111213141516171819&lt;script&gt; var num = 10; function func() &#123; var num = 20; console.log(num); &#125; console.log(num); //10 func(); //20 //模拟提升 var num; function func() &#123; var num; num = 20; console.log(num); &#125; num = 10; console.log(num); //10 func(); //20&lt;/script&gt; 示例代码031234567891011121314151617var num = 10;function func() &#123; console.log(num); var num = 20;&#125;console.log(num); //10func(); //undefiend//模拟提升var num;function func() &#123; var num; console.log(num); num = 20;&#125;num = 10;console.log(num); //10func(); //undefiend 示例代码041234567891011121314151617var num = 10;function func() &#123; console.log(num); num = 20;&#125;console.log(num); //10func(); //10//模拟变量提升var num;function func() &#123; console.log(num); num = 20;&#125;num= 10;console.log(num); //10func(); //10console.log(num); //20 函数表达式的提升说明：在使用函数表达式方式创建函数的时候,整个函数表达式并不会进行提升,只会对var声明的变量提升1234567891011func();var func = function () &#123; console.log(\"会不会被调用\");&#125;//以上如上代码将报错//模拟提升的过程var func;func(); //找不到这个函数func = function () &#123; console.log(\"会不会被调用\");&#125; 作用域链01 在js中函数可以创建作用域 02 函数中又可以创建函数(即又可以开辟新的作用域) 03 函数内部的作用域可以访问外部的作用域 04 如果有多个函数嵌套,那么就会构成一个链式的访问结构,也就是作用域链 05 注意:函数内部的作用域可以访问外部的作用域,但是外部的作用域却不能访问内部的作用域 代码示例1234567891011121314151617&lt;script&gt; function f1() &#123; //f1---&gt;全局作用域 function f4() &#123; //f4--&gt;f1---&gt;全局作用域 function f5() &#123; &#125; &#125; &#125; function f2() &#123; //f2--&gt;全局作用域 function f6() &#123; &#125; &#125; function f3() &#123; &#125;&lt;/script&gt; 作用域链绘图说明 ① 先画出全局作用域线条，然后在上面添加全局作用域中的函数和变量，作为0级作用域链 ② 画出全局作用域中的函数的作用域线条，，然后在上面添加当前作用域中的函数和变量，作为1级作用域链 ③ 以此类推，直至完成 示例代码01123456789function f1() &#123; function f2() &#123; &#125; &#125; var a = 20; function f3() &#123; function f4() &#123; &#125; &#125; 图示 示例代码021234567891011121314function f1() &#123; function f2() &#123; function f5() &#123; var b = \"demo\"; &#125; &#125; &#125; var a = 20; function f3() &#123; var c = \"啊哈哈\"; function f4() &#123; var d = \"test\"; &#125; &#125; 图示 作用域注意点和变量搜索原则注意点 01 在获取值和设置值的时候都是访问变量 02 并非在函数内部写了变量,这个变量就属于当前函数,而是必须使用var 关键字声明的变量才属于当前函数 03 函数在声明的时候,里面的代码并不会执行,只有在函数调用的时候才会执行 04 声明函数时候的函数名,其实也是一个变量名,可以通过这个变量名来进行设置和赋值 05 注意:在变量内部使用var 关键字声明一个变量并不会把同名的全局变量覆盖掉 1234567var a = 10;function f1() &#123; var a = 20; //注意:该行代码并不会覆盖掉全局变量中的变量a console.log(a);&#125;f1(); //20console.log(a); //10 代码点评：12在函数中使用var关键字声明变量a并不会覆盖全局作用域中的a。注意需要同时考虑变量在当前作用域的提升以及访问变量时的搜索原则。 1234567function f1() &#123; console.log(1);&#125;var f1 = \"demo字符串\"; //该行代码会把f1函数覆盖掉f1 = \"demoTest字符串\";console.log(f1);//f1(); 代码点评:函数的名称也是变量，如果在代码中出现同名的变量，那么函数的实现会被覆盖掉 变量搜索原则 01 在使用变量的时候,首先在自己的作用域中查找 02 如果找到了就直接使用,如果没有找到,那么就到上一级作用域中去查找 03 重复上面的步骤,直到0级作用域,如果还是找不到那么就返回undefined(报错) 闭包 闭包是学习JavaScript的难点之一，因JavaScript是单线程，故回调使用频繁，本章节主要讲了闭包以及回调。 闭包简单说明 闭:关闭,封闭 包:包住,包裹 闭包:通过某种方式实现的一个封闭的、包裹的对外不公开的结构|空间 闭包的原理:变量的访问原则(即上一级的作用域无法访问下一级的作用域),其实函数本身就是闭包。 闭包要解决的问题 提供一种间接的方式能够访问到函数内部的数据（变量） 实现思路 01 我们需要能够在函数外部访问函数内部的变量，正常情况无法访问； 02 在函数内部如果新创建函数，那么安装作用域链的原则，这个新创建的内部函数能够访问到函数中的这些变量。 03 我们如果能够操作函数中新创建的函数，那么就能够操作函数中的变量（如访问和设置等） 04 如果要能够操作函数中新创建的函数，那么需要在函数中把新创建的函数返回。 05 调用函数，接收并得到其返回值（是一个函数） 06 调用返回值（函数），通过函数传参的方式来设置函数中的变量。 07 调用返回值（函数），通过在函数内部再次return的方式来访问函数中的变量。 闭包的基本模式 在函数内部创建函数(内部函数),在这个内部函数中,可以操作外部函数中的变量 01 在函数(外部)中创建函数(内部函数),在该函数(内部函数)中操作外部函数中的变量 02 在外部函数中,把内部函数作为返回值返回 03 调用外部函数,并接收其返回值(是一个函数) 04 调用接收到的返回值(内部函数),来间接的操作外部函数中的变量 代码示例123456789function func() &#123; var num = 10; return function (n) &#123; num = n; console.log(num); &#125;&#125;var funcName = func();funcName(\"哗啦哗啦\"); 闭包获取数据获取单个数据（考虑赋值）123456789101112131415function func() &#123; var num = 123; return function (a) &#123; if (a !== undefined) &#123; num = a; &#125; return num; &#125;&#125;var f1 = func();var x = f1(456);var y = f1();console.log(x);console.log(y); 说明：上面的代码能够支持通过闭包对函数中的变量num进行访问（取值）或赋值的操作。 获取多个数据（数组）123456789101112131415function func() &#123; var name = \"张学友\"; var age = 40; return [ function getName() &#123; return name; &#125;, function getAge() &#123; return age; &#125; ]&#125;var foo = func();console.log(foo[0]()); //张学友console.log(foo[1]()); //40 说明：上面的代码能够满足返回多个变量值的需求，但是要数组操作的方式并不常见，且和使用习惯不符合。 利用对象返回并设置对个变量值1234567891011121314151617181920212223242526function foo() &#123; var name = \"张学友\"; var age = 45; return &#123; getName:function () &#123; return name; &#125;, getAge:function () &#123; return age; &#125;, setName:function (nameValue) &#123; name = nameValue; &#125;, setAge:function (ageValue) &#123; age = ageValue; &#125; &#125;&#125;var func = foo();console.log(func.getName()); //张学友console.log(func.getAge()); //45func.setName(\"张三\");func.setAge(30);console.log(func.getName()); //张三console.log(func.getAge()); //30 闭包的作用最基本的作用:闭包中的变量更安全,只能通过特定的接口来访问说明:12(1)创建一个私有的空间,保护数据,外界如果需要访问数据必须通过函数提供的指定方法(2)在这些指定的方法中,我们可以设置一些校验的逻辑,以保证对数据访问和设置的安全性 闭包的使用注意进程和线程 进程指的是系统中正在运行的一个应用程序。 线程:一个进程中可以有一个或多个线程,线程是CPU调度的最小单位,是真正执行任务的。 多线程:一个中可能有多条线程,多条线程之间并发的执行多个不同的任务。 单线程:一个进程中只有一条线程,即同一时间只能执行一个操作,只能干一件事情。 javascript是单线程的 js中的线程主要处理三块任务: 01 渲染任务 02 js的代码执行任务 03 js中的事件处理任务(如setTimeOut方法) javascript中代码的执行顺序 01 先把主任务执行完毕(代码任务)02 主任务执行完毕之后再执行次要的任务(包括setTimeOut方法等) 关于setTimeOut函数 函数的作用:一次性定时器(用于延迟执行任务) 参数: 第一个参数:要执行的任务 第二个参数:要延迟执行的时间,时间的单位是毫秒 函数说明： 01 至少在指定的时间后才能够执行回调函数 02 因为要等主任务中的代码执行完毕之后,才回去检查setTimeOut的回调函数。 通过闭包解决setTimeOut函数的问题12345678910111213&lt;script&gt; for (var i = 0; i &lt; 10; i++) &#123; setTimeout((function (j) &#123; return function () &#123; console.log(j); &#125; &#125;)(i),10); console.log(\"----\"); &#125;&lt;/script&gt; 函数的特殊之处函数的特殊之处在于,它本身是对象,且函数可以提供作用域。 (01) 函数可以在运行时动态的创建,还可以在程序执行过程中创建。 (02) 函数可以赋值给变量,可以被扩展,甚至是删除。 (03) 函数可以作为其他函数的参数和返回值。 (04) 函数可以拥有自己的属性和方法。 注意:{} 块在js中不会创建作用域,哪怕是if或者是while语句中使用var关键字声明的变量也并非局部变量。 函数是可以通过（）调用并执行的对象。 函数是第一型对象12301 函数可以像普通对象一样作为函数的参数02 函数可以像普通对象一样赋值给变量（函数表达式）03 函数可以像普通对象一个作为函数的返回值返回 代码示例123456789101112131415//函数作为参数传递 setTimeout(function () &#123; console.log(1); &#125;,100); //函数作为返回值 function func() &#123; return function () &#123; console.log(\"demo\"); &#125; &#125; var f = func(); f(); //demo //函数赋值给变量 var a = function()&#123;&#125; a(); //直接通过变量的名称调用函数 函数的两个特征1201 函数本质上是对象02 函数可以创建作用域 约定1234var add = function add(a,b)&#123;return a + b;&#125;; //命名函数表达式var add = function (a,b)&#123;return a + b;&#125;; //函数表达式,匿名函数 以上也称为使用字面量的方式来创建函数(或者是函数字面量)function add()&#123;&#125;; //函数声明 代码示例123456789101112131415&lt;script&gt; //01 函数声明 function demo01() &#123; &#125; //02 函数表达式(匿名函数) var demo02 = function () &#123; &#125;; //03 命名函数表达式 var demo03 = function demo03Test() &#123; &#125;; //04 打印name属性 console.log(demo01.name); //demo01 console.log(demo02.name); //demo02 (注意在火狐浏览器中打印出来的name属性为空) console.log(demo03.name); //demo03Test&lt;/script&gt; 函数回调回调函数(回调),当我们把某个函数作为参数传递给另一个函数的时候,这个函数就称为回调函数 函数回调的基本模式12345678910&lt;script&gt; function func(callBack) &#123; //处理其他的操作 callBack(); //调用回调函数 &#125; function demo() &#123; console.log(\"这是一个回调函数\"); &#125; func(demo); //注意调用函数的时候,参数是回调函数的引用(不要加括号);&lt;/script&gt; 函数回调解决this问题说明：如果回调函数是某个对象的方法,而该对象方法中使用了this指针那么该方法作为回调函数来使用的时候,需要注意this123456789101112131415161718192021222324252627//01 提供一个对象,该对象中永远showName方法var obj = &#123; name:\"默认的名字\", age:30, showName:function () &#123; console.log(this.name); &#125;, showAge:function () &#123; console.log(this.age); &#125;&#125;;//02 提供一个函数,该函数接受一个参数(函数引用)function demo(callBack,callBack_obj) &#123; //处理第一个参数传递对象方法字符串的形式 if(typeof callBack == 'string') &#123; callBack = callBack_obj[callBack]; &#125; if (typeof callBack == 'function') &#123; callBack.call(callBack_obj); &#125;&#125;//demo(obj.showName,obj);//demo(obj.showAge,obj);//传递字符串和对象来进行调用demo(\"showName\",obj); 代码说明：123（01）以上代码传入两个参数，分别为具体的回调函数，和该回调函数所属的对象（02）该函数的参数接受两种方式的回调传递（一种是直接传递函数引用，一种是直接以字符串的方式传递对象方法的字符串）（03）在函数内部对传入的回调参数做处理，修正this的问题 函数作为函数的返回值12① 使用闭包实现一个计数器(在该示例中setup函数的返回值为一个函数)② 通过调用返回值(一个函数),可以操作setup函数中的变量 123456789101112&lt;script&gt; var setup = function () &#123; var count = 0; return function () &#123; return count ++; &#125; &#125; var next = setup(); console.log(next()); //0 console.log(next()); //1 console.log(next()); //2&lt;/script&gt; 惰性函数定义说明：某个函数直到第一次使用的时候才被正确的定义,并且其具有向后惰性,执行更少的工作。应用场景:函数有一些初始化的准备工作要做,且只需要执行一次的情况。特点:能够更新自己(函数)的实现。缺点: 01 当重新定义自身的时候,已经添加到原始函数的任何属性都会丢失。 02 如何函数被赋值给了其他的变量或者是对象方法,那么在使用变量或者是对象方法调用时仍然会执行旧的函数体。代码示例123456789function foo() &#123; console.log(\"foo!\"); foo = function () &#123; console.log(\"new foo!\"); &#125;&#125;//函数的调用//foo(); //foo!//foo(); //new foo! 问题： ① 添加属性 ② 把函数赋值给新的变量 ③ 以对象的方法调用函数 当惰性函数定义在处理以上三种情况的时候，使用新的变量名调用或者是是以对象的方法来调用函数，那么该函数在执行的时候并不会更新自身，而是执行旧的函数体的内容 代码示例1234567891011121314151617181920212223242526272829&lt;script&gt; //01 声明函数foo function foo() &#123; console.log(\"foo!\"); foo = function () &#123; console.log(\"foo! foo!\"); &#125; &#125; //02 为foo函数对象添加属性 foo.description = \"foo函数的描述信息\"; //03 把foo函数赋值给其他的变量 var func = foo; //04 把foo函数赋值给对象中的方法 var obj = &#123; showFoo:foo &#125; //05 验证并演示输出 func(); //foo! func(); //foo! console.log(func.description); //foo函数的描述信息 //总结:01 如果把函数赋值给其他的变量,那么在以其他变量的方式调用时不会更新自身,还是执行旧的函数体 obj.showFoo(); //foo! obj.showFoo(); //foo! console.log(obj.showFoo.description); //foo函数的描述信息 //总结:02 如果把函数赋值给对象的方法,那么在以对象方法形式调用时不会更新自身,还是会执行旧的函数体。 foo(); //已经更新过foo函数 foo! foo! foo(); //已经更新过foo函数 foo! foo! console.log(foo.description); //undefined&lt;/script&gt; 即时函数 定义:在函数定义之后立即执行该函数。即时函数模式的组成: ① 使用函数表达式来定义函数(匿名函数,注意不能使用函数声明方式) ② 在函数表达式末尾添加一组(),表示立即执行当前函数。 ③ 将整个函数包装在()中,有两种方式` 即时函数的作用 01 用来将所有的代码包装到当前的作用域中,并且不会将任何的变量泄露到全局作用域中。 02 js中没有代码块作用域,而函数是js中唯一可以创建作用域的。 03 即时函数就是利用了函数创建作用域这一点,来实现对一些需要封装且不允许外部访问的操作。 即时函数的优点01 不会产生全局变量,在即时函数内部定义的所有变量都仅仅只是该函数的局部变量,不会造成全局变量污染问题。02 具有更好的封装性,外部无法访问到该函数内部的数据。 即时函数代码示例12345678//第一种写法(function () &#123; console.log(\"即时函数的第一种写法\");&#125;());//第二种写法(function () &#123; console.log(\"即时函数的第二种写法\");&#125;)(); 写法补充123456789(function (a) &#123; console.log(a); &#125;(20)); +function (b) &#123; console.log(b); &#125;(30); -function (b) &#123; console.log(b); &#125;(40); 即时函数的传参和返回值12345678910//01 接受参数 (function (str) &#123; console.log(str); //hello &#125;)(\"hello\"); //02 提供返回值并赋值给新的变量 var foo = (function () &#123; return 2 + 1; &#125;)(); console.log(foo); //3 即时对象初始化01 结构特征:12345① 提供一个对象,在该对象内部提供一个init初始化方法② 使用()把对象包装起来(让字面量变成表达式)③ 然后随即调用init方法,完成初始化操作。 02 基本结构({}).init(); 03 模式优点 在执行一次性的初始化任务时保护全局的命名空间。 代码示例1234567891011121314&lt;script&gt; (&#123; name:\"张三\", age:23, getDescript:function () &#123; console.log(\"名字:\" + this.name + \"年龄:\" + this.age); &#125;, //注意:在对象中访问对象的属性和方法都需要使用this.前缀 init:function () &#123; this.getDescript(); //其他的初始化处理 &#125; &#125;).init();&lt;/script&gt; 函数属性缓存思路说明 01 函数是对象，因此可以在函数上面添加属性和方法 02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果 03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为value） 04 等需要获取参数对应指定结果的时候，考虑先去缓存中查找，如果有那么就直接使用，若没有则计算并保存一份到缓存中。 代码示例(单个参数)1234567891011121314var func = function (param) &#123; if (func.cache[param] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[param] = result + param; &#125; return func.cache[param];&#125;func.cache = &#123;&#125;; //空对象console.log(func(\"demo\")); //字符串democonsole.log(func(\"test\")); //字符串testconsole.log(func(\"demo\")); //字符串demo 直接使用属性缓存中的数据,而不再进行复杂的计算(可以提升性能) 代码示例（多个参数）12345678910111213var func = function () &#123; var key = JSON.stringify(Object.prototype.slice.call(arguments)); if (func.cache[key] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[key] = result + key; &#125; return func.cache[key];&#125;func.cache = &#123;&#125;; //空对象func(\"123\",\"456\"); ////说明:如果传入的参数数量超过1,则可以将传入的参数序列化为一个json字符串作为参数处理。 代码说明：slice:返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素 函数属性缓存 很高兴你能看到这里，希望对你学习JavaScript有帮助。这是最后一章节，主要讲有关JavaScript的设计模式。 思路说明 01 函数是对象，因此可以在函数上面添加属性和方法 02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果 03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为value） 04 等需要获取参数对应指定结果的时候，考虑先去缓存中查找，如果有那么就直接使用，若没有则计算并保存一份到缓存中。 代码示例(单个参数)12345678910111213var func = function (param) &#123; if (func.cache[param] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[param] = result + param; &#125; return func.cache[param];&#125;func.cache = &#123;&#125;; //空对象console.log(func(\"demo\")); //字符串democonsole.log(func(\"test\")); //字符串testconsole.log(func(\"demo\")); //字符串demo 直接使用属性缓存中的数据,而不再进行复杂的计算(可以提升性能) 代码示例（多个参数）12345678910111213var func = function () &#123; var key = JSON.stringify(Array.prototype.slice.call(arguments)); if (func.cache[key] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[key] = result + key; &#125; return func.cache[key];&#125;func.cache = &#123;&#125;; //空对象func(\"123\",\"456\"); ////说明:如果传入的参数数量超过1,则可以将传入的参数序列化为一个json字符串作为参数处理。 代码说明：slice:返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素 命名空间模式作用:(1)有助于减少程序中所需要的全局变量的数量(2)并且同时还有助于避免命名冲突或过长的名字前缀。 说明：JavaScript中并没有内置的命名空间 如何实现命名空间可以为应用程序创建一个全局对象,然后将所有功能都添加到该全局对象中 从而在具有大量函数,对象和其他变量的情况下并不会污染全局范围。 建议 全局命名空间的名称可以随便写,但建议使用项目的名称或者是APP的名称 按照习惯,通过程序员会约定以全部大写的方式来约定全局命名空间。 命名空间模式的缺点 ① 需要输入更多的字符,在每个变量和函数前面都需要附加上前缀,总体上增加了代码的体积。 ② 仅有一个全局实例,意味着代码的任何部分都能够修改当前的实例。 ③ 很长的前缀意味着需要花更长的时间来解析属性(变量|属性访问原则-就近原则) 代码示例（零散的代码）123456789101112131415&lt;script&gt; //构造函数 function Person() &#123; &#125; function Man() &#123; &#125; var array = [1,2,3,4,5,6]; var testDemo01 = \"测试字符串01\"; var testDemo02 = \"测试字符串02\"; var obj = &#123;&#125;; obj.des = \"描述信息\"; obj.logDes = function () &#123; console.log(obj.des); &#125;&lt;/script&gt; 代码示例(命名空间模式) 1234567891011121314151617&lt;script&gt; //01 提供一个全局变量 var MYAPP = &#123;&#125;; //02 处理构造函数 MYAPP.Person = function () &#123;&#125;; MYAPP.Man = function () &#123;&#125;; //03 处理变量 MYAPP.array = [1,2,3,4,5,6]; MYAPP.testDemo01 = \"测试字符串01\"; MYAPP.testDemo02 = \"测试字符串02\"; //处理对象 MYAPP.obj = &#123;&#125;; MYAPP.obj.des = \"描述信息\"; MYAPP.obj.logDes = function () &#123; console.log(obj.des); &#125;&lt;/script&gt; 说明 01 在使用命名空间模式的时候,因为所有的变量和属性都添加到同一个全局对象下面,因此该全局对象下面可能有很多很多的属性。 02 而我们在添加属性的时候,很有可能该属性已经存在,这导致可能会覆盖掉之前的属性。 03 所以,在添加一个属性或者是创建一个命名空间之前,最好是先检查它是否已经存在。 04 但是如果每次添加属性都需要对属性进行检查则会产生代码冗余问题。 示例代码1234567891011121314151617181920212223242526//01 不好的演示//其他代码//var MYAPP = &#123;&#125;; //注意这是不安全的代码,因为有可能覆盖掉上下文中的代码//02 在创建命名空间之前,先检查该命名空间是否存在// if (MYAPP == 'undefined')&#123;// var MYAPP = &#123;&#125;;// &#125;//03 更好的做法var MYAPP = MYAPP || &#123;&#125;; //如果MYAPP为假,那么就返回&#123;&#125;并赋值给MYAPP//04 添加属性时的检查问题//假如现在需要添加一个name属性,那么在添加之前需要先检查该属性是否存在if (MYAPP.name == 'undefined')&#123; MYAPP.name = \"默认的名称\";&#125;//假如要添加一个obJ属性if (typeof MYAPP.obj == 'undefined')&#123; MYAPP.obj = &#123;&#125;;&#125;//假如要给MYAPP.obj添加属性,则if (typeof MYAPP.obj.des === \"undefined\")&#123; MYAPP.obj.des = \"对象的描述信息\"&#125;console.log(MYAPP.obj); 代码说明：我们在添加属性或者是方法的时候,比较安全的做法是在添加之前先在当前环境中进行检查,以免覆盖但是我们的检查操作催生出了一个新的问题,就是重复代码过多,能否考虑把检查的过程抽取 示例代码1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; var MYAPP = MYAPP || &#123;&#125;; MYAPP.namescape = function (string) &#123; //split() 方法用于把一个字符串分割成字符串数组 var parts = string.split('.'); var parent = MYAPP; console.log(parts); //先去掉最前面的冗余的全局变量 if(parts[0] == \"MYAPP\") &#123; //splice() 方法向/从数组中添加/删除项目,然后返回被删除的项目 //parts.splice(0,1); //slice() 方法可从已有的数组中返回选定的元素 //返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素 parts = parts.slice(1); &#125; console.log(parts,\"处理之后的数组\"); //通过for循环来遍历结构 for (var i = 0; i &lt; parts.length; i++) &#123; //检查属性,如果对应的属性不存在,那么就创建一个属性 if (typeof parent[parts[i]] == 'undefined') &#123; //初始化为一个空的对象 parent[parts[i]] = &#123;&#125;; &#125; //修正parent的值 parent = parent[parts[i]]; &#125; return parent; &#125; //代码示例 var testDemo01 = MYAPP.namescape(\"MYAPP.test.testDemo01\"); var testDemo02 = MYAPP.namescape(\"MYAPP.test.testDemo02\"); console.log(MYAPP); //忽略全面的前缀 MYAPP.namescape(\"sadsa.sadjaldj.adada.test\"); console.log(MYAPP); //演示长命名空间的情况 MYAPP.namescape(\"demo.testDemo.testDemos.ss.dd.qq.ddd.ffff.fff\"); console.log(MYAPP);&lt;/script&gt; 补充说明12301 split() 方法用于把一个字符串分割成字符串数组02 splice() 方法向/从数组中添加/删除项目,然后返回被删除的项目03 slice() 方法可从已有的数组中返回选定的元素 设计模式简单说明概念:设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案 注意,设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案 起源:该属于源于建筑行业 历史: （1）由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学 （2）四人帮著作《设计模式：可复用面向对象软件的基础》（Design Patterns - Elements of Reusable Object-Oriented Software） （3）Gang of Four:Erich Gamma + Richard Helm + Ralph Johnson +John Vlissides 优点: 为了可重用代码、让代码更容易被他人理解、保证代码可靠性 设计模式的分类创建型模式:工厂方法模式 + 抽象工厂模式 + 单例模式 + 建造者模式 + 原型模式 结构型模式:适配器模式 + 代理模式 + ... 行为型模式:观察者模式 + 命令模式 + ... 单例模式的思想保证一个特定的类只有一个实例。 即当我们第二次创建新对象的时候,得到的应该是和第一次创建的对象一模一样的对象(同一个对象) 其他语言中实现单例模式 在其它有Class的语言中,实现单例模式核心步骤是: 01 在创建对象实例时候判断,该类的实例对象是否已经存在,如果已经存在,那么就直接返回 02 如果不存在,那么就创建一个新的实例对象,并保存起来,下次创建实例对象的时候直接使用。 JavaScript中的单例模式JavaScript是一门弱类型,动态,基于原型的语言,并没有类,只有对象。 在JavaScript中要实现单例模式有很多种方式。 最简单的方式:使用字面量的方式来创建对象,因为在JavaScript中对象之间永远不可能相等,除非他们是同一个对象。 使用字面量方式创建的对象总是唯一的12345script&gt; var obj1 = &#123;name:\"zhangsan\"&#125;; var obj2 = &#123;name:\"zhangsan\"&#125;; console.log(obj1 == obj2); //false&lt;/script&gt; 使用new操作符创建对象实现单例 实现单例模式的几种途径 ① 在代码中提供一个全局变量来存储创建出来的实例 缺点:该全局变量可能会被轻易的修改和覆盖 ② 尝试在构造函数的静态成员中缓存实例属性。缺点:函数的静态属性在外部可以直接修改,容易导致实例对象的丢失。 ③ 将实例对象包装在闭包中。优点是安全性较好,无法被轻易的修改,缺点是有额外闭包的开销。 代码示例1234567function China() &#123;&#125;//创建对象var china01 = new China();var china02 = new China();//思考:如果想要实现单例模式,那么最终的结果必要是china01 和china02是同一个对象,那么如何实现 实现方案(一)使用全局变量方式存储创建出来的实例对象代码示例12345678910111213141516171819202122232425262728&lt;script&gt; //01 提供一个全局变量 var instance; //02 提供一个构造函数 function Person() &#123; if (instance == undefined) &#123; instance = this; &#125; this.name = \"默认的名称\"; this.age = 66; //使用全局变量来接收内部创建出来的实例对象(this) return instance; &#125; //03 使用构造函数创建对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2); console.log(p1.name); console.log(p2.name); p1.name = \"修改之后的名称\"; console.log(p1.name); console.log(p2.name); //说明:在上面的方案中我们使用一个全局变量来接收实例对象的值,在构造函数内部也是通过判断这个全局变量来做一些其他的处理 instance = &#123;&#125;; var p3 = new Person(); console.log(p1 == p3);&lt;/script&gt; 说明：这种方法确实可以实现单例模式,但是并不安全,因为全局变量可能会被轻易的修改或者是覆盖,因此不推荐这种方式。 实现方案(二)通过构造函数静态属性来缓存实例对象123456789101112131415161718192021222324252627&lt;script&gt; //01 提供一个构造函数 function Person() &#123; //02 在内部判断构造函数的静态属性中是否拥有实例对象 //如果拥有实例对象,那么就直接返回,否则就设置实例对象,并赋值给构造函数的静态属性 if (typeof Person.instance == \"object\") &#123; return Person.instance; &#125; //设置实例对象的属性和方法 this.name = \"默认的名称\"; this.age = 66; //03 把内部创建的实例化对象赋值给构造函数的静态属性 Person.instance = this; //显示返回 //return Person.instance; //隐式返回 //return this; &#125; //04 创建实例对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2); Person.instance = &#123;&#125;; var p3 = new Person(); console.log(p1 == p3); //false&lt;/script&gt; 说明：在构造函数外部可以直接访问其静态成员(属性和方法),可能会导致实例对象的丢失。 实现方案(二)通过闭包-惰性函数定义来实现12345678910111213141516171819202122&lt;script&gt; //01 提供一个构造函数 function Person() &#123; //02 在函数内部使用私有变量来缓存实例 var instance = this; //03 设置实例对象的属性和方法 this.name = \"默认的姓名\"; this.age = 66; //04 使用惰性函数定义来更新构造函数的实现 //通过一个闭包来返回缓存的实例对象 Person = function () &#123; return instance; &#125; &#125; //05 创建对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2); //代码说明:第一次调用原始构造函数的时候,它会像往常一样返回this(指向内部新创建的实例对象) //再后面调用的时候,它会执行更新后的构造函数,在这个新的函数实现中,我们通过闭包来访问了私有变量,并简单的返回。 //这个instance私有变量存储的是第一次调用构造函数时创建出来的实例对象&lt;/script&gt; 新的问题01 因为内部使用惰性函数定义(重写构造函数会导致之前添加在构造函数中的属性丢失),所以存在属性丢失问题02 在上面的代码中,体现在于创建对象前后设置的构造函数的原型对象丢失问题 代码示例123456789101112131415161718192021222324252627&lt;script&gt; function Person() &#123; var instance = this; this.name = \"默认的姓名\"; this.age = 66; Person = function () &#123; return instance; &#125; &#125; //设置构造函数的原型对象 Person.prototype.des = \"描述信息\"; var p1 = new Person(); //在创建第一个对象之后,设置原型对象 Person.prototype.someThing = \"something\"; var p2 = new Person(); console.log(p1 == p2); console.log(p1.des); //描述信息 console.log(p2.des); //描述信息 console.log(p1.someThing); //undefined console.log(p2.someThing); //undefined //打印对象的构造函数 console.log(p1.constructor.name); //Person console.log(p2.constructor.name); //Person //判断对象的构造函数 console.log(p1.constructor == Person); //false console.log(p1.constructor == p2.constructor,\"构造函数是否一致\");&lt;/script&gt; 解决问题的核心过程1234567891001 提供一个构造函数02 在构造函数内部提供一个私有变量instance03 重写构造函数,返回私有变量instance04 把原有的原型对象赋值给新Person构造函数的原型对象05 调用new 构造函数方法创建一个实例化对象赋值给instance06 修正instance实例的构造器属性,指向新的构造函数(注意:虽然重写了构造函数,但是instance的构造函数仍然是以前的Person)07 设置实例属性和方法08 返回instance对象代码示例 12345678910111213141516171819202122232425262728293031323334353637383940&lt;script&gt; function Person() &#123; //01 提供一个私有变量 var instance; //02 重写构造函数 Person = function () &#123; console.log(instance); //console.log(instance.constructor); var t = this; console.log(t); return instance; &#125;; //03 保留原型属性 Person.prototype = this.__proto__; //这是一个空的对象 Person.lal = \"lala\"; //04 创建并使用私有变量来接收实例对象 instance = new Person(); //05 修正构造函数指针 instance.constructor = Person; //06 设置实例属性和方法 instance.name = \"默认的名字\"; instance.age = 66; //07 返回私有变量 return instance; &#125; Person.haha = \"哈哈\"; //设置构造函数的原型对象 Person.prototype.des = \"描述信息\"; var p1 = new Person(); //在创建第一个对象之后,设置原型对象 Person.prototype.someThing = \"something\"; var p2 = new Person(); console.log(p1 == p2); console.log(p1.des); //描述信息 console.log(p2.des); //描述信息 console.log(p1.someThing); //something console.log(p2.someThing); //something //打印构造器属性 console.log(p1.constructor == Person,\"验证构造器指向\");&lt;/script&gt; 全局变量方式实现单例-改进版1234567891011121314151617181920&lt;script&gt; var Person; (function () &#123; //01 提供一个局部变量instance var instance; Person = function Person() &#123; if (instance) &#123; return instance; &#125; instance = this; this.name = \"默认的名字\"; this.age = 66; &#125; &#125;)(); //创建对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2);&lt;/script&gt; 说明：通过即时函数来限定作用域,外部无法修改内部instance的值(现在是一个局部变量) 工厂模式简单说明工厂模式的目的是用于创建对象,通常在类或者是类的静态方法中实现。 工厂模式的目标 01 用一套方法去创建相似的目标。 02 在编译时不知道具体类型的情况下,为用户提供创建对象的接口 工厂模式实现过程 01 提供一个父构造函数 02 在父构造函数的原型上添加共享的方法 03 在父构造函数身上提供一个静态方法(静态工厂方法) 001 先获取参数(产品类型) 002 判断构造函数是否存在(容错性处理) 003 设置原型链继承:设置子构造函数的原型对象为父构造函数的一个实例对象(目的是为了让子构造函数创建的对象拥有父构造函数上面实例属性和原型属性) 004 使用子构造函数创建实例对象 005 返回新创建的实例对象 04 定义特定的工厂客户(静态方法) 05 通过父构造函数的静态工厂方法来创建产品对象 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; //01 提供一个父构造函数 function PhoneMaker() &#123;&#125;; //02 在父构造函数的原型上添加共享的方法 PhoneMaker.prototype.callPhoneDes = function () &#123; console.log(\"手机的特点是: \" + this.des); &#125; //03 在父构造函数身上提供一个静态方法(静态工厂方法) PhoneMaker.factory = function (type) &#123; //001 先获取参数(产品类型) var typeStr = type; //002 判断构造函数是否存在(容错性处理) if (typeof PhoneMaker[typeStr] !== 'function') &#123; throw \"Error 对应的构造函数不存在,不能生产该种类型的产品\"; &#125; //003 设置原型链继承 PhoneMaker[typeStr].prototype = new PhoneMaker(); //004 使用子构造函数创建实例对象 var newPhone = new PhoneMaker[typeStr](); //005 返回新创建的实例对象 return newPhone; &#125;; //定义特定的工厂客户(静态方法) PhoneMaker.iphone = function () &#123; this.des = \"最安全稳定的系统\"; &#125; PhoneMaker.oppo = function () &#123; this.des = \"充当五分钟,通话两小时\"; &#125; PhoneMaker.vivo = function () &#123; this.des = \"vivo手机,你的音乐手机\"; &#125; //通过父构造函数的静态工厂方法来创建产品对象 var vivo = PhoneMaker.factory('vivo'); var iphone = PhoneMaker.factory('iphone'); var oppo = PhoneMaker.factory('oppo'); vivo.callPhoneDes(); oppo.callPhoneDes(); iphone.callPhoneDes();&lt;/script&gt; 观察者模式观察者模式观察者模式又名为发布-订阅者模式，它定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。 观察者模式的特点（优点）12301 观察者模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案02 观察者模式可以取代对象之间硬性编码的通知机制，一个对象不再是显示的调用另外一个对象的接口，这种模式让两个对象松耦合的联系在一起，它们不需要清楚彼此的实现细节就能够相互通信。03 在这种设计模式中，不再是一个对象调用另外一个对象的方法，而是一个对象订阅另一个对象的特定活动并且在状态改变后获得通知 模型01 订阅者也称为观察者02 被观察的对象称为发布者或者是主题03 当发生一个重要事件的时候，发布者将会通知所有订阅者并且经常以事件的形式来传递消息。示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//01 提取成公共的发行者对象 var publisher = &#123; users:&#123; default:[] &#125;, //所有的订阅者对象 addUser:function (fn,type) &#123; //对订阅的类型进行判断 var type = type || \"default\"; //如果是新的订阅类型,那么我们需要做初始化的处理 if (this.users[type] == undefined) &#123; this.users[type] = []; &#125; this.users[type].push(fn); &#125;, removeUser:function (fn,type) &#123; this.tool(type,\"removerUser\",fn); &#125;, publish:function (type) &#123; this.tool(type,\"publish\"); &#125;, tool:function (type,funcType,fn) &#123; var type = type || \"default\"; var users = this.users[type]; if (users == undefined) &#123; console.log(\"当前没有任何订阅者\"); return; &#125; for (var i = 0; i &lt; users.length; i++) &#123; if (funcType == 'publish') &#123; users[i]() &#125;else &#123; if (users[i] == fn) &#123; users.splice(i, 1); break; &#125; &#125; &#125; &#125; &#125;; //02 提供一个工具函数,能够利用发行者对象的模板来快速创建新的发布者 function makePaper(o) &#123; for(var i in publisher) &#123; if (publisher.hasOwnProperty(i) &amp;&amp; typeof publisher[i] == 'function') &#123; o[i] = publisher[i]; &#125; &#125; o.users = &#123;default:[]&#125;; &#125; //03 创建发布者 var paper1 = &#123; day:function () &#123; this.publish(); &#125;, month:function () &#123; this.publish(\"month\") &#125;, year:function () &#123; this.publish(\"year\") &#125; &#125;; //把某个对象编程一个发布者 makePaper(paper1); //04 创建订阅者(当发布者发布消息的时候,订阅者能够收到信息--自动调用订阅者的方法) var obj = &#123; lookDayNews:function () &#123; console.log(\"obj - 查看最新的日报信息\"); &#125;, lookImageNews:function () &#123; console.log(\"obj - 查看图片信息\"); &#125; &#125;; //05 设置订阅 paper1.addUser(obj.lookDayNews); paper1.addUser(obj.lookImageNews,'month'); paper1.day(); paper1.month();&lt;/script&gt; 因本人能力有限，教程中难免出现疏忽，对此带来的不便敬请见谅。","categories":[{"name":"JavaScript简明教程","slug":"JavaScript简明教程","permalink":"http://www.1oveit.club/categories/JavaScript简明教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.1oveit.club/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"}]},{"title":"JavaScript简明教程（7）","slug":"js-07","date":"2016-05-28T01:05:25.000Z","updated":"2017-05-13T10:45:13.000Z","comments":true,"path":"2016/05/28/js-07/","link":"","permalink":"http://www.1oveit.club/2016/05/28/js-07/","excerpt":"很高兴你能看到这里，希望对你学习JavaScript有帮助。这是最后一章节，主要讲有关JavaScript的设计模式。 函数属性缓存思路说明 01 函数是对象，因此可以在函数上面添加属性和方法 02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果 03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为value） 04 等需要获取参数对应指定结果的时候，考虑先去缓存中查找，如果有那么就直接使用，若没有则计算并保存一份到缓存中。","text":"很高兴你能看到这里，希望对你学习JavaScript有帮助。这是最后一章节，主要讲有关JavaScript的设计模式。 函数属性缓存思路说明 01 函数是对象，因此可以在函数上面添加属性和方法 02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果 03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为value） 04 等需要获取参数对应指定结果的时候，考虑先去缓存中查找，如果有那么就直接使用，若没有则计算并保存一份到缓存中。 代码示例(单个参数)12345678910111213var func = function (param) &#123; if (func.cache[param] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[param] = result + param; &#125; return func.cache[param];&#125;func.cache = &#123;&#125;; //空对象console.log(func(\"demo\")); //字符串democonsole.log(func(\"test\")); //字符串testconsole.log(func(\"demo\")); //字符串demo 直接使用属性缓存中的数据,而不再进行复杂的计算(可以提升性能) 代码示例（多个参数）12345678910111213var func = function () &#123; var key = JSON.stringify(Array.prototype.slice.call(arguments)); if (func.cache[key] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[key] = result + key; &#125; return func.cache[key];&#125;func.cache = &#123;&#125;; //空对象func(\"123\",\"456\"); ////说明:如果传入的参数数量超过1,则可以将传入的参数序列化为一个json字符串作为参数处理。 代码说明：slice:返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素 命名空间模式作用:(1)有助于减少程序中所需要的全局变量的数量(2)并且同时还有助于避免命名冲突或过长的名字前缀。 说明：JavaScript中并没有内置的命名空间 如何实现命名空间可以为应用程序创建一个全局对象,然后将所有功能都添加到该全局对象中 从而在具有大量函数,对象和其他变量的情况下并不会污染全局范围。 建议 全局命名空间的名称可以随便写,但建议使用项目的名称或者是APP的名称 按照习惯,通过程序员会约定以全部大写的方式来约定全局命名空间。 命名空间模式的缺点 ① 需要输入更多的字符,在每个变量和函数前面都需要附加上前缀,总体上增加了代码的体积。 ② 仅有一个全局实例,意味着代码的任何部分都能够修改当前的实例。 ③ 很长的前缀意味着需要花更长的时间来解析属性(变量|属性访问原则-就近原则) 代码示例（零散的代码）123456789101112131415&lt;script&gt; //构造函数 function Person() &#123; &#125; function Man() &#123; &#125; var array = [1,2,3,4,5,6]; var testDemo01 = \"测试字符串01\"; var testDemo02 = \"测试字符串02\"; var obj = &#123;&#125;; obj.des = \"描述信息\"; obj.logDes = function () &#123; console.log(obj.des); &#125;&lt;/script&gt; 代码示例(命名空间模式) 1234567891011121314151617&lt;script&gt; //01 提供一个全局变量 var MYAPP = &#123;&#125;; //02 处理构造函数 MYAPP.Person = function () &#123;&#125;; MYAPP.Man = function () &#123;&#125;; //03 处理变量 MYAPP.array = [1,2,3,4,5,6]; MYAPP.testDemo01 = \"测试字符串01\"; MYAPP.testDemo02 = \"测试字符串02\"; //处理对象 MYAPP.obj = &#123;&#125;; MYAPP.obj.des = \"描述信息\"; MYAPP.obj.logDes = function () &#123; console.log(obj.des); &#125;&lt;/script&gt; 说明 01 在使用命名空间模式的时候,因为所有的变量和属性都添加到同一个全局对象下面,因此该全局对象下面可能有很多很多的属性。 02 而我们在添加属性的时候,很有可能该属性已经存在,这导致可能会覆盖掉之前的属性。 03 所以,在添加一个属性或者是创建一个命名空间之前,最好是先检查它是否已经存在。 04 但是如果每次添加属性都需要对属性进行检查则会产生代码冗余问题。 示例代码1234567891011121314151617181920212223242526//01 不好的演示//其他代码//var MYAPP = &#123;&#125;; //注意这是不安全的代码,因为有可能覆盖掉上下文中的代码//02 在创建命名空间之前,先检查该命名空间是否存在// if (MYAPP == 'undefined')&#123;// var MYAPP = &#123;&#125;;// &#125;//03 更好的做法var MYAPP = MYAPP || &#123;&#125;; //如果MYAPP为假,那么就返回&#123;&#125;并赋值给MYAPP//04 添加属性时的检查问题//假如现在需要添加一个name属性,那么在添加之前需要先检查该属性是否存在if (MYAPP.name == 'undefined')&#123; MYAPP.name = \"默认的名称\";&#125;//假如要添加一个obJ属性if (typeof MYAPP.obj == 'undefined')&#123; MYAPP.obj = &#123;&#125;;&#125;//假如要给MYAPP.obj添加属性,则if (typeof MYAPP.obj.des === \"undefined\")&#123; MYAPP.obj.des = \"对象的描述信息\"&#125;console.log(MYAPP.obj); 代码说明：我们在添加属性或者是方法的时候,比较安全的做法是在添加之前先在当前环境中进行检查,以免覆盖但是我们的检查操作催生出了一个新的问题,就是重复代码过多,能否考虑把检查的过程抽取 示例代码1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; var MYAPP = MYAPP || &#123;&#125;; MYAPP.namescape = function (string) &#123; //split() 方法用于把一个字符串分割成字符串数组 var parts = string.split('.'); var parent = MYAPP; console.log(parts); //先去掉最前面的冗余的全局变量 if(parts[0] == \"MYAPP\") &#123; //splice() 方法向/从数组中添加/删除项目,然后返回被删除的项目 //parts.splice(0,1); //slice() 方法可从已有的数组中返回选定的元素 //返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素 parts = parts.slice(1); &#125; console.log(parts,\"处理之后的数组\"); //通过for循环来遍历结构 for (var i = 0; i &lt; parts.length; i++) &#123; //检查属性,如果对应的属性不存在,那么就创建一个属性 if (typeof parent[parts[i]] == 'undefined') &#123; //初始化为一个空的对象 parent[parts[i]] = &#123;&#125;; &#125; //修正parent的值 parent = parent[parts[i]]; &#125; return parent; &#125; //代码示例 var testDemo01 = MYAPP.namescape(\"MYAPP.test.testDemo01\"); var testDemo02 = MYAPP.namescape(\"MYAPP.test.testDemo02\"); console.log(MYAPP); //忽略全面的前缀 MYAPP.namescape(\"sadsa.sadjaldj.adada.test\"); console.log(MYAPP); //演示长命名空间的情况 MYAPP.namescape(\"demo.testDemo.testDemos.ss.dd.qq.ddd.ffff.fff\"); console.log(MYAPP);&lt;/script&gt; 补充说明12301 split() 方法用于把一个字符串分割成字符串数组02 splice() 方法向/从数组中添加/删除项目,然后返回被删除的项目03 slice() 方法可从已有的数组中返回选定的元素 设计模式简单说明概念:设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案 注意,设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案 起源:该属于源于建筑行业 历史: （1）由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学 （2）四人帮著作《设计模式：可复用面向对象软件的基础》（Design Patterns - Elements of Reusable Object-Oriented Software） （3）Gang of Four:Erich Gamma + Richard Helm + Ralph Johnson +John Vlissides 优点: 为了可重用代码、让代码更容易被他人理解、保证代码可靠性 设计模式的分类创建型模式:工厂方法模式 + 抽象工厂模式 + 单例模式 + 建造者模式 + 原型模式 结构型模式:适配器模式 + 代理模式 + ... 行为型模式:观察者模式 + 命令模式 + ... 单例模式的思想保证一个特定的类只有一个实例。 即当我们第二次创建新对象的时候,得到的应该是和第一次创建的对象一模一样的对象(同一个对象) 其他语言中实现单例模式 在其它有Class的语言中,实现单例模式核心步骤是: 01 在创建对象实例时候判断,该类的实例对象是否已经存在,如果已经存在,那么就直接返回 02 如果不存在,那么就创建一个新的实例对象,并保存起来,下次创建实例对象的时候直接使用。 JavaScript中的单例模式JavaScript是一门弱类型,动态,基于原型的语言,并没有类,只有对象。 在JavaScript中要实现单例模式有很多种方式。 最简单的方式:使用字面量的方式来创建对象,因为在JavaScript中对象之间永远不可能相等,除非他们是同一个对象。 使用字面量方式创建的对象总是唯一的12345script&gt; var obj1 = &#123;name:\"zhangsan\"&#125;; var obj2 = &#123;name:\"zhangsan\"&#125;; console.log(obj1 == obj2); //false&lt;/script&gt; 使用new操作符创建对象实现单例 实现单例模式的几种途径 ① 在代码中提供一个全局变量来存储创建出来的实例 缺点:该全局变量可能会被轻易的修改和覆盖 ② 尝试在构造函数的静态成员中缓存实例属性。缺点:函数的静态属性在外部可以直接修改,容易导致实例对象的丢失。 ③ 将实例对象包装在闭包中。优点是安全性较好,无法被轻易的修改,缺点是有额外闭包的开销。 代码示例1234567function China() &#123;&#125;//创建对象var china01 = new China();var china02 = new China();//思考:如果想要实现单例模式,那么最终的结果必要是china01 和china02是同一个对象,那么如何实现 实现方案(一)使用全局变量方式存储创建出来的实例对象代码示例12345678910111213141516171819202122232425262728&lt;script&gt; //01 提供一个全局变量 var instance; //02 提供一个构造函数 function Person() &#123; if (instance == undefined) &#123; instance = this; &#125; this.name = \"默认的名称\"; this.age = 66; //使用全局变量来接收内部创建出来的实例对象(this) return instance; &#125; //03 使用构造函数创建对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2); console.log(p1.name); console.log(p2.name); p1.name = \"修改之后的名称\"; console.log(p1.name); console.log(p2.name); //说明:在上面的方案中我们使用一个全局变量来接收实例对象的值,在构造函数内部也是通过判断这个全局变量来做一些其他的处理 instance = &#123;&#125;; var p3 = new Person(); console.log(p1 == p3);&lt;/script&gt; 说明：这种方法确实可以实现单例模式,但是并不安全,因为全局变量可能会被轻易的修改或者是覆盖,因此不推荐这种方式。 实现方案(二)通过构造函数静态属性来缓存实例对象123456789101112131415161718192021222324252627&lt;script&gt; //01 提供一个构造函数 function Person() &#123; //02 在内部判断构造函数的静态属性中是否拥有实例对象 //如果拥有实例对象,那么就直接返回,否则就设置实例对象,并赋值给构造函数的静态属性 if (typeof Person.instance == \"object\") &#123; return Person.instance; &#125; //设置实例对象的属性和方法 this.name = \"默认的名称\"; this.age = 66; //03 把内部创建的实例化对象赋值给构造函数的静态属性 Person.instance = this; //显示返回 //return Person.instance; //隐式返回 //return this; &#125; //04 创建实例对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2); Person.instance = &#123;&#125;; var p3 = new Person(); console.log(p1 == p3); //false&lt;/script&gt; 说明：在构造函数外部可以直接访问其静态成员(属性和方法),可能会导致实例对象的丢失。 实现方案(二)通过闭包-惰性函数定义来实现12345678910111213141516171819202122&lt;script&gt; //01 提供一个构造函数 function Person() &#123; //02 在函数内部使用私有变量来缓存实例 var instance = this; //03 设置实例对象的属性和方法 this.name = \"默认的姓名\"; this.age = 66; //04 使用惰性函数定义来更新构造函数的实现 //通过一个闭包来返回缓存的实例对象 Person = function () &#123; return instance; &#125; &#125; //05 创建对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2); //代码说明:第一次调用原始构造函数的时候,它会像往常一样返回this(指向内部新创建的实例对象) //再后面调用的时候,它会执行更新后的构造函数,在这个新的函数实现中,我们通过闭包来访问了私有变量,并简单的返回。 //这个instance私有变量存储的是第一次调用构造函数时创建出来的实例对象&lt;/script&gt; 新的问题01 因为内部使用惰性函数定义(重写构造函数会导致之前添加在构造函数中的属性丢失),所以存在属性丢失问题02 在上面的代码中,体现在于创建对象前后设置的构造函数的原型对象丢失问题 代码示例123456789101112131415161718192021222324252627&lt;script&gt; function Person() &#123; var instance = this; this.name = \"默认的姓名\"; this.age = 66; Person = function () &#123; return instance; &#125; &#125; //设置构造函数的原型对象 Person.prototype.des = \"描述信息\"; var p1 = new Person(); //在创建第一个对象之后,设置原型对象 Person.prototype.someThing = \"something\"; var p2 = new Person(); console.log(p1 == p2); console.log(p1.des); //描述信息 console.log(p2.des); //描述信息 console.log(p1.someThing); //undefined console.log(p2.someThing); //undefined //打印对象的构造函数 console.log(p1.constructor.name); //Person console.log(p2.constructor.name); //Person //判断对象的构造函数 console.log(p1.constructor == Person); //false console.log(p1.constructor == p2.constructor,\"构造函数是否一致\");&lt;/script&gt; 解决问题的核心过程1234567891001 提供一个构造函数02 在构造函数内部提供一个私有变量instance03 重写构造函数,返回私有变量instance04 把原有的原型对象赋值给新Person构造函数的原型对象05 调用new 构造函数方法创建一个实例化对象赋值给instance06 修正instance实例的构造器属性,指向新的构造函数(注意:虽然重写了构造函数,但是instance的构造函数仍然是以前的Person)07 设置实例属性和方法08 返回instance对象代码示例 12345678910111213141516171819202122232425262728293031323334353637383940&lt;script&gt; function Person() &#123; //01 提供一个私有变量 var instance; //02 重写构造函数 Person = function () &#123; console.log(instance); //console.log(instance.constructor); var t = this; console.log(t); return instance; &#125;; //03 保留原型属性 Person.prototype = this.__proto__; //这是一个空的对象 Person.lal = \"lala\"; //04 创建并使用私有变量来接收实例对象 instance = new Person(); //05 修正构造函数指针 instance.constructor = Person; //06 设置实例属性和方法 instance.name = \"默认的名字\"; instance.age = 66; //07 返回私有变量 return instance; &#125; Person.haha = \"哈哈\"; //设置构造函数的原型对象 Person.prototype.des = \"描述信息\"; var p1 = new Person(); //在创建第一个对象之后,设置原型对象 Person.prototype.someThing = \"something\"; var p2 = new Person(); console.log(p1 == p2); console.log(p1.des); //描述信息 console.log(p2.des); //描述信息 console.log(p1.someThing); //something console.log(p2.someThing); //something //打印构造器属性 console.log(p1.constructor == Person,\"验证构造器指向\");&lt;/script&gt; 全局变量方式实现单例-改进版1234567891011121314151617181920&lt;script&gt; var Person; (function () &#123; //01 提供一个局部变量instance var instance; Person = function Person() &#123; if (instance) &#123; return instance; &#125; instance = this; this.name = \"默认的名字\"; this.age = 66; &#125; &#125;)(); //创建对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2);&lt;/script&gt; 说明：通过即时函数来限定作用域,外部无法修改内部instance的值(现在是一个局部变量) 工厂模式简单说明工厂模式的目的是用于创建对象,通常在类或者是类的静态方法中实现。 工厂模式的目标 01 用一套方法去创建相似的目标。 02 在编译时不知道具体类型的情况下,为用户提供创建对象的接口 工厂模式实现过程 01 提供一个父构造函数 02 在父构造函数的原型上添加共享的方法 03 在父构造函数身上提供一个静态方法(静态工厂方法) 001 先获取参数(产品类型) 002 判断构造函数是否存在(容错性处理) 003 设置原型链继承:设置子构造函数的原型对象为父构造函数的一个实例对象(目的是为了让子构造函数创建的对象拥有父构造函数上面实例属性和原型属性) 004 使用子构造函数创建实例对象 005 返回新创建的实例对象 04 定义特定的工厂客户(静态方法) 05 通过父构造函数的静态工厂方法来创建产品对象 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; //01 提供一个父构造函数 function PhoneMaker() &#123;&#125;; //02 在父构造函数的原型上添加共享的方法 PhoneMaker.prototype.callPhoneDes = function () &#123; console.log(\"手机的特点是: \" + this.des); &#125; //03 在父构造函数身上提供一个静态方法(静态工厂方法) PhoneMaker.factory = function (type) &#123; //001 先获取参数(产品类型) var typeStr = type; //002 判断构造函数是否存在(容错性处理) if (typeof PhoneMaker[typeStr] !== 'function') &#123; throw \"Error 对应的构造函数不存在,不能生产该种类型的产品\"; &#125; //003 设置原型链继承 PhoneMaker[typeStr].prototype = new PhoneMaker(); //004 使用子构造函数创建实例对象 var newPhone = new PhoneMaker[typeStr](); //005 返回新创建的实例对象 return newPhone; &#125;; //定义特定的工厂客户(静态方法) PhoneMaker.iphone = function () &#123; this.des = \"最安全稳定的系统\"; &#125; PhoneMaker.oppo = function () &#123; this.des = \"充当五分钟,通话两小时\"; &#125; PhoneMaker.vivo = function () &#123; this.des = \"vivo手机,你的音乐手机\"; &#125; //通过父构造函数的静态工厂方法来创建产品对象 var vivo = PhoneMaker.factory('vivo'); var iphone = PhoneMaker.factory('iphone'); var oppo = PhoneMaker.factory('oppo'); vivo.callPhoneDes(); oppo.callPhoneDes(); iphone.callPhoneDes();&lt;/script&gt; 观察者模式观察者模式观察者模式又名为发布-订阅者模式，它定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。 观察者模式的特点（优点）12301 观察者模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案02 观察者模式可以取代对象之间硬性编码的通知机制，一个对象不再是显示的调用另外一个对象的接口，这种模式让两个对象松耦合的联系在一起，它们不需要清楚彼此的实现细节就能够相互通信。03 在这种设计模式中，不再是一个对象调用另外一个对象的方法，而是一个对象订阅另一个对象的特定活动并且在状态改变后获得通知 模型01 订阅者也称为观察者02 被观察的对象称为发布者或者是主题03 当发生一个重要事件的时候，发布者将会通知所有订阅者并且经常以事件的形式来传递消息。示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//01 提取成公共的发行者对象 var publisher = &#123; users:&#123; default:[] &#125;, //所有的订阅者对象 addUser:function (fn,type) &#123; //对订阅的类型进行判断 var type = type || \"default\"; //如果是新的订阅类型,那么我们需要做初始化的处理 if (this.users[type] == undefined) &#123; this.users[type] = []; &#125; this.users[type].push(fn); &#125;, removeUser:function (fn,type) &#123; this.tool(type,\"removerUser\",fn); &#125;, publish:function (type) &#123; this.tool(type,\"publish\"); &#125;, tool:function (type,funcType,fn) &#123; var type = type || \"default\"; var users = this.users[type]; if (users == undefined) &#123; console.log(\"当前没有任何订阅者\"); return; &#125; for (var i = 0; i &lt; users.length; i++) &#123; if (funcType == 'publish') &#123; users[i]() &#125;else &#123; if (users[i] == fn) &#123; users.splice(i, 1); break; &#125; &#125; &#125; &#125; &#125;; //02 提供一个工具函数,能够利用发行者对象的模板来快速创建新的发布者 function makePaper(o) &#123; for(var i in publisher) &#123; if (publisher.hasOwnProperty(i) &amp;&amp; typeof publisher[i] == 'function') &#123; o[i] = publisher[i]; &#125; &#125; o.users = &#123;default:[]&#125;; &#125; //03 创建发布者 var paper1 = &#123; day:function () &#123; this.publish(); &#125;, month:function () &#123; this.publish(\"month\") &#125;, year:function () &#123; this.publish(\"year\") &#125; &#125;; //把某个对象编程一个发布者 makePaper(paper1); //04 创建订阅者(当发布者发布消息的时候,订阅者能够收到信息--自动调用订阅者的方法) var obj = &#123; lookDayNews:function () &#123; console.log(\"obj - 查看最新的日报信息\"); &#125;, lookImageNews:function () &#123; console.log(\"obj - 查看图片信息\"); &#125; &#125;; //05 设置订阅 paper1.addUser(obj.lookDayNews); paper1.addUser(obj.lookImageNews,'month'); paper1.day(); paper1.month();&lt;/script&gt;","categories":[{"name":"JavaScript简明教程","slug":"JavaScript简明教程","permalink":"http://www.1oveit.club/categories/JavaScript简明教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.1oveit.club/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"}]},{"title":"JavaScript简明教程（6）","slug":"js-06","date":"2016-04-25T03:19:14.000Z","updated":"2017-05-13T10:45:13.000Z","comments":true,"path":"2016/04/25/js-06/","link":"","permalink":"http://www.1oveit.club/2016/04/25/js-06/","excerpt":"闭包是学习JavaScript的难点之一，因JavaScript是单线程，故回调使用频繁，本章节主要讲了闭包以及回调。 闭包闭包简单说明 闭:关闭,封闭 包:包住,包裹 闭包:通过某种方式实现的一个封闭的、包裹的对外不公开的结构|空间 闭包的原理:变量的访问原则(即上一级的作用域无法访问下一级的作用域),其实函数本身就是闭包。","text":"闭包是学习JavaScript的难点之一，因JavaScript是单线程，故回调使用频繁，本章节主要讲了闭包以及回调。 闭包闭包简单说明 闭:关闭,封闭 包:包住,包裹 闭包:通过某种方式实现的一个封闭的、包裹的对外不公开的结构|空间 闭包的原理:变量的访问原则(即上一级的作用域无法访问下一级的作用域),其实函数本身就是闭包。 闭包要解决的问题 提供一种间接的方式能够访问到函数内部的数据（变量） 实现思路 01 我们需要能够在函数外部访问函数内部的变量，正常情况无法访问； 02 在函数内部如果新创建函数，那么安装作用域链的原则，这个新创建的内部函数能够访问到函数中的这些变量。 03 我们如果能够操作函数中新创建的函数，那么就能够操作函数中的变量（如访问和设置等） 04 如果要能够操作函数中新创建的函数，那么需要在函数中把新创建的函数返回。 05 调用函数，接收并得到其返回值（是一个函数） 06 调用返回值（函数），通过函数传参的方式来设置函数中的变量。 07 调用返回值（函数），通过在函数内部再次return的方式来访问函数中的变量。 闭包的基本模式 在函数内部创建函数(内部函数),在这个内部函数中,可以操作外部函数中的变量 01 在函数(外部)中创建函数(内部函数),在该函数(内部函数)中操作外部函数中的变量 02 在外部函数中,把内部函数作为返回值返回 03 调用外部函数,并接收其返回值(是一个函数) 04 调用接收到的返回值(内部函数),来间接的操作外部函数中的变量 代码示例123456789function func() &#123; var num = 10; return function (n) &#123; num = n; console.log(num); &#125;&#125;var funcName = func();funcName(\"哗啦哗啦\"); 闭包获取数据获取单个数据（考虑赋值）123456789101112131415function func() &#123; var num = 123; return function (a) &#123; if (a !== undefined) &#123; num = a; &#125; return num; &#125;&#125;var f1 = func();var x = f1(456);var y = f1();console.log(x);console.log(y); 说明：上面的代码能够支持通过闭包对函数中的变量num进行访问（取值）或赋值的操作。 获取多个数据（数组）123456789101112131415function func() &#123; var name = \"张学友\"; var age = 40; return [ function getName() &#123; return name; &#125;, function getAge() &#123; return age; &#125; ]&#125;var foo = func();console.log(foo[0]()); //张学友console.log(foo[1]()); //40 说明：上面的代码能够满足返回多个变量值的需求，但是要数组操作的方式并不常见，且和使用习惯不符合。 利用对象返回并设置对个变量值1234567891011121314151617181920212223242526function foo() &#123; var name = \"张学友\"; var age = 45; return &#123; getName:function () &#123; return name; &#125;, getAge:function () &#123; return age; &#125;, setName:function (nameValue) &#123; name = nameValue; &#125;, setAge:function (ageValue) &#123; age = ageValue; &#125; &#125;&#125;var func = foo();console.log(func.getName()); //张学友console.log(func.getAge()); //45func.setName(\"张三\");func.setAge(30);console.log(func.getName()); //张三console.log(func.getAge()); //30 闭包的作用最基本的作用:闭包中的变量更安全,只能通过特定的接口来访问说明:12(1)创建一个私有的空间,保护数据,外界如果需要访问数据必须通过函数提供的指定方法(2)在这些指定的方法中,我们可以设置一些校验的逻辑,以保证对数据访问和设置的安全性 闭包的使用注意进程和线程 进程指的是系统中正在运行的一个应用程序。 线程:一个进程中可以有一个或多个线程,线程是CPU调度的最小单位,是真正执行任务的。 多线程:一个中可能有多条线程,多条线程之间并发的执行多个不同的任务。 单线程:一个进程中只有一条线程,即同一时间只能执行一个操作,只能干一件事情。 javascript是单线程的 js中的线程主要处理三块任务: 01 渲染任务 02 js的代码执行任务 03 js中的事件处理任务(如setTimeOut方法) javascript中代码的执行顺序 01 先把主任务执行完毕(代码任务)02 主任务执行完毕之后再执行次要的任务(包括setTimeOut方法等) 关于setTimeOut函数 函数的作用:一次性定时器(用于延迟执行任务) 参数: 第一个参数:要执行的任务 第二个参数:要延迟执行的时间,时间的单位是毫秒 函数说明： 01 至少在指定的时间后才能够执行回调函数 02 因为要等主任务中的代码执行完毕之后,才回去检查setTimeOut的回调函数。 通过闭包解决setTimeOut函数的问题12345678910111213&lt;script&gt; for (var i = 0; i &lt; 10; i++) &#123; setTimeout((function (j) &#123; return function () &#123; console.log(j); &#125; &#125;)(i),10); console.log(\"----\"); &#125;&lt;/script&gt; 函数的特殊之处函数的特殊之处在于,它本身是对象,且函数可以提供作用域。 (01) 函数可以在运行时动态的创建,还可以在程序执行过程中创建。 (02) 函数可以赋值给变量,可以被扩展,甚至是删除。 (03) 函数可以作为其他函数的参数和返回值。 (04) 函数可以拥有自己的属性和方法。 注意:{} 块在js中不会创建作用域,哪怕是if或者是while语句中使用var关键字声明的变量也并非局部变量。 函数是可以通过（）调用并执行的对象。 函数是第一型对象12301 函数可以像普通对象一样作为函数的参数02 函数可以像普通对象一样赋值给变量（函数表达式）03 函数可以像普通对象一个作为函数的返回值返回 代码示例123456789101112131415//函数作为参数传递 setTimeout(function () &#123; console.log(1); &#125;,100); //函数作为返回值 function func() &#123; return function () &#123; console.log(\"demo\"); &#125; &#125; var f = func(); f(); //demo //函数赋值给变量 var a = function()&#123;&#125; a(); //直接通过变量的名称调用函数 函数的两个特征1201 函数本质上是对象02 函数可以创建作用域 约定1234var add = function add(a,b)&#123;return a + b;&#125;; //命名函数表达式var add = function (a,b)&#123;return a + b;&#125;; //函数表达式,匿名函数 以上也称为使用字面量的方式来创建函数(或者是函数字面量)function add()&#123;&#125;; //函数声明 代码示例123456789101112131415&lt;script&gt; //01 函数声明 function demo01() &#123; &#125; //02 函数表达式(匿名函数) var demo02 = function () &#123; &#125;; //03 命名函数表达式 var demo03 = function demo03Test() &#123; &#125;; //04 打印name属性 console.log(demo01.name); //demo01 console.log(demo02.name); //demo02 (注意在火狐浏览器中打印出来的name属性为空) console.log(demo03.name); //demo03Test&lt;/script&gt; 函数回调回调函数(回调),当我们把某个函数作为参数传递给另一个函数的时候,这个函数就称为回调函数 函数回调的基本模式12345678910&lt;script&gt; function func(callBack) &#123; //处理其他的操作 callBack(); //调用回调函数 &#125; function demo() &#123; console.log(\"这是一个回调函数\"); &#125; func(demo); //注意调用函数的时候,参数是回调函数的引用(不要加括号);&lt;/script&gt; 函数回调解决this问题说明：如果回调函数是某个对象的方法,而该对象方法中使用了this指针那么该方法作为回调函数来使用的时候,需要注意this123456789101112131415161718192021222324252627//01 提供一个对象,该对象中永远showName方法var obj = &#123; name:\"默认的名字\", age:30, showName:function () &#123; console.log(this.name); &#125;, showAge:function () &#123; console.log(this.age); &#125;&#125;;//02 提供一个函数,该函数接受一个参数(函数引用)function demo(callBack,callBack_obj) &#123; //处理第一个参数传递对象方法字符串的形式 if(typeof callBack == 'string') &#123; callBack = callBack_obj[callBack]; &#125; if (typeof callBack == 'function') &#123; callBack.call(callBack_obj); &#125;&#125;//demo(obj.showName,obj);//demo(obj.showAge,obj);//传递字符串和对象来进行调用demo(\"showName\",obj); 代码说明：123（01）以上代码传入两个参数，分别为具体的回调函数，和该回调函数所属的对象（02）该函数的参数接受两种方式的回调传递（一种是直接传递函数引用，一种是直接以字符串的方式传递对象方法的字符串）（03）在函数内部对传入的回调参数做处理，修正this的问题 函数作为函数的返回值12① 使用闭包实现一个计数器(在该示例中setup函数的返回值为一个函数)② 通过调用返回值(一个函数),可以操作setup函数中的变量 123456789101112&lt;script&gt; var setup = function () &#123; var count = 0; return function () &#123; return count ++; &#125; &#125; var next = setup(); console.log(next()); //0 console.log(next()); //1 console.log(next()); //2&lt;/script&gt; 惰性函数定义说明：某个函数直到第一次使用的时候才被正确的定义,并且其具有向后惰性,执行更少的工作。应用场景:函数有一些初始化的准备工作要做,且只需要执行一次的情况。特点:能够更新自己(函数)的实现。缺点: 01 当重新定义自身的时候,已经添加到原始函数的任何属性都会丢失。 02 如何函数被赋值给了其他的变量或者是对象方法,那么在使用变量或者是对象方法调用时仍然会执行旧的函数体。代码示例123456789function foo() &#123; console.log(\"foo!\"); foo = function () &#123; console.log(\"new foo!\"); &#125;&#125;//函数的调用//foo(); //foo!//foo(); //new foo! 问题： ① 添加属性 ② 把函数赋值给新的变量 ③ 以对象的方法调用函数 当惰性函数定义在处理以上三种情况的时候，使用新的变量名调用或者是是以对象的方法来调用函数，那么该函数在执行的时候并不会更新自身，而是执行旧的函数体的内容 代码示例1234567891011121314151617181920212223242526272829&lt;script&gt; //01 声明函数foo function foo() &#123; console.log(\"foo!\"); foo = function () &#123; console.log(\"foo! foo!\"); &#125; &#125; //02 为foo函数对象添加属性 foo.description = \"foo函数的描述信息\"; //03 把foo函数赋值给其他的变量 var func = foo; //04 把foo函数赋值给对象中的方法 var obj = &#123; showFoo:foo &#125; //05 验证并演示输出 func(); //foo! func(); //foo! console.log(func.description); //foo函数的描述信息 //总结:01 如果把函数赋值给其他的变量,那么在以其他变量的方式调用时不会更新自身,还是执行旧的函数体 obj.showFoo(); //foo! obj.showFoo(); //foo! console.log(obj.showFoo.description); //foo函数的描述信息 //总结:02 如果把函数赋值给对象的方法,那么在以对象方法形式调用时不会更新自身,还是会执行旧的函数体。 foo(); //已经更新过foo函数 foo! foo! foo(); //已经更新过foo函数 foo! foo! console.log(foo.description); //undefined&lt;/script&gt; 即时函数 定义:在函数定义之后立即执行该函数。即时函数模式的组成: ① 使用函数表达式来定义函数(匿名函数,注意不能使用函数声明方式) ② 在函数表达式末尾添加一组(),表示立即执行当前函数。 ③ 将整个函数包装在()中,有两种方式` 即时函数的作用 01 用来将所有的代码包装到当前的作用域中,并且不会将任何的变量泄露到全局作用域中。 02 js中没有代码块作用域,而函数是js中唯一可以创建作用域的。 03 即时函数就是利用了函数创建作用域这一点,来实现对一些需要封装且不允许外部访问的操作。 即时函数的优点01 不会产生全局变量,在即时函数内部定义的所有变量都仅仅只是该函数的局部变量,不会造成全局变量污染问题。02 具有更好的封装性,外部无法访问到该函数内部的数据。 即时函数代码示例12345678//第一种写法(function () &#123; console.log(\"即时函数的第一种写法\");&#125;());//第二种写法(function () &#123; console.log(\"即时函数的第二种写法\");&#125;)(); 写法补充123456789(function (a) &#123; console.log(a); &#125;(20)); +function (b) &#123; console.log(b); &#125;(30); -function (b) &#123; console.log(b); &#125;(40); 即时函数的传参和返回值12345678910//01 接受参数 (function (str) &#123; console.log(str); //hello &#125;)(\"hello\"); //02 提供返回值并赋值给新的变量 var foo = (function () &#123; return 2 + 1; &#125;)(); console.log(foo); //3 即时对象初始化01 结构特征:12345① 提供一个对象,在该对象内部提供一个init初始化方法② 使用()把对象包装起来(让字面量变成表达式)③ 然后随即调用init方法,完成初始化操作。 02 基本结构({}).init(); 03 模式优点 在执行一次性的初始化任务时保护全局的命名空间。 代码示例1234567891011121314&lt;script&gt; (&#123; name:\"张三\", age:23, getDescript:function () &#123; console.log(\"名字:\" + this.name + \"年龄:\" + this.age); &#125;, //注意:在对象中访问对象的属性和方法都需要使用this.前缀 init:function () &#123; this.getDescript(); //其他的初始化处理 &#125; &#125;).init();&lt;/script&gt; 函数属性缓存思路说明 01 函数是对象，因此可以在函数上面添加属性和方法 02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果 03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为value） 04 等需要获取参数对应指定结果的时候，考虑先去缓存中查找，如果有那么就直接使用，若没有则计算并保存一份到缓存中。 代码示例(单个参数)1234567891011121314var func = function (param) &#123; if (func.cache[param] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[param] = result + param; &#125; return func.cache[param];&#125;func.cache = &#123;&#125;; //空对象console.log(func(\"demo\")); //字符串democonsole.log(func(\"test\")); //字符串testconsole.log(func(\"demo\")); //字符串demo 直接使用属性缓存中的数据,而不再进行复杂的计算(可以提升性能) 代码示例（多个参数）12345678910111213var func = function () &#123; var key = JSON.stringify(Object.prototype.slice.call(arguments)); if (func.cache[key] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[key] = result + key; &#125; return func.cache[key];&#125;func.cache = &#123;&#125;; //空对象func(\"123\",\"456\"); ////说明:如果传入的参数数量超过1,则可以将传入的参数序列化为一个json字符串作为参数处理。 代码说明：slice:返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素","categories":[{"name":"JavaScript简明教程","slug":"JavaScript简明教程","permalink":"http://www.1oveit.club/categories/JavaScript简明教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.1oveit.club/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"}]},{"title":"JavaScript简明教程（5）","slug":"js-05","date":"2016-03-17T17:09:24.000Z","updated":"2017-05-13T10:45:13.000Z","comments":true,"path":"2016/03/18/js-05/","link":"","permalink":"http://www.1oveit.club/2016/03/18/js-05/","excerpt":"JavaScript中有严格模式和非严格模式两种运行环境,本章节主要讲严格模式及非严格模式下函数和变量的区别,最后简单讲诉了JavaScript作用域。 变量和函数私有变量和函数 定义在构造函数内部而被this对象的变量,在外部无法访问到的变量和函数","text":"JavaScript中有严格模式和非严格模式两种运行环境,本章节主要讲严格模式及非严格模式下函数和变量的区别,最后简单讲诉了JavaScript作用域。 变量和函数私有变量和函数 定义在构造函数内部而被this对象的变量,在外部无法访问到的变量和函数 公有变量和方法 对外暴露接口,可以通过构造函数对象创建的对象访问的属性和方法 代码示例1234567891011121314151617function Car(type,number) &#123; this.type = type; //公共的属性 this.number = number; var city = \"广州\"; //私有变量 var getNumber = function () &#123; //私有函数 return number; &#125;; var getType = function () &#123; return type; &#125;; //能够访问私有变量和函数的方法 --- 特权方法 this.getDescription = function () &#123; console.log(getNumber() + getType() + city); &#125; &#125; var car = new Car(\"汽车\",\"201718\"); car.getDescription(); 说明：能够访问构造函数内部私有变量|函数的方法称之为特权方法 构造函数的问题构造函数本身是一个函数，在调用的时候有多种调用方式。12① new 构造函数（）调用② 构造函数（）调用 以上，第二种调用方式存在作用域安全的问题 作用域安全的构造函数12345678910111213141516171819202122&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; //容错处理 if (this instanceof Person) &#123; //设置实例属性和方法 this.name = name; this.showName = function () &#123; console.log(this.name); &#125; &#125;else &#123; return new Person(name); &#125; &#125; //02 创建对象 var p1 = new Person(\"zhangsan\"); var p2 = new Person(\"lisi\"); p1.showName(); p2.showName();&lt;/script&gt; 新的问题说明:上面的代码在使用借用构造函数方式继承的时候存在问题，无法创建出的对象，原因在于通过call或者是apply函数调用的时候，内部的this绑定的子类型中的对象，因此在使用instanceOf 判断的时候，结果为假。解决：可以设置让子类型（构造函数）的原型对象为父类型的一个实例。代码示例123456789101112131415161718192021222324252627282930&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; //容错处理 if (this instanceof Person) &#123; //设置实例属性和方法 this.name = name; this.showName = function () &#123; console.log(this.name); &#125; &#125;else &#123; return new Person(name); &#125; &#125; //02 创建对象 var p1 = new Person(\"zhangsan\"); var p2 = new Person(\"lisi\"); p1.showName(); p2.showName(); // 使用借用构造函数来实现继承 function Boy(name)&#123; Person.call(this,name); &#125; //需要结合原型继承来解决 instanceOf 实例对象检测的问题 Boy.prototype = new Person(); var boy = new Boy(\"测试的名字\"); boy.showName();&lt;/script&gt; 严格模式关键字 “use strict”;实现严格模式:只需要在脚本代码中添加上上述关键字即可。 关键字具体说明12345(1) 注意区分大小写，必须全部都是小写的(2) 注意空格，整个字符串总共10个字符(3) 单引号和双引号无所谓，但是需要有双引号(4) 必须写在作用域的最顶部，注意其位置(5) 可以加分号，也可以不加，但是必须是一个字符串 注意：以下的关键字写法均是错误的123\"USE strict\";\" use strict \";\"(\"USE strict\").toLowerCase();\" 严格模式使用注意12345678910111 所有的变量必须使用var 关键字声明2 不能使用delete关键字删除全局变量 ,以前默认删除失败,严格模式下直接报错3 在对象中不允许有同名的属性4 函数的参数必须唯一(不能出现同名的参数)5 arguments对象的行为不同,在非严格模式下修改形参的值会反映到arguments中,而严格模式下则相对独立6 禁用了argument.callee和caller函数,他们一个引用函数本身,一个引用调用函数7 不能在if语句中声明函数8 禁止使用eval和arguments作为标识符9 修正this的值,在严格模式下,函数this的值始终是指定的值,无论指定的是什么值。10 禁用了with语句11 去掉了JavaScript中的八进制字面量(以0开头的八进制字面量是无效的语法) 1 所有的变量都必须使用var关键字声明12a = 10; //错误的演示console.log(10); ② 不能使用delete关键字删除全局变量1234//在非严格模式下,删除失败(静默失败) 失败了不吭声,严格模式下直接报错var a = 10;delete a;console.log(a); ③ 在对象中不允许有同名的属性1234567//在非严格模式下,会使用后面的属性赋值作为最终值,在严格模式下则直接报错var obj = &#123; name:\"张三\", name:\"李四\"&#125;console.log(obj); ④ 函数的参数必须唯一(不能出现同名的参数)123456789101112//在非严格模式下,如果函数在定义的时候,使用了多个同名的参数,则在函数内部形参的实际值为最后一个传入的实参值//在严格模式下,直接报错// function func(a,a,a) &#123;// console.log(a);// console.log(arguments);// &#125;function func(a,b,c) &#123; console.log(a); console.log(arguments);&#125;func(1,2,3); arguments对象的行为不同说明：（1）严格模式下,在函数内部修改了对象的指向,对arguments的值不会产生影响（2）在严格模式下,形参的值和arguments的值是相互独立的,在函数内部修改了形参的值对arguments不受影响（3）在非严格模式下，修改了形参的值，arguments中的数据会跟着改变123456789101112131415161718 //测试引用类型的值作为函数的参数function funcName(obj) &#123; console.log(obj); console.log(arguments[0]); //在函数内部修改形参的值 obj = &#123;age:20&#125;; console.log(obj); console.log(arguments[0]); &#125; funcName(&#123;name:\"张三\"&#125;); //测试基本类型数据作为函数的参数 function fun(str) &#123; console.log(str); console.log(arguments[0]); str = \"hello\"; console.log(arguments[0]); &#125; fun(\"hi\"); ⑥ 禁用了argument.callee和caller函数说明：argument.callee是对函数自身的引用argument.calller是对调用函数的引用12345678var num = (function (n) &#123; if (n ==1) &#123; return 1; &#125; return arguments.callee(n-1) + n; &#125;)(10); console.log(num); //55 ⑦ 不能在if语句中声明函数123456789//如果在if语句中声明函数，则会产生语法错误 if (true) &#123; console.log(\"________\"); function demo() &#123; console.log(\"呵呵呵呵\"); &#125; demo(); &#125; ⑧ 禁止使用eval和argument作为标识符1234var eval = \"测试的字符串\";console.log(eval);var arguments = \"参数列表\";console.log(arguments); ⑨ 修正this的值12345678在严格模式下,函数this的值始终是指定的值,无论指定的是什么值var name = \"测试的name\";function demoTest() &#123; //在非严格模式下,打印出来的this为全局的对象window console.log(this); //在严格模式下打印出来的this为undefined&#125;demoTest(); ⑩ 禁用了with语句1234567var o = &#123;name:\"暂时干\",age:20&#125;; with(o) &#123; name = \"lisi\"; age = 48 &#125; console.log(o); 禁用了八进制123//以0开头的数据常常引起混乱//var num = 023; //2*8 + 3 ==&gt; 19//console.log(num); //19 书写格式1234501 必须使用单引号或者是双引号括住字符串02 必须使用小写,不能出现大写字符03 必须是10个字符04 字符串后面的分号可以省略05 必须写在当前作用域的最顶上 代码示例123456789101112&lt;script&gt; //\"use strict\"; //正确写法 //\"use strict\" //正确写法 分号可以省略 //'use strict'; //正确写法 可以使用单引号 //\"use strict\"; //错误写法 必须是10个字符 //\"use Strict\"; //错误写法 所有的字符都必须小写 \"use strict\"; a = 10; // \"use strict\"; //错误写法 必须写在当前作用域的顶端 b = 20; console.log(a);&lt;/script&gt; 作用范围12① 函数的顶部(只对当前的函数有效)② script标签的顶部,只对当前的标签有效,对页面中其他的script无效 代码示例12345678910111213141516 //位置01 对func01和func02都有效 //\"use strict\"; function func01() &#123; //位置02 对func01有效,对func02无效 //\"use strict\"; a = 10; console.log(a); &#125; function func02() &#123; //位置03 对func02有效,但对func01无效 //\"use strict\"; b = 20; console.log(b); &#125;func01(); func02(); 函数的几种调用方式123401 普通函数调用 内部的this指向全局对象window02 构造函数调用 内部的this指向新创建的对象03 对象的方法调用 内部的this指向调用的对象本身04 通过call 或者是apply方式调用(函数上下文),this指向的是当前的上下文对象 this丢失demo演示123456789101112&lt;script&gt; var obj = &#123; name:\"张三\", getName:function () &#123; console.log(this.name); &#125; &#125;; //以对象的方法来进行调用 obj.getName(); //张三 var getName = obj.getName; getName(); //以普通函数的方式调用,此时内部的this指向的是window对象 打印的是window.name 为空值&lt;/script&gt; 代码示例0212345678910111213141516&lt;script&gt; //01 获取页面中id值为demo的标签 //var div = document.getElementById('demo');// var getId = document.getElementById;// var div = getId('demo'); //会报错?// console.log(div); //借用apply来修正this document.getElementById = (function (func) &#123; return function () &#123; return func.apply(document,arguments); &#125; &#125;)(document.getElementById); var getId = document.getElementById; var div = getId('demo'); //会报错? console.log(div);&lt;/script&gt; 代码说明：12301 因为document.getElementById方法的内部实现中需要使用到this,这个this本来期望指向的是document对象02 当我们以document.getElementById来调用的时候,内部的this指向document对象03 但是当我们以getId的方式调用的时候,内部的this指向的是window对象(因为我们以普通的方式进行调用) 作用域变量其作用的范围就是它的作用域 块级作用域说明：JavaScript中没有块级作用域123456for (var i = 0; i &lt; 10; i++) &#123; var num = i; &#125; console.log(i); console.log(num); //说明:如果有块级作用域,则i和num打印的结果应该为undefined 词法作用域123词法作用域:在代码写好的那一刻,变量的作用域就已经确定的动态作用域:变量的作用域由执行时的环境所决定说明:在js中不是动态作用域,当调用的时候,是往上查找的,不会到其他函数的作用域中去查找 在JavaScript中唯一能够产生作用域的东西是函数代码演示123456789101112131415161718192021222324&lt;script&gt; var a = \"这是第一个a\"; function func01() &#123; console.log(a); //先在当前作用域中查找,如果没有则访问全局的作用域 &#125; function func02() &#123; var a = \"这是第二个a\"; func01() &#125; func01(); //打印结果为:这是第一个a func02(); //打印结果为:这是第一个a&lt;/script&gt;&lt;script&gt; var a = \"这是第一个a\"; function func02() &#123; var a = \"这是第二个a\"; func01() &#125; function func01() &#123; console.log(a); //先在当前作用域中查找,如果没有则访问全局的作用域 &#125; func01(); //打印结果为:这是第一个a func02(); //打印结果为:这是第一个a&lt;/script&gt; 词法作用域的规则1234① 在函数内部允许访问外部的变量② 只有函数可以限定作用域③ 作用域规则首先使用提升规则分析④ 如果当前作用域中有该变量,则不考虑外部作用域的同名变量 变量和函数提升JS中的代码执行分为两个步骤① 预解析JavaScript在预解析阶段,会对使用var关键字声明的变量和function声明的代码块进行提升操作,提升到当前作用域的顶端② 执行 代码提升的几种情况 01 函数提升123456&lt;script&gt; func(); function func() &#123; console.log(\"测试的函数\"); &#125;&lt;/script&gt; 02 变量提升1234567&lt;script&gt; console.log(a); //打印出来的结果为undefined var a = 10; //var a; //注意:只会对变量的声明进行提升 //console.log(a); //a = 10&lt;/script&gt; 03 函数同名情况提升12345678910111213141516171819&lt;script&gt; func01(); //打印last function func01() &#123; console.log(\"first\"); &#125; func01(); //打印last function func01() &#123; console.log(\"last\"); &#125; //模拟提升后的情况 function func01() &#123; console.log(\"first\"); &#125; function func01() &#123; console.log(\"last\"); &#125; func01(); func01();&lt;/script&gt; 说明：预处理的时候，同名的函数都会进行提升，但是后面的会覆盖掉前面的 04 变量名和函数同名的情况12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; console.log(a); //打印function function a() &#123; console.log(\"我是一个函数\"); &#125; var a = 20; console.log(a); //打印20 //变量和函数提升后的结果 错误// function a() &#123;// console.log(\"我是一个函数\");// &#125;// var a ;// console.log(a);// a = 20;// console.log(a); //变量和函数提升后的结果 正确 function a() &#123; console.log(\"我是一个函数\"); &#125; console.log(a); var a = 20; console.log(a);&lt;/script&gt;```js总结:如果出现变量和函数同名的情况,则在进行提升的时候,只会提升函数到当前作用域顶端而忽略变量的提升操作**变量的提升是分作用域的**示例代码01```js&lt;script&gt; console.log(a); //undefined var a = 10; //模拟提升 var a; console.log(a); //undefined a = 10;&lt;/script&gt; 示例代码0212345678910111213141516171819&lt;script&gt; var num = 10; function func() &#123; var num = 20; console.log(num); &#125; console.log(num); //10 func(); //20 //模拟提升 var num; function func() &#123; var num; num = 20; console.log(num); &#125; num = 10; console.log(num); //10 func(); //20&lt;/script&gt; 示例代码031234567891011121314151617var num = 10;function func() &#123; console.log(num); var num = 20;&#125;console.log(num); //10func(); //undefiend//模拟提升var num;function func() &#123; var num; console.log(num); num = 20;&#125;num = 10;console.log(num); //10func(); //undefiend 示例代码041234567891011121314151617var num = 10;function func() &#123; console.log(num); num = 20;&#125;console.log(num); //10func(); //10//模拟变量提升var num;function func() &#123; console.log(num); num = 20;&#125;num= 10;console.log(num); //10func(); //10console.log(num); //20 函数表达式的提升说明：在使用函数表达式方式创建函数的时候,整个函数表达式并不会进行提升,只会对var声明的变量提升1234567891011func();var func = function () &#123; console.log(\"会不会被调用\");&#125;//以上如上代码将报错//模拟提升的过程var func;func(); //找不到这个函数func = function () &#123; console.log(\"会不会被调用\");&#125; 作用域链01 在js中函数可以创建作用域 02 函数中又可以创建函数(即又可以开辟新的作用域) 03 函数内部的作用域可以访问外部的作用域 04 如果有多个函数嵌套,那么就会构成一个链式的访问结构,也就是作用域链 05 注意:函数内部的作用域可以访问外部的作用域,但是外部的作用域却不能访问内部的作用域 代码示例1234567891011121314151617&lt;script&gt; function f1() &#123; //f1---&gt;全局作用域 function f4() &#123; //f4--&gt;f1---&gt;全局作用域 function f5() &#123; &#125; &#125; &#125; function f2() &#123; //f2--&gt;全局作用域 function f6() &#123; &#125; &#125; function f3() &#123; &#125;&lt;/script&gt; 作用域链绘图说明 ① 先画出全局作用域线条，然后在上面添加全局作用域中的函数和变量，作为0级作用域链 ② 画出全局作用域中的函数的作用域线条，，然后在上面添加当前作用域中的函数和变量，作为1级作用域链 ③ 以此类推，直至完成 示例代码01123456789function f1() &#123; function f2() &#123; &#125; &#125; var a = 20; function f3() &#123; function f4() &#123; &#125; &#125; 图示 示例代码021234567891011121314function f1() &#123; function f2() &#123; function f5() &#123; var b = \"demo\"; &#125; &#125; &#125; var a = 20; function f3() &#123; var c = \"啊哈哈\"; function f4() &#123; var d = \"test\"; &#125; &#125; 图示 作用域注意点和变量搜索原则注意点 01 在获取值和设置值的时候都是访问变量 02 并非在函数内部写了变量,这个变量就属于当前函数,而是必须使用var 关键字声明的变量才属于当前函数 03 函数在声明的时候,里面的代码并不会执行,只有在函数调用的时候才会执行 04 声明函数时候的函数名,其实也是一个变量名,可以通过这个变量名来进行设置和赋值 05 注意:在变量内部使用var 关键字声明一个变量并不会把同名的全局变量覆盖掉 1234567var a = 10;function f1() &#123; var a = 20; //注意:该行代码并不会覆盖掉全局变量中的变量a console.log(a);&#125;f1(); //20console.log(a); //10 代码点评：12在函数中使用var关键字声明变量a并不会覆盖全局作用域中的a。注意需要同时考虑变量在当前作用域的提升以及访问变量时的搜索原则。 1234567function f1() &#123; console.log(1);&#125;var f1 = \"demo字符串\"; //该行代码会把f1函数覆盖掉f1 = \"demoTest字符串\";console.log(f1);//f1(); 代码点评:函数的名称也是变量，如果在代码中出现同名的变量，那么函数的实现会被覆盖掉 变量搜索原则 01 在使用变量的时候,首先在自己的作用域中查找 02 如果找到了就直接使用,如果没有找到,那么就到上一级作用域中去查找 03 重复上面的步骤,直到0级作用域,如果还是找不到那么就返回undefined(报错)","categories":[{"name":"JavaScript简明教程","slug":"JavaScript简明教程","permalink":"http://www.1oveit.club/categories/JavaScript简明教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.1oveit.club/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"}]},{"title":"JavaScript简明教程（4）","slug":"js-04","date":"2016-03-05T05:26:28.000Z","updated":"2017-05-13T10:45:13.000Z","comments":true,"path":"2016/03/05/js-04/","link":"","permalink":"http://www.1oveit.club/2016/03/05/js-04/","excerpt":"本章节主要讲解了原型链及相关方法。 原型链及相关属性方法简单说明原型链代码示例","text":"本章节主要讲解了原型链及相关方法。 原型链及相关属性方法简单说明原型链代码示例1234567891011121314151617&lt;script&gt; //01 提供Person构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置Person的原型对象 Person.prototype.showName = function () &#123; console.log(this.name); &#125; //03 创建Student构造函数 function Student(number) &#123; this.numer = number &#125; //04 设置Student的原型对象 Student.prototype = new Person();&lt;/script&gt; 原型链图示例 Object对象Object构造函数01 使用Object构造函数创建字符串对象12345678//01 创建字符串对象var str1 = new String(\"测试字符串\");var str2 = new Object(\"测试字符串\");var str3 = str1;//注意:对象比较相等(需要引用[地址]相等)console.log(str1 == str2); //falseconsole.log(str1 === str2); //falseconsole.log(str1 === str3); //true 02 使用Object构造函数创建数字对象12var num = new Object(10);console.log(typeof num); //object 03 使用Object构造函数创建布尔类型对象12var bool = new Object(true); console.log(typeof bool); //object js中所有的内置或自定义对象都继承自Object对象,几乎所有的对象都可以使用Object.prototype上面的属性和方法 Object.prototype01 因为js中所有的对象都继承自Obejct,都可以使用Object对象的原型属性和方法,因此不要轻易的扩展Object.prototype。02 Object.property中的属性和方法 ① constructor 指向原型相关联的构造函数，为Object ② hasOwnProperty 判断对象中是否拥有某个实例属性(不包括原型链上面的属性) ③ isPrototypeOf 校验某个对象是否是指定对象的原型对象(整条原型链) ④ propertyIsEnumerable 属性是否存在且可枚举(使用for循环可以遍历,即目标属性能否在for循环中显示出来) ⑤ toString() 返回一个描述目标对象的字符串,对象则返回[object object] toString(参数) 参数出可以传入一个用于进制数的参数,该参数的默认值为10(主要针对Number类型有效) ⑥ toLocaleString 同toString,但是会做一些本地化的处理。 ⑦ valueOf() 如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。 Date对象调用该方法会返回一个时间戳。 constructor说明：该属性指向创建该对象的构造函数，在这里为Object123456function Person() &#123; &#125; var p = new Person(); console.log(p.constructor); //function Person() &#123;&#125; console.log(Person.prototype.constructor); //function Person() &#123;&#125; console.log(Object.prototype.constructor); //function Object() &#123; [native code] &#125; hasOwnProperty说明：判断对象中是否拥有某个实例属性(不包括原型链上面的属性)12345678function Person() &#123; this.name = \"默认的姓名\"&#125;//检查对象中是否拥有指定的属性(实例属性)var p1 = new Person();p1.hasOwnProperty(\"name\"); //truep1.hasOwnProperty(\"age\"); //falsep1.hasOwnProperty(\"constructor\"); //对象的constructor是从原型对象上继承的 isPrototypeOf说明：校验某个对象是否是指定对象的原型对象(整条原型链);1234567891011121314&lt;script&gt; var obj = &#123; name:\"张三\", age:20, hello:function () &#123; console.log(\"hello\"); &#125;, showName:function () &#123; console.log(this.name); &#125; &#125; //属性是否存在且可以枚举 console.log(obj.propertyIsEnumerable(\"name\")); //true&lt;/script&gt; toString说明：返回一个描述目标对象的字符串,对象则返回[object object]12345678910111213&lt;script&gt; var obj = &#123;&#125;; console.log(obj.toString()); //打印[object Object] var arr = [1,2,3,4,5]; console.log(arr.toString()); //打印1,2,3,4,5 var num = 10; console.log(num.toString()); //10 var date = new Date(); console.log(date.toString()); //Mon Feb 13 2017 19:00:13 GMT+0800 (CST) //toString方法可以传入参数,在处理Number类型数据的时候,可以传入指定的进制 console.log(num.toString(2)); //1010 == 1*2*2*2+0*2*2+1*2+1*1 = 10 console.log(num.toString(3)); //101 == 1*3*3 + 0*3 + 1*1 = 10&lt;/script&gt; toLocaleString说明：作用同toString方法一致，但是会做一些本地化的处理. valueOf说明：① 如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。② 如果是Date类型，则返回时间戳。123456789&lt;script&gt; var obj = &#123;&#125;; console.log(obj + 1); //[object Object]1 //说明:如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。 var o = &#123;name:\"张三\"&#125;; console.log(o + 1); //[object Object]1 var date = new Date(); console.log(date.valueOf()); //1486984088998&lt;/script&gt; 静态成员和实例成员静态成员 定义在构造函数上面的成员(属性和方法) 实例成员 定义在实例对象上面的成员(属性和方法) 建议 ① 把工具类的方法写成静态方法 ② 把和对象相关的方法写成实例方法(成员) 代码示例12345678910111213141516&lt;script&gt; function Person() &#123; this.name = \"张三\"; //实例属性 this.showName = function () &#123; console.log(this.name); &#125;; &#125; //为Person构造函数添加静态成员 Person.des = \"描述信息\"; Person.add = function (msg) &#123; console.log(\"添加信息\" + msg); &#125;; Person.add(\"这是一个+操作\"); var p1 = new Person(); p1.showName();&lt;/script&gt; Function构造函数函数创建的几种方式 12301 函数声明02 字面量的方式创建03 使用new Function的形式创建 函数创建代码示例 12345678function func01() &#123; console.log(\"函数声明\"); &#125; var func02 = function () &#123; console.log(\"字面量方式创建\"); &#125; //使用Function构造函数创建 var func03 = new Function(); Function构造函数创建函数 参数说明:可以传入多个参数 最后一个参数:传入的最后一个参数为函数的函数体内容 其他参数:创建出来的函数的参数 如果只有一个参数,则表示这是该函数的函数体内容 传递参数的格式:以字符串的方式进行传参代码示例123456//需求01 使用Function构造函数创建一个函数对象,该函数执行一行打印操作var funcName01 = new Function(\"console.log('让我掉下眼泪的,不止昨夜的酒')\");funcName01();//需求02 使用Function构造函数创建一个函数对象,该函数需要接受两个参数,要求返回他们的和var funcName02 = new Function(\"a\",\"b\",\"return a + b;\");console.log(funcName02(10, 20)); //30 解决函数体代码过长的问题（1）使用转义字符，写在一行中（2）使用+操作符来拼接字符串（3）使用``操作符来管理字符串（4）使用模板先处理字符串，然后在js中获得模板中的内容 arguments、length和calleearguments参数说明：在js中的函数中，有两个隐藏的参数分别是this和arguments1234arguments 是一个类似数组的结构,可以通过下标来操作函数的参数,但并非数组类型的。在函数调用的时候,会将函数的所有参数都传入arguments对象中保存,因此我们可以通过操作arguments属性来操作参数形参的数量大于实参的数量,则依次传入,未传入的设置为undefined形参的数量小于实参的数量,则arguments中保存实际的值 length 函数内部的arguments数组拥有length属性,可以通过该属性获取用户调用时传入的实参的个数 函数本身有一个length属性,可以通过该属性来获取形式参数的个数 callee方法 函数内部的arguments对象中,有一个callee方法,该方法指向函数自身,常用于匿名函数的递归调用。 代码示例12345678910111213141516171819&lt;script&gt; function func() &#123; console.log(arguments); console.log(arguments.length); //调用函数时实际传入的参数数量 &#125; func(1,2,3,4,5); console.log(func.length); //预期的参数数量 —— 函数的形参数量 function func02(a,b) &#123; console.log(a, b); console.log(arguments); &#125; func02(1,2,3); //实参的数量 &gt; 形参的数量 则arguments保存实参的值 func02(1); //实参的数量 &lt; 形参的数量 则不足的补undefined //匿名函数调用 (function () &#123; //如果需要在该函数中调用自身,则可以使用arguments.callee方法 arguments.callee(); &#125;)();&lt;/script&gt; Function的应用01 数组去重123456789101112 var func = new Function(\"arr\",` var array = []; for(var i = 0 ; i&lt;arr.length; i++) &#123; if(array.indexOf(arr[i]) == -1) &#123; array.push(arr[i]); &#125; &#125; return array;`); console.log(func([1, 2, 3, 4, 5, 3, 4, 2]));; 02 返回传入函数中所有数据的最大值123456789101112var func = function () &#123; var maxNumber = arguments[0]; for(var i = 0;i&lt;arguments.length;i++) &#123; if (maxNumber &lt; arguments[i]) &#123; maxNumber = arguments[i]; &#125; &#125; return maxNumber;&#125;console.log(func(1, 2, 3, 45, 5, 6, 7, 8, 30, 21)); eval 简单说明eval 的基本使用eval函数用来讲字符串转换为JS的代码,并执行 eval 处理JSON数据代码示例123456&lt;script&gt; var jsonData = '&#123;\"name\":\"张三\",\"age\":18&#125;'; //把json的数据转换为对象 var obj = JSON.parse(jsonData); console.log(obj);&lt;/script&gt; 12345678910111213&lt;script&gt; var jsonData = '&#123;\"name\":\"张三\",\"age\":18&#125;'; //var obj = eval(jsonData); //注意:如果直接这样写代码则会报错 //正确的处理方式 //方式一 eval(\"var obj = \" + jsonData); console.log(obj); //方式二 //说明:使用eval来解析json格式字符串的时候,会将&#123;&#125;解析为代码块,而不是字面量 // 在使用的时候为了避免这种错误,需要在JSO的最外面加上(),如此则会把大括号当做一条语句来解析 var o = eval(\"(\"+jsonData+\")\"); console.log(o);&lt;/script&gt; eval 注意事项 ① eval函数本身功能强大,但它的特性也为程序带来了很大的不确定性,因此在开发中并不推荐使用。 ② eval函数是动态的执行代码,因此其效率不如直接执行静态脚本高。 eval和Function比较12相同点:都能够把字符串转换为Javascript的代码不同点:eval转换为js的代码之后马上就执行,而Function需要先创建函数,调用函数之后才会执行。 Function.prototype原型链关于Function和自定义构造函数的原型对象 Function.prototype 是一个空的函数 自定义构造函数的原型对象是一个空的对象 说明 Function也可以被当做是一个构造函数 通过new Function创建出来的函数,可以认为是Function的实例化对象。 Function的原型对象是一个空的函数,这个空的函数也是一个对象,它的原型对象是Object.prototype。 在JS中,Object的原型对象是所有对象的祖宗。 Function是构造函数,则其原型对象为空的函数 空的函数的原型对象为Object.prototype Function本身也是对象,则其构造函数为:function Function() { [native code] } 是自身 同Object类型 Object本身是构造函数,其原型对象是Object.prototype Object本身也是对象,其构造函数为:function Function() { [native code] 代码示例123456789101112131415//01 提供Person构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置Person的原型对象 Person.prototype.showName = function () &#123; console.log(this.name); &#125; //03 创建Student构造函数 function Student(number) &#123; this.numer = number &#125; //04 设置Student的原型对象 Student.prototype = new Person(); 完整的原型链示意图Object和Function的关系01 Object构造函数是通过Function构造函数实例化出来的02 Function构造函数也是通过Function构造函数实例化出来的 代码示例12345678&lt;script&gt; //检查对象是否是某个构造函数的实例 console.log(Function instanceof Function); console.log(Function instanceof Object); console.log(Object instanceof Object); console.log(Object instanceof Function); //注意:以上打印结果均为true&lt;/script&gt; 对象的拷贝操作浅拷贝如果对象中的属性是引用类型的值,那么存在数据共享问题,修改某个对象会对拷贝的对象产生影响代码示例123456789var o = &#123;name:\"张三\",car:&#123;number:\"2017\",type:\"火车\"&#125;&#125;;var obj = &#123;&#125;;//obj对象需要拷贝o对象中所有的属性for (var i in o )&#123; obj[i] = o[i];&#125;console.log(obj);o.car.type = \"飞船\";console.log(obj); 深拷贝 如果对象中的属性是值类型,那么就直接拷贝赋值 如果对象中的属性是引用类型,那么就再次调用拷贝方法,遍历对象 代码示例123456789101112131415161718192021222324252627 var o = &#123;name:\"张三\",car:&#123;number:\"2017\",type:\"火车\"&#125;&#125;; var obj = &#123;&#125;; function deepCopy(obj,tmp) &#123; tmp = tmp || &#123;&#125;; //如果没有传入,那么就创建一个空的对象 for(var i in obj) &#123; if (obj.hasOwnProperty(i)) //只拷贝实例属性 &#123; //判断是否是引用类型 if ((typeof obj[i]) == 'object') &#123; //重新调用拷贝方法 tmp[i] = Array.isArray(obj[i]) ? [] :&#123;&#125;; deepCopy(obj[i],tmp[i]); &#125;else &#123; //直接拷贝 tmp[i] = obj[i]; &#125; &#125; &#125; &#125;deepCopy(o,obj); console.log(obj); o.car.type = \"测试的类型\"; console.log(obj); console.log(o); 注意isArray的兼容性问题isArray是ECMA5中新推出的方法,需要处理兼容性问题123456if (Array.isArray != \"function\")&#123; Array.isArray = function (obj) &#123; return Object.prototype.toString.call(obj) == '[object Array]'; &#125;&#125; Number原型扩展小案例：在Number的原型对象上面定义一个新的方法add(),该方法接收一个参数,并将该参数与自身的值进行相加,然后进行返回。代码实现123456789Number.prototype.add = function (num) &#123; return this + num;&#125;var n = 10;console.log(n.add(3));//console.log(5.add(5)); 错误:解析器无法处理字面量的这种情况var num = new Number(50);console.log(num.add(20)); //70console.log((1).add(4)); //5 使用()把数字包起来 使用注意123（01）使用数字变量可以调用成功（02）使用数字表达式可以调用成功（03）直接使用数字字面量方式调用失败 js的语法解析器无法处理数字字面量这种情况。 With语句with语句简单介绍123with语句是js中一个强大但有争议的特性。with语句允许我们将一个对象的所有属性引用到当前的作用域允许我们无需使用拥有者对象的前缀，就可以直接对这些属性进行引用和赋值操作。 注意：ECMAScript5规范在严格模式下已经禁用了该语句，在开发中不推荐使用，但是要求能够看懂with的代码。 with语句内部细节说明： with语句会创建一个作用域，在该作用域内，在引用特定对象的属性时，可以不使用前缀。应用场景：对深层级对象的引用进行缩短。 在with作用域内部引用属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //[01] 测试with语句作用域内对对象属性的引用 //01 提供全局变量,名称为testValue var testValue = '测试使用的全局变量'; //02 提供对象,对象内部提供属性 var testObject = &#123; name:'对象的名称属性', testValue:'对象内部的属性' &#125;; //03 使用with语句引用 with(testObject) &#123; console.log(name); //对象的名称属性 console.log(testValue); //对象内部的属性 console.log(this); //window &#125; console.log(testValue); //测试使用的全局变量``` 总结：(1) 在with语句作用域内,对象属性的优先级绝对高于在更层级作用域内定义的同名变量(2) this(函数上下文)依然指向window,并不会收到with作用域的影响**在with作用域内进行赋值操作**```js //01 提供一个对象,在内部提供属性 var obj = &#123; name:'对象的内部属性', &#125; //02 with语句测试对对象属性的赋值操作 with(obj) &#123; name = '修正对象中name的值'; //在作用域内部添加变量(思考?该变量是添加为全局作用域还是当前obj对象的属性?) age = '25'; showName = function () &#123; console.log('name == ' + name); &#125;; &#125;; //测试修改对象属性操作 console.log(obj.name); //测试添加对象属性操作 console.log(obj.age); //undefined //obj.showName(); //obj.showName is not a function console.log('____________________'); console.log(this.name); //== name == window.name console.log(window.name); console.log(name); showName(); //==this.showName() ==window.showName() 总结：（1）在with作用域的内部我们可以使用无前缀引用对象的属性进行读取和赋值的操作 但是 不能使用无前缀的方式添加属性（2）如果使用无前缀的方式来添加属性[对不存在的属性进行赋值操作],那么属性将被添加到全局上下文[window|this]（3）可能产生的错误:意外的引入一个全局变量,而非为with作用域对象添加属性 with语句的问题（1）with作用域内操作优先级混乱（2）性能不好，会大大降低js代码的执行性能（3）ECMAScript5规定在严格模式下禁用with特性 with语句简化代码的替代方案使用即时调用函数来替代with语句，通过函数传参的方式使用更短的引用来替代冗长的引用前缀比使用with语句消除前缀的方式更好。123456789101112with(this.style)&#123; width = '200px'; height = '200px'; backgroundColor = '#ca3'; console.log(width); //要访问的本应该是外部的字符串变量 \"错误哈哈\",但是这里被解释为200px&#125;(function (s) &#123; s.width = '200px'; s.height = '200px'; s.backgroundColor = '#ca3';&#125;)(this.style); 使用面向过程的方式处理1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; var bookList = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ]; //增加操作 bookList.push(&#123;name:\"城堡\",author:\"卡夫卡\"&#125;); //查询操作 for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == \"飞鸟集\") &#123; console.log(obj); break; &#125; &#125; //修改操作 for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == \"飞鸟集\") &#123; obj.author = \"泰戈尔-戈尔泰\" &#125; &#125; //删除操作 for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == \"飞鸟集\") &#123; //删除该对象 bookList.splice(i, 1); &#125; &#125; console.log(bookList);&lt;/script&gt; 使用函数来封装图书管理操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script&gt; var bookList = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ]; //增加操作 function addBook(bookObj) &#123; bookList.push(bookObj); &#125; addBook(&#123;name:\"城堡\",author:\"卡夫卡\"&#125;); //查询操作 function getBook(name) &#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; return obj; &#125; &#125; return null; &#125; console.log(getBook(\"什么是批判\")); //修改操作 function updateBookData(name,authorName)&#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; obj.author = authorName; &#125; &#125; &#125; updateBookData(\"飞鸟集\",\"泰戈尔斯坦\"); //删除操作 function removeBook(name) &#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; //删除该对象 bookList.splice(i, 1); &#125; &#125; &#125; console.log(bookList);&lt;/script&gt; 数封装-复用形式12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; var bookList = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ]; //增加操作 function addBook(bookObj) &#123; bookList.push(bookObj); &#125; addBook(&#123;name:\"城堡\",author:\"卡夫卡\"&#125;); //查询操作 function getBook(name) &#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; return obj; &#125; &#125; return null; &#125; console.log(getBook(\"什么是批判\")); //修改操作 function updateBookData(name,authorName)&#123; var obj = getBook(name); obj.author = authorName; &#125; updateBookData(\"飞鸟集\",\"泰戈尔斯坦\"); //删除操作 function removeBook(name) &#123; var obj = getBook(name); var index = bookList.indexOf(obj); bookList.splice(index,1); &#125; addBook(&#123;name:\"东京人\",author:\"川端康成\"&#125;); console.log(bookList);&lt;/script&gt; 面向对象的方式管理图书123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;scrip&gt; var obj = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ];泰 function BookManager() &#123; this.bookList = null; &#125; BookManager.prototype = &#123; constructor:BookManager, init:function (arr) &#123; this.bookList = arr || []; &#125;, addBook:function (bookObj) &#123; this.bookList.push(bookObj) &#125;, getBook:function (name) &#123; for (var i = 0; i &lt; this.bookList.length; i++) &#123; var obj = this.bookList[i]; if (obj.name == name) &#123; return obj; &#125; &#125; return null; &#125;, updateBookData:function (name,authorName)&#123; var obj = this.getBook(name); obj.author = authorName; &#125;, removeBook:function (name) &#123; var obj = this.getBook(name); var index = this.bookList.indexOf(obj); this.bookList.splice(index,1); &#125; &#125;; //01 创建对象 var YYManager = new BookManager(); YYManager.init(obj); console.log(YYManager.bookList); //02 演示添加操作 YYManager.addBook(&#123;name:\"花田半亩\",author:\"田维\"&#125;); console.log(YYManager.bookList); //03 演示查询操作 console.log(YYManager.getBook(\"花田半亩\")); //04 演示更新操作 YYManager.updateBookData(\"花田半亩\",\"甜田\"); console.log(YYManager.getBook(\"花田半亩\"));; //05 演示删除操作 YYManager.removeBook(\"什么是批判\"); console.log(YYManager.bookList); //02 创建第二个人的图书管理对象 var wulitaotaoMManager = new BookManager(); wulitaotaoMManager.init([&#123;name:\"装逼速成\",author:\"六扇门\"&#125;]); console.log(wulitaotaoMManager.bookList);&lt;/script&gt; 总结01 提供构造函数，在构造函数内部设置实例化属性02 把常用的操作提取成对象的实例方法，写在原型对象身上03 提供init方法，用于初始化数据04 注意：如果切断了原型对象那么需要修正内部的构造器属性指向","categories":[{"name":"JavaScript简明教程","slug":"JavaScript简明教程","permalink":"http://www.1oveit.club/categories/JavaScript简明教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.1oveit.club/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"}]},{"title":"JavaScript简明教程（3）","slug":"js-3","date":"2016-02-18T03:55:29.000Z","updated":"2017-05-13T10:45:13.000Z","comments":true,"path":"2016/02/18/js-3/","link":"","permalink":"http://www.1oveit.club/2016/02/18/js-3/","excerpt":"关于继承，通俗说子继父业。在JavaScript中，Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。 继承相关方法在讲继承之前，我们必须先了解一些相关的方法。 hasOwnProperty和in属性操作in关键字作用：用来检查对象中是否存在某个属性(不区分实例属性和原型属性)。语法：“属性名” in 对象。代码示例:","text":"关于继承，通俗说子继父业。在JavaScript中，Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。 继承相关方法在讲继承之前，我们必须先了解一些相关的方法。 hasOwnProperty和in属性操作in关键字作用：用来检查对象中是否存在某个属性(不区分实例属性和原型属性)。语法：“属性名” in 对象。代码示例:12345678910111213141516&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; this.name = name; &#125; //02 设置构造函数的原型对象的属性 Person.prototype.sayHello = function () &#123; console.log(\"hello\"); &#125; //03 创建对象 var p1 = new Person(); //04 使用in关键字判断对象中是否存在以下属性:name age sayHello console.log(\"age\" in p1); //false console.log(\"name\" in p1); //true console.log(\"sayHello\" in p1); //true&lt;/script&gt; 对象的hasOwnProperty方法作用：用来检查对象中是否存在指定的属性(只检查实例属性)语法：对象.hasOwnProperty(“属性名”)代码示例123456789101112131415161718&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; this.name = name; &#125; //02 设置构造函数的原型对象的属性 Person.prototype.sayHello = function () &#123; console.log(\"hello\"); &#125; Person.prototype.des = \"默认的描述信息\"; //03 创建对象 var p1 = new Person(); //04 使用hasOwnProperty方法判断该属性是否是对象的实例属性 console.log(p1.hasOwnProperty(\"age\")); //false console.log(p1.hasOwnProperty(\"name\")); //true console.log(p1.hasOwnProperty(\"sayHello\")); //false console.log(p1.hasOwnProperty(\"des\")); //false&lt;/script&gt; 判断某对象中存在且只存在某个原型属性123function isProperty(obj, property) &#123; return !obj.hasOwnProperty(property) &amp;&amp; (property in obj); &#125; constructor构造器属性说明 使用构造函数创建对象,则 原型对象中的constructor属性指向对应的构造函数 实例对象中的constructor指向对应的构造函数,其中这里的constructor就是从原型中获取的即constructor时实例对象中的原型属性,而非实例属性 代码验证123456789101112131415//01 提供一个构造函数 function Person(name) &#123; this.name = name; &#125; //02 设置构造函数的原型对象的属性 Person.prototype.sayHello = function () &#123; console.log(\"hello\"); &#125;; Person.prototype.des = \"默认的描述信息\"; //03 创建对象 var p1 = new Person(); function isProperty(obj, property) &#123; return !obj.hasOwnProperty(property) &amp;&amp; (property in obj); &#125; console.log(isProperty(p1, \"constructor\")); //true isprotoTypeOf和instanceisprotoTypeOf作用：判断是否是某个实例对象的原型对象语法:构造函数.protoType.isPrototypeOf(对象)用法示例123456789&lt;script&gt; function Person() &#123;&#125; function Dog() &#123;&#125; Person.prototype.name = \"嘿嘿\"; var p1 = new Person(); console.log(Person.prototype.isPrototypeOf(p1));//rue console.log(Object.prototype.isPrototypeOf(p1));//true console.log(Dog.prototype.isPrototypeOf(p1));//false&lt;/script&gt; instance作用：用于检查对象是否是某个构造函数(类型)的实例语法：对象 instance 构造函数注意：所有的对象都是Object构造函数（类型）的实例用法示例12345678&lt;script&gt; var arr = [1,2,3]; console.log(arr instanceof Array); //true console.log(Array instanceof Object); //true console.log(arr instanceof Object); //true //instanceOf在判断的时候,算上整条原型链 //arr 是Array 和Object 任何一个类的示例&lt;/script&gt; 继承继承基本概念继承：即通过一定的方式实现让某个类型A获取另外一个类型B的属性或方法。其中类型A称之为子类型，类型B称之为父类型或超类型。 javaScript中的继承Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。继承有两种方式：接口继承和实现继承，在js中只支持实现继承，实现继承主要依赖原型链来完成。JavaScript中实现继承的几种方式：说明:其他语言中继承通常通过类来实现，js中没有类的概念，js中的继承是某个对象继承另外一个对象，是基于对象的。123401 原型式继承02 原型链继承03 经典继承(借用构造函数)04 组合继承 原型式继承原型链继承的方式A1234567891011121314151617&lt;script&gt; //01 提供一个构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置原型对象的属性 Person.prototype.className = \"逍遥派1班\"; //03 使用构造函数来创建原型对象 var p1 = new Person(\"张三\",10); var p2 = new Person(\"李四\",20); //04 打印p1和p2对象中的className属性 console.log(p1.className); console.log(p2.className); //结论:对象p1和p2继承了构造函数原型对象中的属性className //但是这并不是严格意义上的继承&lt;/script&gt; 原型链继承的方式B1234567891011121314151617181920&lt;script&gt; //01 提供一个构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置原型对象的属性 Person.prototype = &#123; constructor:Person, className:\"逍遥派1班\" &#125;; //03 使用构造函数来创建原型对象 var p1 = new Person(\"张三\",10); var p2 = new Person(\"李四\",20); //04 打印p1和p2对象中的className属性 console.log(p1.className); console.log(p2.className); //结论:对象p1和p2继承了构造函数原型对象中的属性className //注意:使用原型替换的方式实现继承的时候,原有原型对象中的属性和方法会丢失&lt;/script&gt; 原型链继承的方式C1234567891011121314151617181920212223//01 提供超类型|父类型构造函数function SuperClass() &#123; this.name = 'SuperClass的名称'; this.showName = function () &#123; console.log(this.name); &#125;&#125;//02 设置父类型的原型属性和原型方法SuperClass.prototype.info = 'SuperClass的信息';SuperClass.prototype.showInfo = function () &#123; console.log(this.info);&#125;;//03 提供子类型function SubClass() &#123;&#125;//04 设置继承(原型对象继承)SubClass.prototype = SuperClass.prototype;SubClass.prototype.constructor = SubClass;var sub = new SubClass();console.log(sub.name); //undefinedconsole.log(sub.info); //SuperClass的信息sub.showInfo(); //SuperClass的信息sub.showName(); //sub.showName is not a function 点评：上面的方法可以可以继承超类型中的原型属性和原型方法，但是无法继承实例属性和实例方法 原型链继承实现思想：利用原型（链）让一个对象继承另一个对象的属性和方法实现本质：重写原型对象 原型链123456① 每个构造函数都有原型对象② 每个对象都有自己的构造函数③ 每个构造函数的原型都是一个对象④ 那么这个构造函数的原型对象也有自己的构造函数⑤ 那么这个构造函数的原型对象的构造函数也有自己的原型对象以上形成一个链式的结构,称之为原型链 原型链中的属性搜索原则12345当访问某个对象的成员的时候,会先在自身中查找,如果找到则直接使用如果在自身中没有找到,则去当前创建当前对象的构造函数的原型对象中查找,如果找到了则直接使用如果在该原型对象中没有找到,则继续查找原型对象的原型对象(创建该原型对象的构造函数所对应的原型对象),如果找到则直接使用如果在原型对象的原型对象中也没有找到,则继续向上搜索....直到Object的原型对象,若还是没有,则返回undefined(属性)或报错(方法)。 基本写法·代码示例1234567891011121314151617181920212223//01 提供超类型|父类型function SuperClass() &#123; this.name = 'SuperClass的名称'; this.showName = function () &#123; console.log(this.name); &#125;&#125;//02 设置父类型的原型属性和原型方法SuperClass.prototype.info = 'SuperClass的信息';SuperClass.prototype.showInfo = function () &#123; console.log(this.info);&#125;;//03 提供子类型function SubClass() &#123;&#125;//04 设置继承(原型对象继承)SubClass.prototype = new SuperClass();SubClass.prototype.constructor = SubClass;var sub = new SubClass();console.log(sub.name); //SuperClass的名称console.log(sub.info); //SuperClass的信息sub.showInfo(); //SuperClass的信息sub.showName(); //SuperClass的名称 点评：可以继承父类型中的原型属性|原型方法,以及实例属性和实例方法 注意点① 确定原型和实例的关系 instanceof + isPrototypeOf()② 注意重写原型对象的位置，必须先实现原型继承，然后再设置子对象的原型属性和原型方法③ 完成继承之后，不能使用字面量的方式来创建原型[因为会切断原型] 问题① 父对象的实例属性会转换为子类型原型的原型属性，而如果父类型是实例属性是引用类型则会存在共享问题② 在创建子类型的实例时，不能向父类型的构造函数中传递参数1234567891011121314151617//01 提供父对象的构造函数function SuperType() &#123; //02 在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈'];&#125;;//03 提供子对象的构造函数function SubType() &#123;&#125;;//04 设置原型继承SubType.prototype = new SuperType();//05 创建父对象构造函数的实例对象,并对内部的实例化属性进行修改var subDemo1 = new SubType();var subDemo2 = new SubType();alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈subDemo1.family.push('爷爷','奶奶');alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶 经典继承（借用构造函数）经典继承又称为借用构造函数|伪造继承 基本思想在子类型构造函数的内部调用超类型|父类型构造函数说明：需要借助call|apply方法代码示例1234567891011121314151617181920212223242526//01 提供父类型(对象)的构造函数 function SuperType(name) &#123; //02 在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈']; //实例属性 this.name = name; &#125;; SuperType.prototype.info = '父类型的原型属性'; //03 提供子类型（对象）的构造函数 function SubType() &#123; //经典继承|借用构造函数|伪造对象继承 //SuperType.call(this); //构造参数传递参数 SuperType.call(this,'张老汉'); &#125;; //04 创建父类型的实例对象,并对内部的实例化属性进行修改 var subDemo1 = new SubType(); var subDemo2 = new SubType(); alert(subDemo1.info); //undefined alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈 alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈 subDemo1.family.push('爷爷','奶奶'); alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶 alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈 //测试构造函数传递参数 alert(subDemo1.name); 点评：能够继承父类型的实例属性,但是无法继承父类型的原型属性和原型方法 经典继承的优点① 解决实例对象共享问题，通过调用父对象的构造函数来实现每个子类型（对象）的实例对象均拥有一份父类型实例属性和方法的副本② 可以在调用call方法的时候向构造函数传递参数 经典继承的问题① 冒充继承的方法无法实现函数的重用② 无法继承父对象的原型属性和原型方法 组合继承组合继承|伪经典继承 基本思想① 使用原型链实现对原型属性和方法的继承② 通过伪造(冒充)构造函数来实现对实例属性的继承代码示例1234567891011121314151617181920212223242526272829//01 提供父类型的构造函数function SuperType(name) &#123; //在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈']; //实例属性 this.name = name;&#125;;//原型方法SuperType.prototype.showName = function () &#123; console.log(this.name);&#125;//02 提供子类型的构造函数function SubType(name) &#123; //冒充|伪造 构造参数传递参数 SuperType.call(this,name);&#125;;SubType.prototype = SuperType.prototype;//SubType.prototype = new SuperType();//02 创建父类型的实例对象,并对内部的实例化属性进行修改var subDemo1 = new SubType('张三');var subDemo2 = new SubType('张四');alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈subDemo1.family.push('爷爷','奶奶');alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈//测试构造函数传递参数subDemo1.showName(); //张三subDemo2.showName(); //张四 基本包装类型基本类型：字符串 + 数值 + null + undefined + 布尔值为了便于操作基本类型，ECMAScript提供了三个特殊的引用类型：Boolean + Number + String。上述类型和其他的引用类型类似，同时也具备与各自的基本类型相应的特殊行为，每当我们读取一个基本类型的值的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。123var str = '测试字符串';console.log(str.length); //5console.log(str.substring(2)); //字符串 思考：属性和方法本是对象的特征，字符串如何能够拥有length属性以及其他类似subString等方法，内部怎么实现的？基本类型值并不是对象，因此从逻辑上讨论他们不应该有属性和方法。 内部的具体处理:123（1）创建String类型的一个实例对象（2）在实例对象上面读取指定的属性（length）,调用指定的方法（subString）（3）销毁该对象 NumberNumber是与数字值相对应的引用类型。创建Number类型的对象：var num = new Number(10); String String是字符串的对象包装类型。创建字符串类型的对象：var str = new String(‘hello World’); BooleanBoolean是与布尔值对象的引用类型。可以通过调用Boolean构造函数传递参数来创建boolean类型的对象。var bool = new Boolean(true); 基本包装类型的代码示例1234567891011121314//001 Stringvar str = '测试字符串';console.log(str.length); //5console.log(str.substring(2)); //字符串//002 Numbervar num = new Number(10);console.log(num); //Number &#123;[[PrimitiveValue]]: 10&#125;console.log(typeof num); //objectconsole.log(typeof 10); //number//003 Booleanvar bool = new Boolean(true);console.log(bool); //Boolean &#123;[[PrimitiveValue]]: true&#125;console.log(typeof bool); //objectconsole.log(typeof true); //boolean 基本包装类型的注意点[1] 对象还是基本数据类型值？对象：通过new 调用构造函数创建出来的是对象基本数据类型值：直接通过字面量方式赋值|通过省略new关键字调用构造函数方式创建的是基本数据类型值。12345ex: var str1 = new String('hello'); var str2 = 'hello'; var str3 = String('hello'); 说明：以上代码中，str1是对象，而str2和str3是字符串（基本数据类型值） [2] 相等问题基本类型值判断相等=&gt;值相等引用类型值判断相等=&gt;值相等且引用相等对象是引用类型，因此在判断相等的时候有诸多的注意点和容易出错的地方123456789101112131415161718ex var str1 = '这是一个字符串'; //基本数据类型 var str2 = String('这是一个字符串'); //基本数据类型 console.log(str1 == str2); //true 相等 var str3 = new String('这是一个字符串'); //引用类型-对象 console.log(str1 == str3); //true //值相等 console.log(str2 == str3); //true //值相等 console.log(str1 === str3); //false //值相等,但是引用不相等 console.log(str2 === str3); //false //值相等,但是引用不相等 //判断下面的变量是否相等 var num1 = 10; //基本数据类型 var num2 = new Number(10); //对象 console.log(num1 == num2); //true console.log(num1 === num2); //false var bool1 = true; var bool2 = new Boolean(true); console.log(bool1 == bool2); //true console.log(bool1 === bool2); //false","categories":[{"name":"JavaScript简明教程","slug":"JavaScript简明教程","permalink":"http://www.1oveit.club/categories/JavaScript简明教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.1oveit.club/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"}]},{"title":"JavaScript简明教程（2）","slug":"js-02","date":"2016-02-01T05:15:15.000Z","updated":"2017-05-13T10:45:13.000Z","comments":true,"path":"2016/02/01/js-02/","link":"","permalink":"http://www.1oveit.club/2016/02/01/js-02/","excerpt":"面向对象方法被人谈论了二十多年了，直到今天，我们还一直在谈对象。 面向对象编程面向层过程和面向对象编程01 面向对象编程和面向过程编程是一种编程思想,和具体的语言关系不大。02 面向过程编程和面向对象编程的主要区别","text":"面向对象方法被人谈论了二十多年了，直到今天，我们还一直在谈对象。 面向对象编程面向层过程和面向对象编程01 面向对象编程和面向过程编程是一种编程思想,和具体的语言关系不大。02 面向过程编程和面向对象编程的主要区别1234567891011121314151617181920面向过程编程: 关注点在于解决问题需要的每一个详细的步骤 示例: 自己洗衣服的过程 ① 收集需要洗的脏衣服 ② 准备洗衣粉、洗衣液等 ③ 把衣服放到一个盆里 ④ 接水 ⑤ 把洗衣粉放到盆里 ⑥ 摩擦,摩擦,不断的摩擦 ⑦ 把洗好的衣服用清水冲洗干净 ⑧ 尽量把把洗好的衣服的水分拧干 ⑨ 晾晒 面向对象编程: 关注点在于解决问题需要的对象身上 示例: 使用洗衣机洗衣服的过程 ① 收集需要洗的脏衣服 ② 找到合适的洗衣机 ③ 设定洗衣服和烘干的程序 03 面向过程和面向对象他们的区别就类似于自己洗衣服和使用洗衣机洗衣服|自己做饭吃和去餐馆吃饭 面向对象编程的相关概念01 对象 什么是对象? 所有的一切都是对象,在开发中有一项重要的工作就是对象的划分。一般来说,我们所指的对象是某个具体的事物,而非泛泛的类别。02 对象的特征(静态描述信息) 所谓特征就是一些特定的描述信息 如:学生(性别、年龄、班级、专业、籍贯、家庭住址) 如:汽车(颜色、车牌、品牌、价格等)03 对象的行为(动态特性) 如:人(吃饭、睡觉、玩游戏、奔跑、运动等) 如:狗(吃、睡、咬人、叫、流口水)04 js中的对象 键-值对(key-value)的集合。05 现实生活中的对象和js对象的对应关系 静态的描述信息 - js对象中的属性(属性就是定义在对象内部的变量) 动态的行为特征 - js对象中的方法(方法就是定义在对象内部的函数)06 代码示例：12345678910111213141516171819202122232425 var zhangsan = &#123; name:\"张三\", sex:\"男\", age:18, address:\"天上人间1号公馆\", eat:function () &#123; console.log('能吃'); &#125;, sleep:function () &#123; console.log(\"能睡\"); &#125;, say:function () &#123; console.log(\"能说话\"); &#125;, run:function () &#123; console.log(\"能运动\"); &#125;, song:function () &#123; console.log(\"能唱歌\"); &#125; &#125;; //打印对象的属性并调用相关的方法console.log(zhangsan.name,zhangsan.age,zhangsan.address); zhangsan.say(); zhangsan.sleep(); 面向对象的三大特性面向对象的三大特性:封装、继承、多态01 封装:复用|信息隐蔽代码示例123456789101112131415161718192021//01 封装的简单说明//001 观察以下杂乱无关的语句,它们仅仅只是一堆无意义的全局变量var name = \"乘风波浪会有时\";var actors = [\"彭于晏\",\"邓超\"];var showTime = \"2016-1-28 - 2016-2-28\";var director = \"韩寒\";var type = \"喜剧\";var play = function () &#123; //播放......&#125;;//002 把上面的变量封装到对象中(更具有意义)var film = &#123; name:\"乘风破浪会有时\", actors:[\"彭于晏\",\"邓超\"], showTime:\"2016-1-28 - 2016-2-28\", director:\"韩寒\", type:\"喜剧\", play:function () &#123; //播放...... &#125;&#125; 02 继承:获取已经存在的对象已有属性和方法的一种方式(获取他人已有财富和资源的一种方式)。代码示例123456789101112131415//继承的简单示例//001 创建一个空的对象var nullObj = &#123;&#125;;// 上面的对象film拥有了很多的属性和方法//002 设法让nullObj拥有film中所有的属性和方法//方法一:自己重新写一遍//方法二:通过某种方式来获得,比如遍历该对象,然后完成赋值for(var k in film)&#123; nullObj[k] = film[k];&#125;for(var k in nullObj)&#123; console.log(nullObj[k]);&#125; 03 多态(polymorphism) 多态:polymorphism = poly(复数) + morph(形态) + ism 多用于强类型语言中，JavaScript具备与生俱来的多态特性。 多态表现为: ① 同一操作,作用于不同的对象,会产生不同的解释和行为。 ② 隐藏不同。 创建对象的方法字面量方式创建对象基本写法123456789var book1 = &#123; name:\"声名狼藉者的生活\", price:42.00, author:\"福柯\", press:\"北京大学出版社\", read:function () &#123; console.log(\"我的书名为:声名狼藉者的的生活,作者为福柯....\"); &#125; &#125;; 存在的问题[01] 代码复用性差[02] 如果要创建大量的同类型对象，则需要些大量重复性代码 内置构造函数创建对象JS中的内置构造函数123456789StringNumberBoolean 注意：(区别于string number boolean)DateArrayFunctionObjectRegExp 基本写法12345678var book1 = new Object();book1.name = \"声名狼藉者的生活\";book1.price = 42.00;book1.author = \"福柯\";book1.press = \"北京大学出版社\";book1.read = function () &#123; console.log(\"我的书名为:声名狼藉者的的生活,作者为福柯....\");&#125;; 问题01 创建的对象无法复用,复用性差02 如果需要创建多个同类型的对象,如(书籍)则需要写大量重复的代码,代码的冗余度高 工厂函数创建对象基本写法12345678910111213141516171819202122function createBookNew (name,price,author,press) &#123; var book = new Object(); book.name = name; book.price = price; book.author = author; book.press = press; book.read = function () &#123; console.log(\"我的书名为:\"+book.name+\",作者为\"+book.author+\"....\"); &#125;; return book;&#125;//使用工厂函数来创建对象var book1 = createBookNew(\"声名狼藉者的的生活\",\"42.00\",\"福柯\",\"北京大学出版社\");var book2 = createBookNew(\"人性的枷锁\",\"49.00\",\"毛姆\",\"华东师范大学出版社\");var book3 = createBookNew(\"悟空传\",\"28.00\",\"今何在\",\"湖南文艺出版社\");//打印对象的属性,调用对象的方法console.log(book1.name);console.log(book2.name);console.log(book3.name);book1.read();book2.read();book3.read(); 工厂函数说明:001 工厂函数方式创建对象其本质是对内置构造函数创建对象的过程进行了封装002 适用于大规模“批量生产”同类型的对象1234567891011121314function createBook (name,price,author,press) &#123; //001 参数 = 原料 var book = new Object(); //002 创建对象并设置对象的属性和方法 = 对原料进行加工 book.name = name; book.price = price; book.author = author; book.press = press; book.read = function () &#123; console.log(\"我的书名为:\"+book.name+\",作者为\"+book.author+\"....\"); &#125;; //003 把处理好的对象返回给我们 == 产品出厂 return book;&#125; 封装思路:使用函数把固定不变的部分封装起来，变化的部分提取为函数的参数。工厂函数创建对象的实现过程:① 提供一个创建对象的函数（参数）② 在该函数内部使用new 关键字和Object构造器创建对象③ 设置对象的属性④ 设置对象的方法⑤ 返回对象 自定义构造函数创建对象基本写法123456789101112131415function 构造函数名(参数1,参数2,参数3...) &#123; //设置对象的属性 this.属性01 = 参数1; this.属性02 = 参数2; //设置对象的方法 this.方法01 = function () &#123; //..... &#125;; this.方法02 = function () &#123; //..... &#125;&#125;//自定义构造函数方式创建对象var 对象01 = new 构造函数名(实参01,实参02,实参03...);var 对象02 = new 构造函数名(实参01,实参02,实参03...); 代码示例12345678910111213141516171819function CreateBook (name,price,author,press) &#123; this.name = name; this.price = price; this.author = author; this.press = press; this.read = function () &#123; console.log(\"我的书名为:\"+this.name+\",作者为\"+this.author+\"....\"); &#125;;&#125;var b1 = new CreateBook(\"声名狼藉者的的生活\",\"42.00\",\"福柯\",\"北京大学出版社\");var b2 = new CreateBook(\"人性的枷锁\",\"49.00\",\"毛姆\",\"华东师范大学出版社\");var b3 = new CreateBook(\"悟空传\",\"28.00\",\"今何在\",\"湖南文艺出版社\");//打印对象的属性,并调用对象的方法测试console.log(b1.author);console.log(b2.author);console.log(b3.author);b1.read();b2.read();b3.read(); 构造函数与new关键字:new关键字的作用：用于创建对象（Object类型）。构造函数和普通函数的区别：函数的首字母大写。构造函数的作用:用于完成对象的初始化。 自定义构造函数和简单工厂函数的对比：1234① 函数的首字母大写(用于区别构造函数和普通函数)② 创建对象的过程是由new关键字实现③ 在构造函数内部会自动的创建新对象,并赋值给this指针④ 自动返回创建出来的对象 构造函数的执行过程① 使用new关键字创建对象② 把新创建出来的对象赋值给this③ 在构造函数内部,使用this为新创建出来的对象设置属性和方法④ 默认返回新创建的对象(普通函数如果不显示的return则默认返回undefined)。 构造函数的返回值01 如果在构造函数中没有显示的return,则默认返回的是新创建出来的对象02 如果在构造函数中显示的return,则依照具体的情况处理 [01] return 的是对象,则直接返回该对象,取而代之本该默认返回的新对象 [02] return 的是null或基本数据类型值,则返回新创建的对象 构造函数方式创建对象存在的问题每次创建对象,都会重新创建函数，那么如果创建的对象数量很多,而对象方法内部的实现一模一样,则造成了资源浪费。 构造函数的使用注意函数传值：可以把构造函数的对象方法抽取为参数。代码示例：1234567891011121314151617//001 创建一个构造函数function Person(name,age,toDoSomeThing) &#123; //002 在构造函数内部设置对象的属性和方法 this.name = name; this.age = age; this.sayName = function () &#123; console.log(this.name); &#125;; this.toDoSomeThing = toDoSomeThing;&#125;//003 使用构造函数创建对象var zhangsan = new Person(\"张三\",18,function () &#123; console.log(\"张三在读书\");&#125;);var lisi = new Person(\"李四\",20,function () &#123; console.log(\"李四在玩耍\");&#125;); 对象类型:01 检查对象的类型：instanceOf02 获取对象的类型：Object.prototype.toString.call(dog) 对象的构造器属性12345function Dog(name) &#123; this.name = name; this.color = \"黄色\"; &#125;console.log(dog.constructor); 属性的名称：constructor属性的作用：指向创建该对象的构造函数，类似于现实生活中所有的产品都标有生产厂家一样。 构造函数的调用01 构造函数可以像普通函数一样不通过new关键字直接调用02 在使用构造函数创建对象的时候，如果没有传递参数，则（）可以省略代码示例:1234567891011//01 创建构造函数function Person() &#123; this.name = \"张三\"; this.age = 20; this.sayName = function () &#123; console.log(this.name); &#125;&#125;//02 使用构造函数创建对象var p1 = new Person();var p2 = new Person; //说明:如果不需要传递参数,则在调用构造函数的时候()可以省略 this指向01 如果使用new 构造函数的方式调用，则this指向内部默认创建出来的空对象02 如果像调用普通函数一样调用构造函数，则this指向全局对象window(不要这样使用) 原型对象原型对象概念 在构造函数创建出来的时候,系统会默认帮构造函数创建并关联的一个新对象 自定义构造函数的原型对象默认是一个空对象。 原型对象的作用 构造函数中的原型对象中的属性和方法可以被使用该构造函数创建出来的对象使用。 即以自定义构造函数方式创建出来的所有对象,自动拥有和共享该构造函数的原型对象中的所有属性和方法。 如何访问构造函数的原型对象① 构造函数.protoType② 对象.__proto__（不推荐） 设置原型对象的属性和方法① 利用对象的动态特性来为构造函数的原型对象添加属性和方法② 替换原型对象 实例和实例化：实例化:通过构造函数创建具体对象的过程。实例:通过构造函数实例化出来的对象,我们称之为该构造函数的一个实例。注意:在说实例的时候,一定要指定是某个具体构造函数的实例。 原型的使用方法① 利用对象的动态特性给原型添加属性|方法，如果要添加的方法过多,则有大量重复代码。② 直接替换原型对象：01 替换前后创建的对象所指向的原型对象不一致02 替换原型对象会切断和之前的原型对象之间的关系 原型对象的使用注意1234567① 访问属性:构造函数创建出来的对象在访问属性的时候,会先在实例内查找,如果没有找到则进一步到对应的原型对象中查找。② 设置属性:在使用点语法进行赋值的时候,无法操作到对应的原型对象,如果该属性在对象中已经存在，则修改该属性的值。如果该属性在对象中尚未存在,则新增该属性。③ 设置原型对象的属性:[01] 设置原型对象的属性,只能通过构造函数.Prototype的方式替换原型对象的方式设置。[02] 如果原型对象的属性是值类型，那么只能通过Person.prototype.属性的方式修改其值。如果原型对象的属性是引用类型,那么可以通过对象名.引用对象.属性名的方式设置修改： (001) 使用构造函数创建出来的多个对象的原型对象中的该属性指向的是同一块数据。 (002) 某个对象对该原型对象属性进行了修改会影响到其他的对象。 __proto__属性说明：__proto__是一个非标准属性,即ECMAScript中并不包含该属性,这只是某些浏览器为了方便开发人员开发和调试而提供的一个属性,不具备通用性。建议:在调试的时候可以使用该属性,但不能出现在正式的代码中。","categories":[{"name":"JavaScript简明教程","slug":"JavaScript简明教程","permalink":"http://www.1oveit.club/categories/JavaScript简明教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.1oveit.club/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"}]},{"title":"JavaScript简明教程（1）","slug":"01","date":"2016-01-15T08:36:35.000Z","updated":"2017-05-13T10:45:13.000Z","comments":true,"path":"2016/01/15/01/","link":"","permalink":"http://www.1oveit.club/2016/01/15/01/","excerpt":"JavaScript与Java没有半毛钱关系，网景公司员工Brendan Eich用了10天时间设计了JavaScript语言。 JavaScript的范围JavaScript的范围：BOM + DOM + ECMAScript BOM简单说明123456BOM即Browser Object Mode,浏览器对象模型。BOM提供了独立于内容而与浏览器窗口进行交互的对象。BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。因为BOM主要用于管理窗口与窗口之间的通信，因此其核心对象是window。BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C。BOM结构体系","text":"JavaScript与Java没有半毛钱关系，网景公司员工Brendan Eich用了10天时间设计了JavaScript语言。 JavaScript的范围JavaScript的范围：BOM + DOM + ECMAScript BOM简单说明123456BOM即Browser Object Mode,浏览器对象模型。BOM提供了独立于内容而与浏览器窗口进行交互的对象。BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。因为BOM主要用于管理窗口与窗口之间的通信，因此其核心对象是window。BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C。BOM结构体系 DOM简单说明12345DOM即Document Object Model，文档对象模型。当网页被加载时，浏览器会创建页面的文档对象模型，即DOM。DOM(文档对象模型)被构造为对象的树。DOM由一系列相关的对象构成，引申为Document对象。DOM的标准化组织是W3C。 ECMAScript简单说明123456789ECMAScript指代JavaScript的核心语法。JavaScript 由 Brendan Eich 发明。JavaScript于1995 年出现在 Netscape 中于 1997 年被 ECMA（一个标准协会）采纳。语法核心：变量基本数据类型对象类型结构(循环|条件|判断)面向对象 javascript语法javascript数据类型基本类型（简单数据类型） * string * number * boolean * undefined * null 复杂类型（复杂数据类型） * Object * Array * Date * RegExp * Function * String * Number * Boolean * null * Math javascript部分操作符的说明一元操作符只能够操作一个值的操作符叫做一元操作符。① 递增和递减操作符:12345678910[01] 前置型,递增和递减操作在包含他们的语句被求值之前就执行。[02] 后置型,递增和递减操作在包含他们的语句被求值之后才执行。var num1 = 2;var num2 = 20;var num3 = --num1 + num2; //21var num4 = num1 + num2; //21var num1 = 2;var num2 = 20;var num3 = num1-- + num2; //22var num4 = num1 + num2; //21 ② 一元加和减操作符:一元加操作符对结果不会有任何的影响。一元减操作符主要用于表示负数。 位操作符01 按位非(NOT):使用 ~ 表示，执行按位非的结果就是返回数值的反码。操作数的负值减去1。123var num1 = 25;var num2 = -num1 - 1; //-26consol.log(~num1) //-26 02 按位与(AND):使用&amp;表示，操作两个操作数。只要有0就为0。03 按位或(OR):使用|表示，操作两个操作数。只要有1就为1。04 按位异或(XOR):使用 ^ 表示，操作两个操作数。相同则为0，不同则为1。05 左移|右移(|有符号|无符号)。 布尔操作符 布尔操作符一共有三个，分别是：非、与、或。 01 逻辑非，符号：！ 说明：取反，可应用于任何值，！！相当于没有操作。02 逻辑与，符号：&amp;&amp; 说明：两个值都为真的时候，结果为真。属于短路操作，如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。03 逻辑或，符号：||说明：两个值只要有一个为真，那么结果为真。属于短路操作，如果第一个操作数为真，那么就不会再对第二个操作数求值了。技巧：可以利用逻辑或短路操作的特点来避免为变量赋null或undefined值。123var myObject = refObject || backupObject;//如果refObject的值不是null,那么它的值将被赋值给myObject//如果是null,那么就将backupObject的值赋值给myObject。 乘性操作符乘 *除 /模 % 加性操作符加 +减 - 说明：上述五种操作符在操作数为非数值的时候内部会执行自动的类型转换。 关系操作符大于 &gt;小于 &lt;小于等于 &lt;=大于等于 &gt;=说明：返回布尔类型的值，要么为false，要么为true。 相等操作符01 相等和不相等[先转换再比较]，符号是 == 和！=比较的规则:[01] 如果操作数中有布尔值，则先转换为数值再比较。[02] 如果是字符串和数值比较，则先将字符串转换为数值再比较。[03] 如果是对象和其他类型的值比较，则先调用对象的valueOf方法，然后用得到的基本类型值去比较。[04] null和undefined是相等的。[05] NaN和NaN不相等。[06] 如果两个操作符都是对象，则比较他们是不是同一个对象，如果指向的是同一个对象则返回true，否则返回false。02 全等和不全等[仅比较不转换],符号是===和!==比较的规则:[01] null和undefined是不全等的，因为它们是不同类型的值。[02] 类型相同，且值相等，则返回true，否则返回false。 条件操作符符号：表达式1 ? 字面量1 ：字面量2说明：如果表达式1的结果为true，则使用字面量1，否则使用字面量2。 赋值操作符符号：=、+=、-=、*=、&lt;&lt;=等等说明：使用赋值操作符对性能而言，没有任何的提升，只是简化了赋值操作而已。 值类型和引用类型01 值类型和引用类型简单说明值类型主要有：12345数值字符串布尔类型undefinednull 引用类型主要有：123对象（Object类型）数组（Array）函数 (Function) 值类型：保存为简单的数据值，赋值只是简单的数据值的复制引用类型:保存为对象，其本质是指向内存位置的引用(地址)，赋值是对地址的复制值类型代码示例1234567var num1 = 10;var num2 = num1; //把num1的值复制一份给num2,num1和num2的值相等,除此之外没有任何其他关系console.log(num1,num2); //10,10console.log(num1 == num2); //truenum2 = 20; //修改num2的值为20,不会对num1产生任何的影响console.log(num1,num2); //10,20console.log(num1 == num2); //false 引用类型代码示例12345678910111213var arr1 = [1,2,3];var arr2 = arr1;console.log(arr1,arr2); //[1,2,3],[1,2,3]console.log(arr1 == arr2); //truevar arr3 = [1,2,3];console.log(arr3); //[1,2,3]console.log(arr1 == arr3,arr2 == arr3); //false,false/** * 代码说明: * arr1和arr2在比较的时候,值相等(都是[1,2,3]),且引用相等(都指向堆中同一块数据),因此arr1和arr2相等 * arr3和arr1以及arr2比较的时候,值相等([1,2,3]),但是引用不相等(arr3指向的是堆中另外一块数据),因此不等 * 总结:引用类型在比较相等的时候,只有值和引用都相等才相等 * */ 02 值类型和引用类型的赋值赋值操作(=):把当前变量存储的值复制一份给接收的变量。值类型的赋值:把当前变量存储的值(具体的数据)复制一份给接收的变量。引用类型的赋值:把当前变量存储的值(具体数据的引用即地址)复制一份给接收的变量。12345678//引用类型使用注意 console.log(arr1,arr2); //[1,2,3],[1,2,3]; console.log(arr1 == arr2); //true arr1.push(4); console.log(arr1,arr2); //[1,2,3,4],[1,2,3,4] /** * 代码说明:因为arr1和arr2内部的引用指向的是同一块数据,所以修改了arr1会对arr2也产生影响 * */ 03 值类型和引用类型作为函数参数处理形参:占位用的参数,用来接收数据的参数而已。实参:实际传递的参数。函数的调用:在函数调用的时候,函数默认会把实参的值赋值给形参。值类型作为参数：在函数内部对形参变量进行修改不会影响到实参的值。引用类型作为参数：在函数内部对形参变量进行修改会影响到实参的值，因为他们的引用指向同一个对象。04 值类型和引用类型的相关图示基本类型的赋值12var str1 = \"hello zhangsan\";var str2 = str1; 引用类型的结构和赋值123456789var car = &#123; color:\"黑色\", number:\"B99\"&#125;;var p1 = &#123; name:\"王宝宝\", age:30, car:car&#125;; 12345var obj1 = &#123; name:\"lisi\", age:18 &#125;; var obj2 = obj1; 对象的动态特性在js中可以动态的对对象属性进行增加、修改和删除；代码示例12345678910111213141516171819//01 创建对象var obj = &#123; name:\"刘德华\", age:60&#125;;//02 动态的为对象添加属性obj.height = \"180cm\";console.log(obj.height);//03 动态的为对象添加方法obj.maiMeng = function () &#123; console.log(\"华仔会卖萌噢\");&#125;;obj.maiMeng();//04 修改属性的值:如果设置的属性以前不存在,那么就是添加,如果设置的属性已经存在了,那么就是修改obj.name = \"王宝强\";console.log(obj.name)//05 删除属性delete obj.name;console.log(obj.name); //undefined 访问对象的方法01 可以使用点语法访问02 可以使用[]语法访问，注意对象的属性必须是字符串 关键字in和delete的使用01 in关键字01 判断属性是否存在于对象中，注意所有的key都是字符串02 for in循环中 遍历对象的 键代码示例12345678910var obj = &#123; name:\"张三\", age:18&#125;;for(k in obj)&#123; console.log(k,obj[k]);&#125;//检测obj对象中是否存在name这个属性console.log(\"name\" in obj); 注意：in关键字操作数组的时候检测的是索引值并非数组元素02 delete关键字01 删除对象的属性02 删除未使用var声明的变量03 返回值为boolean类型，true则表示是否删除成功注意1201 删除的属性如果不存在，返回true02 删除的如果是原型中的属性，返回true 但是删除不成功 循环和分支循环结构1234forwhiledo...whilefor..in 分支结构12if...else..swith..case break和continue对比break:终止循环，循环中后面的代码不再执行continue:结束当前循环，循环后面的代码不再执行，继续下一次循环 调试工具的使用开启调试窗口 windows 平台: f12; Mac: option+command+i;调试窗口介绍 指针: 选择页面中的元素 手机: 使用移动端界面调试 Elements: 查看页面 DOM 树 Console: 控制台(注意, 控制台与该页面是一个整体, 在控制台中的任何操作, 会影响到页面) Source: 代码调试调试工具的使用 逐过程运行, 一次运行一个函数 单步运行(逐步运行), 一次运行一句, 如果是函数, 进入函数体内运行 继续运行. 从当前状态运行下去, 直到出现断点, 如果没有断点则运行结束设置断点技巧 逐步与逐过程混合 断点加继续运行 条件断点(右键添加 add contitional breakpoint)利用 watch 监视窗口可以查看对象成员 异常处理常见的异常分类运行环境的多样性导致的异常（浏览器）语法错误，代码错误异常的特征:一旦代码出现异常，后面的代码就不会再执行异常捕获使用try-catch语句捕获异常123456try&#123; //这里写可能出现异常的代码&#125;catch(e)&#123; //这里的e就是捕获的异常对象 //可以在这里写，出现异常后的处理代码&#125; 异常捕获语句执行的过程为：01 代码正常运行, 如果在try中出现了错误, try 里面出现错误的语句后面的代码都不再执行, 直接跳转到 catch 中02 在catch中处理错误信息03 继续执行后面的代码04 如果 try 中没有出现错误, 那么不走 catch 直接执行后面的代码捕获异常的优点：通过try-catch语句进行异常捕获之后，代码将会继续执行，而不会中断。注意：语法错误异常用try-catch语句无法捕获，因为在预解析阶段，语法错误会直接检测出来，而不会等到运行的时候才报错。try..catch使用示例1234567891011121314151617//01 try ... catch结构的使用//a(); 若直接调用则爆出:Uncaught ReferenceError: a is not defined错误//在开发中,我们对于可能会报错或者是发生异常的代码用try结构进行处理try&#123; a(); //如果发生异常,那么至少不会到正程序中断&#125;catch(e)&#123; //如果try语句中发生了异常,那么会执行此处的代码块 //参数e.为具体的异常信息,可以打印进行查看 console.log(e);&#125;function functionTest() &#123; console.log(\"functionTest\");&#125;;functionTest();//结论:使用try...catch结构,如果发生了异常,那么不会影响后面代码的执行,且我们可以在发生异常信息之后做出具体的处理 手动抛出异常案例：自己写的一个函数，需要一个参数，如果用户不传参数，此时想直接给用户抛出异常，就需要了解如何抛出异常。抛出异常使用throw关键字，语法如下：手动抛出异常信息（字符串）:123456789101112131415try&#123; //a(); //如果发生异常,那么至少不会到正程序中断 //不使用系统默认的异常信息,尝试手动抛出 throw \"对不起,您调用了尚未定义的方法\";&#125;catch(e)&#123; //如果try语句中发生了异常,那么会执行此处的代码块 //参数e.为具体的异常信息,可以打印进行查看 console.log(e);&#125;function functionTest() &#123; console.log(\"functionTest\");&#125;;functionTest(); 手动抛出异常信息（对象）:1234567891011121314151617181920212223try&#123; //a(); //如果发生异常,那么至少不会到正程序中断 //不使用系统默认的异常信息,尝试手动抛出 throw &#123; errMsg:\"具体的错误信息提示\", errCode:\"指定错误类型的代号,如1001等\" &#125;;&#125;catch(e)&#123; //如果try语句中发生了异常,那么会执行此处的代码块 //参数e.为具体的异常信息,可以打印进行查看 console.log(e); //在try语句中抛出的错误信息是什么,那么得到的异常信息就是什么 //如果抛出的是字符串,那么得到的就是字符串 //如果抛出的是对象,那么此处得到的就是对象 console.log(e.errMsg); console.log(e.errCode);&#125;function functionTest() &#123; console.log(\"functionTest\");&#125;;functionTest(); 异常捕获语句的完整模式异常捕获语句的完整模式为try-catch-finally123456789101112131415try&#123; //在执行的时候可能发生异常的代码 b();&#125;catch (e)&#123; //如果try代码块中的代码在执行中发生了异常,那么就会执行该代码块的代码 //通过打印e对象可以查看具体的异常信息 console.log(e); //打印异常信息&#125;finally &#123; //不论try语句中的代码是否会发生异常,都一定会执行此处的代码块 //一般在前端开发中很少使用,常用语后台开发的资源释放工作 console.log(\"无论如何总要执行的代码\");&#125; finally中的代码，不管是否发生异常，都会执行。一般用在后端语言中，用来释放资源，JavaScript中很少会用到。 DOM操作获取元素操作123getElementByIdgetElementsByTagNamegetElementsByClassName 元素节点操作1234567appendChildinsertBeforeremoveChildreplaceChildcloneNodecreateElementcreateTextNode（创建文本节点） 属性节点操作123getAttributesetAttributeremoveAttribute 常用DOM属性1234classNameinnerHTMLinnerText/textContent valuechildren 代码示例12345678910111213141516//0 获取页面中指定的标签,并设置其样式 var divID = document.getElementById(\"divId\"); divID.style.backgroundColor = \"pink\"; divID.style.height = \"40px\"; divID.style.width = \"200px\"; //01 创建新的标签 var div = document.createElement(\"div\"); //02 设置标签的样式 div.style.backgroundColor = \"red\"; div.style.height = \"100px\"; div.style.width = \"300px\"; div.style.fontSize = \"20\"; //03 设置标签的内容 div.innerText = \"这是一个自己创建的标签\"; //04 把标签插入到页面中 document.body.appendChild(div);","categories":[{"name":"JavaScript简明教程","slug":"JavaScript简明教程","permalink":"http://www.1oveit.club/categories/JavaScript简明教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.1oveit.club/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"}]},{"title":"Top 10 ES6 Features","slug":"top10es","date":"2016-01-13T07:41:09.000Z","updated":"2017-05-18T00:48:05.000Z","comments":true,"path":"2016/01/13/top10es/","link":"","permalink":"http://www.1oveit.club/2016/01/13/top10es/","excerpt":"Top 10 ES6 Features Top 10 ES6 Features Every Busy JavaScript Developer Must KnowTop 10 ES6 Features Every Busy JavaScript Developer Must Know 10 ES6 Features Every Busy JavaScript Software Engineer Must Know38 Replies","text":"Top 10 ES6 Features Top 10 ES6 Features Every Busy JavaScript Developer Must KnowTop 10 ES6 Features Every Busy JavaScript Developer Must Know 10 ES6 Features Every Busy JavaScript Software Engineer Must Know38 RepliesThis essay will give you a quick introduction to ES6. If you don’t know what is ES6, it’s a new JavaScript implementation. If you’re a busy JavaScript software engineer (and who is not?), then proceed reading to learn the best 10 features of the new generation of the most popular programming language—JavaScript. Here’s the list of the top 10 best ES6 features for a busy software engineer (in no particular order):12345678910Default Parameters in ES6Template Literals in ES6Multi-line Strings in ES6Destructuring Assignment in ES6Enhanced Object Literals in ES6Arrow Functions in ES6Promises in ES6Block-Scoped Constructs Let and ConstClasses in ES6Modules in ES6 Disclaimer: the list if highly biased and subjective. It is in no way was intended to diminish usefulness of other ES6 features, which didn’t make it to the list simply because I had to limit the number to 10. Default Parameters in ES6Remember we had to do these statements to define default parameters:123456var link = function (height, color, url) &#123; var height = height || 50 var color = color || 'red' var url = url || 'http://azat.co' ...&#125; They were okay until the value was 0 and because 0 is falsy in JavaScript it would default to the hard-coded value instead of becoming the value itself. Of course, who needs 0 as a value (#sarcasmfont), so we just ignored this flaw and used the logic OR anyway… No more! In ES6, we can put the default values right in the signature of the functions:123var link = function(height = 50, color = 'red', url = 'http://azat.co') &#123; ...&#125; By the way, this syntax is similar to Ruby! Template Literals in ES6Template literals or interpolation in other languages is a way to output variables in the string. So in ES5 we had to break the string like this:123456var name = 'Your name is ' + first + ' ' + last + '.'var url = 'http://localhost:3000/api/messages/' + idLuckily, in ES6 we can use a new syntax $&#123;NAME&#125; inside of the back-ticked string:var name = `Your name is $&#123;first&#125; $&#123;last&#125;.`var url = `http://localhost:3000/api/messages/$&#123;id&#125;` Multi-line Strings in ES6Another yummy syntactic sugar is multi-line string. In ES5, we had to use one of these approaches: Sidenote: If you like this post and interested in a corporate on-site JavaScript, Node.js and React.js training to boost productivity of your team, then contact NodeProgram.com.12345var roadPoem = 'Then took the other, as just as fair,\\n\\t' + 'And having perhaps the better claim\\n\\t' + 'Because it was grassy and wanted wear,\\n\\t' + 'Though as for that the passing there\\n\\t' + 'Had worn them really about the same,\\n\\t' var fourAgreements = ‘You have the right to be you.\\n\\ You can only be you when you do your best.’While in ES6, simply utilize the backticks:12345678var roadPoem = `Then took the other, as just as fair, And having perhaps the better claim Because it was grassy and wanted wear, Though as for that the passing there Had worn them really about the same,`var fourAgreements = `You have the right to be you. You can only be you when you do your best.` Destructuring Assignment in ES6Destructuring can be a harder concept to grasp, because there’s some magic going on… let’s say you have simple assignments where keys house and mouse are variables house and mouse: [Sidenote] Reading blog posts is good, but watching video courses is even better because they are more engaging. A lot of developers complained that there is a lack of affordable quality video material on Node. It’s distracting to watch to YouTube videos and insane to pay $500 for a Node video course! Go check out Node University which has FREE video courses on Node: node.university. [End of sidenote]12345678910var data = $('body').data(), // data has properties house and mouse house = data.house, mouse = data.mouseOther examples of destructuring assignments (from Node.js):var jsonMiddleware = require('body-parser').jsonvar body = req.body, // body has username and password username = body.username, password = body.password In ES6, we can replace the ES5 code above with these statements:123456789var &#123; house, mouse&#125; = $('body').data() // we'll get house and mouse variablesvar &#123;jsonMiddleware&#125; = require('body-parser')var &#123;username, password&#125; = req.bodyThis also works with arrays. Crazy!var [col1, col2] = $('.column'), [line1, line2, line3, , line5] = file.split('\\n') It might take some time to get use to the destructuring assignment syntax, but it’s a sweet sugarcoating. Enhanced Object Literals in ES6What you can do with object literals now is mind blowing! We went from a glorified version of JSON in ES5 to something closely resembling classes in ES6. Here’s a typical ES5 object literal with some methods and attributes/properties:12345678910111213var serviceBase = &#123;port: 3000, url: 'azat.co'&#125;, getAccounts = function()&#123;return [1,2,3]&#125;var accountServiceES5 = &#123; port: serviceBase.port, url: serviceBase.url, getAccounts: getAccounts, toString: function() &#123; return JSON.stringify(this.valueOf()) &#125;, getUrl: function() &#123;return \"http://\" + this.url + ':' + this.port&#125;, valueOf_1_2_3: getAccounts()&#125; If we want to be fancy, we can inherit from serviceBase by making it the prototype with the Object.create method:123456789var accountServiceES5ObjectCreate = Object.create(serviceBase)var accountServiceES5ObjectCreate = &#123; getAccounts: getAccounts, toString: function() &#123; return JSON.stringify(this.valueOf()) &#125;, getUrl: function() &#123;return \"http://\" + this.url + ':' + this.port&#125;, valueOf_1_2_3: getAccounts()&#125; I know, accountServiceES5ObjectCreate and accountServiceES5 are NOT totally identical, because one object (accountServiceES5) will have the properties in the proto object as shown below: Enhanced Object Literals in ES6Enhanced Object Literals in ES6 But for the sake of the example, we’ll consider them similar. So in ES6 object literal, there are shorthands for assignment getAccounts: getAccounts, becomes just getAccounts,. Also, we set the prototype right there in the proto` property which makes sense (not‘proto’ though:12345678910111213141516var serviceBase = &#123;port: 3000, url: 'azat.co'&#125;, getAccounts = function()&#123;return [1,2,3]&#125;var accountService = &#123; __proto__: serviceBase, getAccounts,Also, we can invoke super and have dynamic keys (valueOf_1_2_3): toString() &#123; return JSON.stringify((super.valueOf())) &#125;, getUrl() &#123;return \"http://\" + this.url + ':' + this.port&#125;, [ 'valueOf_' + getAccounts().join('_') ]: getAccounts()&#125;;console.log(accountService)Enhanced Object Literals in ES6 IIEnhanced Object Literals in ES6 II This is a great enhancement to good old object literals! Arrow Functions in ES6This is probably one feature I waited the most. I love CoffeeScript for its fat arrows. Now we have them in ES6. The fat arrows are amazing because they would make your this behave properly, i.e., this will have the same value as in the context of the function—it won’t mutate. The mutation typically happens each time you create a closure. Using arrows functions in ES6 allows us to stop using that = this or self = this or _this = this or .bind(this). For example, this code in ES5 is ugly:12345678910var _this = this$('.btn').click(function(event)&#123; _this.sendData()&#125;)This is the ES6 code without _this = this:$('.btn').click((event) =&gt;&#123; this.sendData()&#125;) Sadly, the ES6 committee decided that having skinny arrows is too much of a good thing for us and they left us with a verbose old function instead. (Skinny arrow in CoffeeScript works like regular function in ES5 and ES6). Here’s another example in which we use call to pass the context to the logUpperCase() function in ES5:12345678var logUpperCase = function() &#123; var _this = this this.string = this.string.toUpperCase() return function () &#123; return console.log(_this.string) &#125;&#125; logUpperCase.call({ string: ‘es6 rocks’ })()While in ES6, we don’t need to mess around with _this:123456var logUpperCase = function() &#123; this.string = this.string.toUpperCase() return () =&gt; console.log(this.string)&#125;logUpperCase.call(&#123; string: 'es6 rocks' &#125;)() Note that you can mix and match old function with =&gt; in ES6 as you see fit. And when an arrow function is used with one line statement, it becomes an expression, i.e,. it will implicitly return the result of that single statement. If you have more than one line, then you’ll need to use return explicitly. This ES5 code is creating an array from the messages array:1234var ids = ['5632953c4e345e145fdf2df8','563295464e345e145fdf2df9']var messages = ids.map(function (value) &#123; return \"ID is \" + value // explicit return&#125;); Will become this in ES6:12var ids = ['5632953c4e345e145fdf2df8','563295464e345e145fdf2df9']var messages = ids.map(value =&gt; `ID is $&#123;value&#125;`) // implicit return Notice that I used the string templates? Another feature from CoffeeScript… I love them! The parenthesis () are optional for single params in an arrow function signature. You need them when you use more than one param. In ES5 the code has function with explicit return:1234var ids = ['5632953c4e345e145fdf2df8', '563295464e345e145fdf2df9'];var messages = ids.map(function (value, index, list) &#123; return 'ID of ' + index + ' element is ' + value + ' ' // explicit return&#125;); And more eloquent version of the code in ES6 with parenthesis around params and implicit return:12var ids = ['5632953c4e345e145fdf2df8','563295464e345e145fdf2df9']var messages = ids.map((value, index, list) =&gt; `ID of $&#123;index&#125; element is $&#123;value&#125; `) // implicit return Promises in ES6Promises have been a controversial topic. There were a lot of promise implementations with slightly different syntax. q, bluebird, deferred.js, vow, avow, jquery deferred to name just a few. Others said we don’t need promises and can just use async, generators, callbacks, etc. Gladly, there’s a standard Promise implementation in ES6 now! Let’s consider a rather trivial example of a delayed asynchronous execution with setTimeout():123setTimeout(function()&#123; console.log('Yay!')&#125;, 1000) We can re-write the code in ES6 with Promise:12345var wait1000 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 1000)&#125;).then(function() &#123; console.log('Yay!')&#125;) Or with ES6 arrow functions:12345var wait1000 = new Promise((resolve, reject)=&gt; &#123; setTimeout(resolve, 1000)&#125;).then(()=&gt; &#123; console.log('Yay!')&#125;) So far, we’ve increased the number of lines of code from three to five without any obvious benefit. That’s right. The benefit will come if we have more nested logic inside of the setTimeout() callback:123456setTimeout(function()&#123; console.log('Yay!') setTimeout(function()&#123; console.log('Wheeyee!') &#125;, 1000)&#125;, 1000) Can be re-written with ES6 promises:12345678910var wait1000 = ()=&gt; new Promise((resolve, reject)=&gt; &#123;setTimeout(resolve, 1000)&#125;)wait1000() .then(function() &#123; console.log('Yay!') return wait1000() &#125;) .then(function() &#123; console.log('Wheeyee!') &#125;); Still not convinced that Promises are better than regular callbacks? Me neither. I think once you got the idea of callbacks and wrap your head around them, then there’s no need for additional complexity of promises. Nevertheless, ES6 has Promises for those of you who adore them. Promises have a fail-and-catch-all callback as well which is a nice feature. Take a look at this post for more info on promises: Introduction to ES6 Promises. Block-Scoped Constructs Let and ConstYou might have already seen the weird sounding let in ES6 code. I remember the first time I was in London, I was confused by all those TO LET signs. The ES6 let has nothing to do with renting. This is not a sugarcoating feature. It’s more intricate. let is a new var which allows to scope the variable to the blocks. We define blocks by the curly braces. In ES5, the blocks did NOTHING to the vars:123456789101112131415function calculateTotalAmount (vip) &#123; var amount = 0 if (vip) &#123; var amount = 1 &#125; &#123; // more crazy blocks! var amount = 100 &#123; var amount = 1000 &#125; &#125; return amount&#125;console.log(calculateTotalAmount(true)) The result will be 1000. Wow! That’s a really bad bug. In ES6, we use let to restrict the scope to the blocks. Vars are function scoped.123456789101112131415function calculateTotalAmount (vip) &#123; var amount = 0 // probably should also be let, but you can mix var and let if (vip) &#123; let amount = 1 // first amount is still 0 &#125; &#123; // more crazy blocks! let amount = 100 // first amount is still 0 &#123; let amount = 1000 // first amount is still 0 &#125; &#125; return amount&#125;console.log(calculateTotalAmount(true)) The value is 0, because the if block also has let. If it had nothing (amount=1), then the expression would have been 1. When it comes to const, things are easier; it’s just an immutable, and it’s also block-scoped like let. Just to demonstrate, here are a bunch of constants and they all are okay because they belong to different blocks:123456789101112131415function calculateTotalAmount (vip) &#123; const amount = 0 if (vip) &#123; const amount = 1 &#125; &#123; // more crazy blocks! const amount = 100 &#123; const amount = 1000 &#125; &#125; return amount&#125;console.log(calculateTotalAmount(true)) In my humble opinion, let and const overcomplicate the language. Without them we had only one behavior, now there are multiple scenarios to consider. ;-( Classes in ES6If you love object-oriented programming (OOP), then you’ll love this feature. It makes writing classes and inheriting from them as easy as liking a comment on Facebook. Classes creation and usage in ES5 was a pain in the rear, because there wasn’t a keyword class (it was reserved but did nothing). In addition to that, lots of inheritance patterns like pseudo classical, classical, functional just added to the confusion, pouring gasoline on the fire of religious JavaScript wars. I won’t show you how to write a class (yes, yes, there are classes, objects inherit from objects) in ES5, because there are many flavors. Let’s take a look at the ES6 example right away. I can tell you that the ES6 class will use prototypes, not the function factory approach. We have a class baseModel in which we can define a constructor and a getName() method:123456789101112class baseModel &#123; constructor(options = &#123;&#125;, data = []) &#123; // class constructor this.name = 'Base' this.url = 'http://azat.co/api' this.data = data this.options = options &#125; getName() &#123; // class method console.log(`Class name: $&#123;this.name&#125;`) &#125;&#125; Notice that I’m using default parameter values for options and data. Also, method names don’t need to have the word function or the colon (:) anymore. The other big difference is that you can’t assign properties this.NAME the same way as methods, i.e., you can’t say name at the same indentation level as a method. To set the value of a property, simply assign a value in the constructor. The AccountModel inherits from baseModel with class NAME extends PARENT_NAME:12345678class AccountModel extends baseModel &#123; constructor(options, data) &#123;To call the parent constructor, effortlessly invoke super() with params: super(&#123;private: true&#125;, ['32113123123', '524214691']) //call the parent method with super this.name = 'Account Model' this.url +='/accounts/' &#125; If you want to be really fancy, you can set up a getter like this and accountsData will be a property:12345 get accountsData() &#123; //calculated attribute getter // ... make XHR return this.data &#125;&#125; So how do you actually use this abracadabra? It’s as easy as tricking a three-year old into thinking Santa Claus is real:123let accounts = new AccountModel(5)accounts.getName()console.log('Data is %s', accounts.accountsData) In case you’re wondering, the output is:12Class name: Account ModelData is %s 32113123123,524214691 Modules in ES6As you might now, there were no native modules support in JavaScript before ES6. People came up with AMD, RequireJS, CommonJS and other workarounds. Now there are modules with import and export operands. In ES5 you would use &lt;script&gt; tags with IIFE, or some library like AMD, while in ES6 you can expose your class with export. I am a Node.js guy, so I’ll use CommonJS which is also a Node.js syntax. It’s straightforward to use CommonJS on the browser with the Browserify bunder. Let’s say we have port variable and getAccounts method in ES5 module.js:123456module.exports = &#123; port: 3000, getAccounts: function() &#123; ... &#125;&#125; In ES5 main.js, we would require(‘module’) that dependency:12var service = require('module.js')console.log(service.port) // 3000 In ES6, we would use export and import. For example, this is our library in the ES6 module.js file:1234export var port = 3000export function getAccounts(url) &#123; ...&#125; In the importer ES6 file main.js, we use import {name} from ‘my-module’ syntax. For example,123456import &#123;port, getAccounts&#125; from 'module'console.log(port) // 3000Or we can import everything as a variable service in main.js:import * as service from 'module'console.log(service.port) // 3000 Personally, I find the ES6 modules confusing. Yes, they are more eloquent, but Node.js modules won’t change anytime soon. It’s better to have only one style for browser and server JavaScript, so I’ll stick with CommonJS/Node.js style for now. The support for ES6 modules in the browsers are not coming anytime soon (as of this writing), so you’ll need something like jspm to use ES6 modules. For more information and examples on ES6 modules, take a look at this text. No matter what, write modular JavaScript! How to Use ES6 Today (Babel) ES6 is finalized, but not fully supported by all browsers (e.g., ES6 Firefox support). To use ES6 today, get a compiler like Babel. You can run it as a standalone tool or use with your build system. There are Babel plugins for Grunt, Gulp and Webpack. How to Use ES6 Today (Babel)How to Use ES6 Today (Babel) Here’s a Gulp example. Install the plugin: $ npm install –save-dev gulp-babelIn gulpfile.js, define a task build that takes src/app.js and compiles it into the build folder:12345678var gulp = require('gulp'), babel = require('gulp-babel')gulp.task('build', function () &#123; return gulp.src('src/app.js') .pipe(babel()) .pipe(gulp.dest('build'))&#125;) Node.js and ES6 For Node.js, you can compile your Node.js files with a build tool or use a standalone Babel module babel-core. To install it, $ npm install –save-dev babel-coreThen in Node.js, you call this function: require(“babel-core”).transform(es5Code, options)Summary of ES6 Things There are many other noteworthy ES6 features which you probably won’t use (at least not right away). In no particular order: New Math, Number, String, Array and Object methodsBinary and octal number typesDefault rest spreadFor of comprehensions (hello again mighty CoffeeScript!)SymbolsTail callsGeneratorsNew data structures like Map and SetFor overachievers who can’t stop learning about ES6, like some people who can’t stop after the first potato chip (just one more!), here’s the list for further reading:Top 10 ES6 Features Every Busy JavaScript Developer Must Know","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://www.1oveit.club/tags/css/"},{"name":"js","slug":"js","permalink":"http://www.1oveit.club/tags/js/"}]},{"title":"固定导航，不做抖man","slug":"解决页面抖动","date":"2016-01-10T16:17:25.000Z","updated":"2017-05-16T16:44:00.000Z","comments":true,"path":"2016/01/11/解决页面抖动/","link":"","permalink":"http://www.1oveit.club/2016/01/11/解决页面抖动/","excerpt":"如何hold住导航？ 页面结构假设一个网页由Header,Nav,Main三部分构成。","text":"如何hold住导航？ 页面结构假设一个网页由Header,Nav,Main三部分构成。1234567891011Header(Logo, other information)----------------------------------------------Nav(Nav,menu,links)----------------------------------------------Main(Container, Content)----------------------------------------------- 解决方法根据需求，当大于Header的高度时，固定住导航。当我们滚动滚轮时候，此时 Header 会被 Nav 所遮住，再往下面滚动时Nav会固定在顶部。最常规的解决方法,让Header固定定位，Nav上边距为Header的高度：123Header：position: fixedNav: margin-top: A.height 设置滚动事件：12345if (scrollTop &gt; Header.height) &#123; Nav: position: fixed&#125; else &#123; Nav: position: initial&#125; 这样做会所产生的问题： 当 Header fixed 后，页面高度由 Header + Nav + Main 变为 Header + Main，导致 Main 自动上移了 Nav.height，从而使 scrollTop 变小。这样根据滚动事件将执行 Nav: position: initial，用鼠标慢慢拖动时，Nav 会进行多次抖动（fixed-&gt;initial-&gt;fixed-&gt;initial-&gt;……）。 解决的方法如下： 使 Header fixed 后，页面高度依旧为 Header + Nav + Main。 Header: margin-top: A.height Nav-wrap： height: Nav.height 为了使用户产生 Header fixed 后的视觉动感，可设置 scrollTop &gt; Header.height + Nav.height / 3","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://www.1oveit.club/tags/css/"},{"name":"js","slug":"js","permalink":"http://www.1oveit.club/tags/js/"}]},{"title":"JSONP跨域","slug":"JSONP跨域","date":"2016-01-07T16:55:40.000Z","updated":"2017-05-09T04:50:22.000Z","comments":true,"path":"2016/01/08/JSONP跨域/","link":"","permalink":"http://www.1oveit.club/2016/01/08/JSONP跨域/","excerpt":"Asynchronous JavaScript and XML (Ajax) 是Web2.0的关键技术。AJAX与服务器交换数据刷新局部网页,不需重载。 因为浏览器及同源策略的限制，ajax不允许跨域通信。同源是指协议、域名和端口都一致的情况。同源策略保证一个源的动态脚本不能读取或操作其他源的http响应和cookie，使浏览器隔离不同源的内容之间互相操作。","text":"Asynchronous JavaScript and XML (Ajax) 是Web2.0的关键技术。AJAX与服务器交换数据刷新局部网页,不需重载。 因为浏览器及同源策略的限制，ajax不允许跨域通信。同源是指协议、域名和端口都一致的情况。同源策略保证一个源的动态脚本不能读取或操作其他源的http响应和cookie，使浏览器隔离不同源的内容之间互相操作。 Access-Control-Allow-Origin解决跨域问题可以在第三方网站开启HTTP的Access-Control-Allow-Origin参数，当目标页面的response包含Access-Control-Allow-Origin 这个header，而且还包含我们的域名时，浏览器就允许拿到它页面的数据：1Access-Control-Allow-Origin: http://www.1oveit.club 当值为 * 表示匹配所有，都能用：1Access-Control-Allow-Origin: * 但是此时的主动权不在我们手里。 JSONP解决跨域还可以使用更为主动的方法，使用JSONP解决跨域问题。分为以下几步：我们知道多个不同的script标签中的数据是可以相互访问的，而script的src的本质就是将导入文件中的内容拷贝到当前script标签中，我们拿到百度搜索URL地址：1https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=ab&amp;cb=jQuery11020672211218553074_1491468814655 搜索之后的结果：1jQuery11020672211218553074_1491468814655(&#123;q:&quot;ab&quot;,p:false,s:[&quot;abs&quot;,&quot;ab胶&quot;,&quot;abc&quot;,&quot;abac形式的成语&quot;,&quot;abcc形式的成语&quot;,&quot;abab式的词语&quot;,&quot;abo&quot;,&quot;abp&quot;,&quot;abstract&quot;,&quot;abs塑料&quot;]&#125;); 从而可以引出跨域(jsonP)原理：1.src可以拿到非当前域的数据。2.script的src的本质就是将导入文件中的内容拷贝到当前script标签中。3.如果src返回的数据符合 函数名称(参数); 格式, 那么就可以实现跨域。具体例子：在本地的文件的script准备回调函数say,123function say(obj) &#123; console.log(obj); &#125; 通过script的src属性拿到百度要搜索的URL并且拼接?wd=ab&amp;cb=say参数，如下：1&lt;script src=&quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=ab&amp;cb=say&quot;&gt;&lt;/script&gt; 最后，调用say方法，1say(&#123;q:&quot;ab&quot;,p:false,s:[&quot;abs&quot;,&quot;ab胶&quot;,&quot;abc&quot;,&quot;abac形式的成语&quot;,&quot;abcc形式的成语&quot;,&quot;abab式的词语&quot;,&quot;abo&quot;,&quot;abp&quot;,&quot;abstract&quot;,&quot;abs塑料&quot;]&#125;); 具体例子： //1.使用src，请求数据 &lt;script src=\"http://datainfo.duapp.com/shopdata/getGoods.php?callback=callback\"&gt; //2.在本地声明一个方法 function callback(args) { console.log(args); } //3.要在服务端要处理跨域 $res = $_GET['callback']; echo $res.\"('我是服务的数据')\"; function callback(args) { console.log(args); } &lt;/script&gt; &lt;!-- 如果服务器返回的是js代码，那么浏览器就会直接执行js代码 借助浏览器的特性来实现跨域 --&gt; &lt;script src=\"http://datainfo.duapp.com/shopdata/getGoods.php?call6‘back=callback\"&gt;&lt;/script&gt; 总体的流程大概就是这样子，不过实际开发中要与后台定好接口，希望能够帮到你。","categories":[],"tags":[{"name":"JSONP跨域","slug":"JSONP跨域","permalink":"http://www.1oveit.club/tags/JSONP跨域/"}]},{"title":"可能是最简单的js原型继承","slug":"js原型继承","date":"2015-12-08T07:35:45.000Z","updated":"2017-05-11T17:01:18.000Z","comments":true,"path":"2015/12/08/js原型继承/","link":"","permalink":"http://www.1oveit.club/2015/12/08/js原型继承/","excerpt":"JavaScript是一门奇妙的弱类型语言，原型继承与其它语言的类继承有所区别，下面通过一个简单的例子展示js的原型继承。 你有对象吗？你有对象吗？没有，赶紧就new一个吧！首先，创建构造函数Parent然后，new出一个Parent的实例对象child此时，构造函数Parent拥有以下属性aString、aNumber、anObject,构造函数Parent的原型对象有aFunction方法。","text":"JavaScript是一门奇妙的弱类型语言，原型继承与其它语言的类继承有所区别，下面通过一个简单的例子展示js的原型继承。 你有对象吗？你有对象吗？没有，赶紧就new一个吧！首先，创建构造函数Parent然后，new出一个Parent的实例对象child此时，构造函数Parent拥有以下属性aString、aNumber、anObject,构造函数Parent的原型对象有aFunction方法。12345678910function Parent() &#123; this.aString = 'string'; this.aNumber = 'number'; this.anObject = 'object'&#125;Parent.prototype = &#123; constructor: Parent, aFunction: function()&#123; alert('i am function'); &#125; 然后，new出一个Parent的实例对象child1var child = new Parent(); 简单的原型继承图如下： #~~~~# 实现继承实例对象默认拥有构造函数本身的属性和方法。但是，要知道构造函数荷构造函数的原型对象是俩个不同的函数（对象），原型对象拥有的属性和方法可以被实例化对象所共享。也就是说实例对象child此时拥有属性aString、aNumber、anObject，this指向实例对象。child本身并没有aFunction方法。但是你调用此方法时，却发现能调用，这是怎么回事呢？1child.aFunction(); 这就是我们所说的原型对象原拥有的属性和方法可以被实例化对象所共享的原因。通过简单的例子，希望能帮到你，如果想深入学习javascript，请深戳MDZ开发者","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.1oveit.club/tags/javascript/"},{"name":"原型继承机制","slug":"原型继承机制","permalink":"http://www.1oveit.club/tags/原型继承机制/"}]},{"title":"有趣的Chrome DevTools","slug":"有趣的ChromeDevTools","date":"2015-11-11T13:46:45.000Z","updated":"2017-05-11T16:59:40.000Z","comments":true,"path":"2015/11/11/有趣的ChromeDevTools/","link":"","permalink":"http://www.1oveit.club/2015/11/11/有趣的ChromeDevTools/","excerpt":"Chrome 自带开发者工具很有趣，怎么个有趣法呢？Chrome的JS控制台有很多很多神奇而且有趣的功能。此文仅例举其中几个，一起来看看吧。 我们调试的时候控制台总会有一大堆密密麻麻的代码时，请试着输入 clear() 然后回车，清空所有，回到原始界面。","text":"Chrome 自带开发者工具很有趣，怎么个有趣法呢？Chrome的JS控制台有很多很多神奇而且有趣的功能。此文仅例举其中几个，一起来看看吧。 我们调试的时候控制台总会有一大堆密密麻麻的代码时，请试着输入 clear() 然后回车，清空所有，回到原始界面。 jq选择器第一个有趣的事情就是获取页面上的DOM元素啦！在控制台里通过jQuery选择器选取DOM元素. 如 $(&#39;tagName&#39;) $(&#39;.class&#39;) $(&#39;#id&#39;)等选择器。其实是通过document.querySelector(‘’)返回第一个匹配的DOM元素。通过 $$(&#39;tagName&#39;) $$(&#39;.className&#39;)两个$$符号来选择返回的一个相应的DOM数组。瞧： 获取DOM元素绑定事件其实也是一句代码搞定的事情，但是在调试的时候却非常有用。通过在控制台输入getEventListeners($(&#39;selector&#39;))返回数组对象的格式并且返回元素绑定的所有事件。然后通过getEventListeners($(&#39;selector&#39;)).click[0].listener获取元素绑定的click事件。 Chrome编辑器如果浏览器可以编辑，要记得导出喔。在控制台轻轻输入一句代码，然后试着编辑页面，接下来就是奇迹发生的时候！赶快试一下吧！ 监测事件通过输入monitorEvents($(&#39;selector&#39;)) 监测元素上绑定的所有事件，该元素某个事件被触发就会在控制台里显示出来。monitorEvents($(&#39;selector&#39;),&#39;eventName&#39;)监听元素上绑定的具体事件。第二个参数代表事件类型的名称。monitorEvents($(&#39;selector&#39;),[&#39;eventName1&#39;,&#39;eventName3&#39;,….])同时检测具体指定的多个事件类型。unmonitorEvents($(&#39;selector&#39;)) 用来停止对某个元素的事件监测。 表格形式输出数组先输入数组arr,然后通过输入console.table(variableName)以表格形式查看，如下图： 检查元素你可以直接在控制台里输入下面的方法来检查元素inspect($(&#39;selector&#39;)) 会检查所有匹配选择器的DOM元素，并返回所有选择器选择的DOM对象。inspect($(&#39;img&#39;)[1]) 检查并返回页面上第2个img元素。最后，Chrome DevTools是十分强大的调试工具，这只是冰上一角，深入了解请戳chrome-devtools","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.1oveit.club/tags/javascript/"},{"name":"Chrome DevTools","slug":"Chrome-DevTools","permalink":"http://www.1oveit.club/tags/Chrome-DevTools/"}]},{"title":"HTML简明教程（1）","slug":"HTML简明教程","date":"2015-10-18T15:45:46.000Z","updated":"2017-05-18T17:15:48.000Z","comments":true,"path":"2015/10/18/HTML简明教程/","link":"","permalink":"http://www.1oveit.club/2015/10/18/HTML简明教程/","excerpt":"简单的概念，简洁明了。 常识1.什么是浏览器？功能：（1）将网页渲染出来让用户查看（2）并让用户与网页交互的一种软件主流浏览器：IE（内核：Trident） 火狐（内核：Gecko） 谷歌（内核：Webkit/Blink） Safari（内核：Webkit） 欧朋（内核：Presto）因为内核不同，所以渲染的网页有所不同","text":"简单的概念，简洁明了。 常识1.什么是浏览器？功能：（1）将网页渲染出来让用户查看（2）并让用户与网页交互的一种软件主流浏览器：IE（内核：Trident） 火狐（内核：Gecko） 谷歌（内核：Webkit/Blink） Safari（内核：Webkit） 欧朋（内核：Presto）因为内核不同，所以渲染的网页有所不同2.什么是服务器？超级计算机，24小时不断电不关机，专门用于存储数据 3.什么是URL?我们在浏览器的地址栏输入的就是URL，eg：http://127.0.0.1:80/index.htmlhttp:// URL协议类型127.0.0.1 服务器IP地址:80 服务器的端口号/index.html 需要访问的资源名称 HTML基础1.HTML（超文本标记语言）作用：专门用来描述文本语义的，也就是说告诉浏览器哪些是标题哪些是段落。注意事项：HTML作用只有一个专门给文本添加语义的，不是用来修改文本样式的。&lt;h1&gt;标签的作用是告诉浏览器哪些文字是标题，即给指定文字添加标题语义的.html是纯文本文件 2.乱码问题：（1）基本上都保存为UTF-8:&lt;meta charset=”UTF-8”&gt;（2）保存网页的字符集和网页中指定的字符集设置为一致 3.DTD文档声明：不是HTML标签，必须在第一行，不区分大小&lt;!DOCTYPE html&gt;：HTML5的DTD文档声明是上下兼容的 HTML标签1.标签分类：（1） 双标签1&lt;html&gt;&lt;/html&gt; &lt;title&gt;&lt;/title&gt; &lt;body&gt;&lt;/body&gt;…… 单标签 `&lt;meta&gt; &lt;br&gt;……` （2） 兄弟关系 &lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;嵌套关系 &lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt; 2.&lt;hn&gt;标签：&lt;h1&gt;~&lt;h6&gt; 注意点：（1）H标签是用来给文本添加标题语义的（2）被H系列标签包裹的内容会独占一行（3）在企业开发中一般情况下一个界面只能出现一个H1标签 3.&lt;p&gt;标签：作用：告诉浏览器哪些文字是一个段落注意点：在浏览器中会独占一行 4．&lt;hr&gt;标签：分割线 注意点：在浏览器中会独占一行 5.img标签 （1）格式：&lt;img src=””alt=””title=”” &gt; （2）注意点： 如果我们不指定img标签的宽度和高度，那么系统按照默认图片宽度和高度，如果我们手动指定了Img标签的宽度和高度，有可能导致图片变形。 如果想指定img标签的宽度和高度，又不想图片变形，我们只能只指定宽度或高度其中一个 （3）常用属性： src：用来显示图片的路径 title：用来告诉浏览器，当鼠标悬停在图片上时，需要弹出的描述框中显示什么内容 alt:当需要显示的图片找不到的时候显示什么内容 6.&lt;br&gt;：用于换行 注意点： 多个br标签可以同时使用由于HTML是用于给文本添加语义的，而br标签的语义不是另起一个段落，所以在企业开发中很少使用它 7.路径问题 给src属性赋值有两种方式： （1）相对路径:每次都是从.html文件所在的文件夹开始查找 同级：图片和.html文件存储在同一个文件夹中，格式：src=”xxx.xxx” 下级：存储图片的文件夹和.html文件在同一个文件夹中，格式：src=”xxx/xxx.xxx” 上级：存储图片的位置和存储代码的文件夹在同一个文件夹中，格式：src=”../xxx.xxx” （2）绝对路径:每次都是从指定的盘符开始查找 注意点： 企业开发中如果需要编写路径，统一使用反斜杠/ 企业开发中一般不使用绝对路径，因为可移植性不好 8.a标签：用于控制页面与页面之间的跳转 （1）格式：&lt;a href=””&gt;&lt;/a&gt; （2）注意点： a标签不仅可以让文字可以点击，也可以让图片能够被点击 a标签必须有一个href属性 如果通过a标签的href属性指定一个URL地址，那么必须在地址前加上http://或https:// a标签的href属性除了可以指定一个网址，还可以指定一个本地地址 （3）常用属性： target（跳转方式）：_self:在当前选项卡中跳转，默认。_blank:在新的选项卡中跳转 title：用来告诉浏览器，当鼠标悬停在链接上时，需要弹出的描述框中显示什么内容 （4）假链接：点击之后不会跳转，企业开发前期，其他页面都没有写出来，就用假链接来代替 格式：&lt;a href=”#”&gt;会自动回到网页顶部 &lt;a href=”javascript”&gt;不会自动回到网页顶部 9.base标签：专门用来统一的指定当前网页中所有的超链接需要如何打开 格式：&lt;base target=””&gt; 注意点：如果base和a标签同时指定了打开方式，网页的打开方式由a标签决定 10.锚点： (1)要想通过a标签跳转到当前界面的指定位置，那么必须告诉a标签一个独一无二的id，这样才能在当前界面找到需要跳转到的目标位置 格式： 1234&lt;a href=”zhongbu”&gt;&lt;h2&gt;我是顶部&lt;/h2&gt;&lt;/a&gt; &lt;h2 id=”zhongbu”&gt;我是中部&lt;/h2&gt; &lt;a href=”dibu”&gt; 跳转到底部&lt;/a&gt; &lt;h2 id=”dibu”&gt;我是底部&lt;/h2&gt; (2)想通过a标签跳转到其他界面的指定位置 格式： 12&lt;a href=”新界面的网址#123”&gt;跳转到xxx&lt;/a&gt;&lt;h2 id=”123”&gt;欢迎来到这里&lt;/h2&gt; 11.列表标签（1）无需列表：ul 作用：给一堆数据添加列表语义，并且这一堆数据没有先后之分 格式：&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 应用场景：新闻列表 商品列表 导航条（2）有序列表：ol 作用：给一堆数据添加列表语义，并且这一堆数据有先后之分 格式：&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;（3）定义列表：dl 作用：给一堆数据添加列表语义，先通过dt标签定义列表中的所有标题，然后在通过dd标签给标题添加描述信息 格式：&lt;dl&gt;&lt;dt&gt;&lt;/dt&gt;&lt;dd&gt;&lt;/dd&gt;&lt;/dl&gt;dt:定义列表的标题 dd:描述标题对应的含义 应用场景：网页的导航条 做网站尾部的相关信息 做图文混排 12.表格标签：&lt;table&gt;&lt;/table&gt; （1）作用：给一堆数据添加表格语义 （2）格式： &lt;table&gt;&lt;caption&gt;&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; tr：表示一行 td:表示一行的一个单元格 th：专门用来存储每一列的标题，内容会自动加粗居中 caption:专门用来指定表格标题 （3）注意点：表格边框属性border默认为0 常用属性：（1）宽度和高度（table、td） 表格默认宽高度是根据内容的尺寸调整的，也可以通过table标签设置width/height属性来手动设置； 如果给td标签设置width/height属性，只会改变单元格的宽度和高度，不会影响整个表格的宽度和高度 （2）水平对齐（table、td、tr） 给table标签设置align属性，可以控制表格在水平方向的对齐方式； 给tr标签设置align属性，可以控制当前行中的所有单元格的水平方向对齐方式； 给td标签设置align属性，可以控制当前行中的单元格内容的水平方向对齐方式； 注意点：如果同时给tr、td设置align属性，那么单元格中的内容会安照td的设置来对齐 （3）垂直对齐（td、tr） 给tr标签设置设置valign属性,可以控制当前行中的所有单元格的垂直方向对齐方式； 给td标签设置设置valign属性,可以控制当前行的单元格内容的垂直方向对齐方式 注意点：如果同时给tr、td设置valign属性，那么单元格中的内容会安照td的设置来对齐 （4）外边距：单元格与单元格之间的距离，默认情况下cellspacing=2px（5）内边距:单元格的边框与内容之间的间隙，默认情况下cellpadding=1px（6）水平方向上的单元格合并：（行上的单元格合并），给td标签设置一个colspan属性，来指定把一个单元格当作多个单元格（7）垂直方向上的单元格合并：（列上的单元格合并），给td标签设置一个rowspan属性,来指定把一个单元格当作多个单元格 细线表格制作方式：123456789&lt;table bgcolor=\"black\" cellspacing=\"1px\" &gt; &lt;tr bgcolor=\"white\" &gt; &lt;td&gt;1.1&lt;/td&gt; &lt;td&gt;1.2&lt;/td&gt; &lt;/tr&gt; &lt;tr bgcolor=\"white\" &gt; &lt;td&gt;2.1&lt;/td&gt; &lt;td&gt;2.2&lt;/td&gt; &lt;/tr&gt; 表格完整格式：（仅作了解）123456789101112131415161718&lt;table&gt; &lt;caption&gt;&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 13.表单标签：（1）作用：表单是专门用来收集用户信息的表单标签比较特殊，在浏览器中有自己默认的外观和功能。（2）格式： &lt;from&gt;&lt;表单元素&gt;&lt;/from&gt;（3）常见表单元素： input标签（默认有边框）：它有一个type属性，这个属性有很多类型的取值，取值的不同决定了input标签的功能和外观，除了按钮类型的input标签以外，其他标签都可以通过value属性来指定将来提交到服务器的值 《1》&lt;input type=”text”&gt;明文输入框 《2》&lt;input type=”password”&gt;暗文输入框 《3》&lt;input type=”radio”&gt;单选框注意点：默认单选框不会互斥，要想选框互斥，要给每个单选框标签设置一个name属性，并且属性值必须相同。要想让单选框默认选中其中一个，那么就给他添加一个checked属性 《4》&lt;input type=”checkbox”&gt;多选框注意点：默认可以选择多个，要想让单选框默认选中其中一个，那么就给他添加一个checked属性 《5》 按钮 普通按钮：&lt;input type=”button”value=”按钮”&gt;，通过value属性给按钮添加标题 图片按钮：&lt;input type=”img”src=””&gt;，作用与普通按钮一样 重置按钮：&lt;input type=”reset”&gt;，用于清空表单填写的内容 注意点：默认按钮标题是重置，可以通过value属性修改按钮标题 提交按钮：&lt;input type=”submit”&gt;，将表单中填写好的内容提交到远程服务器注意点：要想把表单中填写的内容提交给远程服务器中，需要做到以下两点：&lt;form action=”网址”&gt;&lt;/form&gt;；给需要提交的表单元素都添加name属性 《6》隐藏域：&lt;input type=”hidden”&gt;配合提交按钮将一些数据默默的提交到远程服务器 label标签：默认情况下，文字与输入框是没有关联关系的，也就是说点击文字输入框不会聚焦，如果想聚焦，需要这样：方法一：&lt;label for=”一样”&gt;文字:&lt;/label&gt;&lt;input type=”” id=”一样”&gt;方法二：&lt;labrl&gt;文字：&lt;input type=””&gt;&lt;/label&gt;局限性是不能交叉绑定datalist标签：给输入框绑定待选项（了解）格式：123456&lt;input type=\"text\" list=\"cities\"&gt;&lt;datalist id=”cities”&gt;&lt;option&gt;待选项内容&lt;/option&gt;&lt;option&gt;待选项内容&lt;/option&gt;&lt;option&gt;待选项内容&lt;/option&gt;&lt;/datalist&gt; select标签：用于定义下拉列表格式：12345&lt;select&gt;&lt;option&gt;列表数据&lt;/option&gt;&lt;option&gt;列表数据&lt;/option&gt;&lt;option&gt;列表数据&lt;/option&gt;&lt;/select&gt; 注意点：下拉列表不能输入内容，但是可以选择内容。也可以设置默认值：&lt;option selected=&quot;selected&quot;&gt;列表数据&lt;/option&gt;给下拉列表分类：123&lt;optgroup label=\"分组名称\"&gt;&lt;option&gt;列表数据&lt;/option&gt;&lt;/optgroup&gt; textarea标签：默认情况下可以无限换行，有默认的宽度和高度，默认情况下输入框是可以手动拉伸的格式：&lt;textarea&gt;内容&lt;/textarea&gt;可以通过这样给文本添加列数和行数：&lt;textarea cols=”” rows=””&gt;内容&lt;/textarea&gt;fieldset标签：给表单添加边框legend标签：可以给边框指定一个标题 14.video标签：（1）作用： 播放视频（2）格式： 第一种格式：&lt;video src=””&gt;&lt;/video&gt;第二种格式：&lt;video&gt;&lt;source src=”” type=”video/webm/ogg/mp4”&gt;&lt;/suorce&gt;&lt;/video&gt;由于视频数据非常的重要，所以五大浏览器厂商都不愿意支持别人的视频格式，所以导致了没有一种视频格式是所有浏览器都支持的，这个时候w3c为了解决这个问题，所以有了第二种格式（3）常用属性：width/heightautoplay:用来告诉video标签是否需要自动播放视频 controls: 用来告诉video标签是否需要显示控制条 poster：用来告诉video标签视频没有播放之前显示的占用图片 loop：一般用于做广告视频，用于告诉video标签播放结束后是否需要循环播放preload：预加载视频，与autoplay相冲，如果设置了autoplay属性那么preload就会失效muted静音： 15.audio标签：（1）作用：播放音频（2）格式：第一种格式：&lt;audio src=””&gt;&lt;/audio&gt; 第二种格式：&lt;audio&gt;&lt;source src=”audio/mp3”&gt;&lt;/source&gt;&lt;/audio&gt;（3）常用属性：width/heightautoplay:用来告诉audio标签是否需要自动播放视频 controls: 用来告诉audio标签是否需要显示控制条 loop：用于告诉audio o标签播放结束后是否需要循环播放preload：加载音频，与autoplay相冲，如果设置了autoplay属性那么preload就会失效muted静音： 16.详情和概要标签：（1）作用：利用summary标签来描述概要信息，利用dateils标签描述详情信息，默认情况下是折叠显示，想看详情信息必须点击（2）格式：&lt;details&gt;&lt;summary&gt;概要信息&lt;/summary&gt;详情信息&lt;/details&gt;17.marquee标签：不是w3c推荐的标签，但各个浏览器对他的支持非常好 （1）作用：跑马灯效果，不仅可以让文字滚动也可以让图片滚动 （2）格式：&lt;marquee &gt;内容&lt;/marquee &gt; （3）常用属性： direction：滚动方向 left/right/up/down scrollamount:滚动速度 loop:滚动次数，默认是-1，无限次 behavior:滚动类型 slide滚动到边界就停止alternate滚动到边界就弹回来 18.字符实体&amp;nbsp;空格、&amp;lt;小于号、&amp;gt;大于号、&amp;copy;版权符号","categories":[],"tags":[{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"},{"name":"HTML","slug":"HTML","permalink":"http://www.1oveit.club/tags/HTML/"}]},{"title":"五分钟学会简单使用git","slug":"五分钟学会简单使用git","date":"2015-09-22T16:00:00.000Z","updated":"2017-05-08T02:46:43.000Z","comments":true,"path":"2015/09/23/五分钟学会简单使用git/","link":"","permalink":"http://www.1oveit.club/2015/09/23/五分钟学会简单使用git/","excerpt":"五分钟，简单入门。学会之后可以愉快的管理你的文件啦。 简单使用git 其实很简单，有多简单呢？ 1. git init 初始化一个仓库； 2. git add . 添加文件到暂存区； 3. git commit -m&apos;messeage&apos; 提交至版本库； 4. git push origin master 推送至远程仓库；","text":"五分钟，简单入门。学会之后可以愉快的管理你的文件啦。 简单使用git 其实很简单，有多简单呢？ 1. git init 初始化一个仓库； 2. git add . 添加文件到暂存区； 3. git commit -m&apos;messeage&apos; 提交至版本库； 4. git push origin master 推送至远程仓库； 分支管理什么是平衡分支？实际工作中一般新建平衡分支用于开发调试等，然后再合并到主分支。 1.git checkout -b dev 新建dev分支并切换到dev分支。 相当于：git branch dev 创建dev分支； git checkout dev 切换到dev分支； 2. 开发或者调试结束后 git add * 添加所有文件到暂存区； git commit -m&apos;messeage&apos; 提交至版本库； 3.git checkout master 切换到主分支； git merge dev 合并分支； git branch -d dev 删除分支； 解决冲突什么是冲突？同一份文件同一个地方被不同的协作者修改了，最后一个推送至远程的会产生冲突。 解决冲突：git pull 更新本地仓库 打开冲突文件，找到冲突部分，协调修改。 1 TODO 2 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 3 我修改的 4 ======= 5 协作者修改的 6 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 经过协调，修改为 1 TODO 2 经过协调修改的 到这里，你已经基本上掌握了git的使用了，想再深入了解，请点击git Pro中文","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://www.1oveit.club/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"http://www.1oveit.club/tags/版本控制/"}]},{"title":"你好，世界","slug":"你好，世界","date":"2015-08-24T10:23:07.000Z","updated":"2017-05-16T16:42:18.000Z","comments":true,"path":"2015/08/24/你好，世界/","link":"","permalink":"http://www.1oveit.club/2015/08/24/你好，世界/","excerpt":"","text":"你好，世界。 起笔不详在遥远的海洋上，夕阳无限好。摇摇曳曳，余光随着波浪，尽情摇摆。海面像往常一样平静。这是这座小城第824年历史的纪念日，历史悠久，耐人探索。 吃完晚饭六点多，一家人来到海边散步。女儿已经5岁了，扎着小尾辫子。一手牵着妈妈，一手牵着爸爸，唱着上课老师教的歌曲。忽然，不知道那里逃出来的狗，灰棕灰，气势汹汹. 这可不得了，这冲着人去咬。猝不及防，小女孩被狗咬伤了。没想到，意外总是这么意外。今天是小女孩的五岁生日。","categories":[{"name":"世界，你好","slug":"世界，你好","permalink":"http://www.1oveit.club/categories/世界，你好/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.1oveit.club/tags/随笔/"},{"name":"updating","slug":"updating","permalink":"http://www.1oveit.club/tags/updating/"}]},{"title":"jQuery 源码简单分析","slug":"jQuery-源码分析","date":"2015-08-12T16:33:34.000Z","updated":"2017-05-13T10:45:13.000Z","comments":true,"path":"2015/08/13/jQuery-源码分析/","link":"","permalink":"http://www.1oveit.club/2015/08/13/jQuery-源码分析/","excerpt":"jQuery时下非常流行，简单好用，工作必用。想更深入学习，可以通过研究其源代码。 jQuery是一个闭包（即时函数）(function( window, undefined ) {}) 让我们来看一看jQuery源代码的基本信息","text":"jQuery时下非常流行，简单好用，工作必用。想更深入学习，可以通过研究其源代码。 jQuery是一个闭包（即时函数）(function( window, undefined ) {}) 让我们来看一看jQuery源代码的基本信息12345678910111213 /*!* jQuery JavaScript Library v2.0.0 版本信息* http://jquery.com/ 官方网站** Includes Sizzle.js 复杂选择器文件名称* http://sizzlejs.com/ 复杂选择器文件网站** Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors 版权信息* Released under the MIT license 开源协议* http://jquery.org/license** Date: 2013-04-18 更新时间*/ 这说明jQuery有多个版本,现在我们分析的是2.0.0版本，在之前的版本版本需要兼容IE678,里面有大量的兼容性处理。从2.0.0版本入手开始研究,从上往下解读注释 包括: 01 官方网站 02 复杂选择器 03 版权信息和开源协议 04 #1335和bug管理系统 jQ本质就是一个闭包 使用闭包的好处： ① 为了避免和其他框架产生冲突(代码说明) ② 多个框架中如果出现了同名的变量或者是函数那么会存在覆盖或者是冲突,而使用闭包结构可以处理这个问题 ③ 其它 传递window参数的好处： ① 参数的区分:形式参数和实际参数 ② 函数作用域说明:函数内部的数据外界无法访问(引申闭包相关知识点) ③ 把内部的数据传递给外部使用 ④ 用于压缩代码(不是很理解) 传递window参数的好处： ① 方便代码的压缩 ② 使用undefined作为形参传入,为了防止代码的修改(在IE以前的版本中undefined可以被修改) jQuery被写成了一个工厂函数根据我们已经清楚的部分来开始初步的搭建框架结构,主要包括以下部分 001 该框架的最外层是一个立即调用函数(闭包),需要接受两个参数window和undefined 002 提供一个jQuery工厂函数 003 设置jQuery函数对象的原型对象(直接替换),并修正构造器属性,添加init方法 004 在jQuery工厂函数内部返回使用init方法创建的对象 005 设置原型对象赋值并讲解fn就是原型对象 03 讲解外界应该如何使用jQuery函数 001 依据我们使用jQuery框架的经验,在HTML文件中通过jQuery或者是$来访问 002 分析外部如何访问闭包内部的数据(在闭包中提供接口返回|把闭包中需要让外界访问的对象通过全局变量传递) 003 书写代码 window.$ = window.jQuery = jQuery; 004 注意说明:外界在调用的时候是通过jQuery()这种方式调用的,那么获取的就是一个jQuery.prototype.init类型的实例化对象 04 验证并说明调用jQuery得到的是jQuery.fn.init类型的实例化对象 代码示例：123456789101112131415161718192021222324252627包含功能: (1) 整体结构(立即调用函数) (2) jQuery工厂函数定义 (3) fn函数 (4) window.$ 和window.jQuery*/(function (window) &#123; //01 jQuery工厂函数 var jQuery = function () &#123; //02 返回一个jQuery.prototype.init类型的实例化对象 return new jQuery.fn.init(); &#125;; //03 替换jQuery工厂函数的原型对象 jQuery.prototype = &#123; //修正构造器属性 constructor:jQuery, init:function () &#123; //...init方法内部实现细节 &#125; &#125; //04 把jQuery工厂函数的原型对象赋值给jQuery.prototype.init的原型对象 jQuery.prototype.init.prototype = jQuery.prototype; //05 为jQuery工厂函数添加fn属性,该方法指向jQuery的原型对象 jQuery.fn = jQuery.prototype; //06 设置让外界能够拿到并使用jQuery工厂函数 window.$ = window.jQuery = jQuery;&#125;)(window); 上面分析的很简单，如果想要深入了解可以到GitHub网站等，希望对您有帮助","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://www.1oveit.club/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://www.1oveit.club/tags/jQuery/"},{"name":"源码分析","slug":"源码分析","permalink":"http://www.1oveit.club/tags/源码分析/"}]},{"title":"12年逗比如我","slug":"12年怀旧","date":"2015-08-10T13:27:45.000Z","updated":"2017-05-12T17:16:12.000Z","comments":true,"path":"2015/08/10/12年怀旧/","link":"","permalink":"http://www.1oveit.club/2015/08/10/12年怀旧/","excerpt":"12年写的乱七八遭，拿出来怀旧，权当笑话，笑笑更开心！ 一周大一秀欢迎收听一周大一秀，观众朋友们大家好。好学生就是我，我就是曾大贤。欢迎收听本节目，请大家用热烈的掌声欢迎我们今天的主角出场。他就是人见人爱，花见花开，俗称一朵海棠压梨花的帅哥。没错，你猜对了，好学生就是我，我就是曾大贤。接下来请大家千万把耳屎勾干净了，洗耳恭听嘛，哈哈。","text":"12年写的乱七八遭，拿出来怀旧，权当笑话，笑笑更开心！ 一周大一秀欢迎收听一周大一秀，观众朋友们大家好。好学生就是我，我就是曾大贤。欢迎收听本节目，请大家用热烈的掌声欢迎我们今天的主角出场。他就是人见人爱，花见花开，俗称一朵海棠压梨花的帅哥。没错，你猜对了，好学生就是我，我就是曾大贤。接下来请大家千万把耳屎勾干净了，洗耳恭听嘛，哈哈。大学就是围墙啊，在外面的人都想跳进来，在里面的人都想跳出去。曾哥我真的是深深的有感触啊！此事从五百年前说起，曾哥在一个夜黑风高的晚上，血腥的风放肆嘲笑满街的横尸遍野。曾哥右持AK_47，左携一篮子地雷，嘴叼雪茄【此音乐响起上海滩】，在千军万马中杀了出来。就这样，千军万马来相见，曾哥突破了大学这道围墙，杀进了大学【此时音乐响起天空之城】。进了大学这道墙，曾哥欣喜若狂，因为按照传说，就可以不费吹灰之力拥有一切，以后开宝马，住洋房，娶洋妞都不用愁了。以为到了世外桃源，曾哥很高兴地把AK_47丢进了河里，把一篮子地雷也扔了进去【此时音乐响起乌鸦的惨叫声】，只留下嘴刁着的那根雪茄，用来扮酷讨女孩子欢心。 故事到这里，相信大家都能猜到后果了，很遗憾广告时间到了，请大家不要走开，广告之后更精彩【好敌真好，广州好敌】。欢迎大家继续收听一周大一秀，好学生就是我，我就是曾大贤。曾大贤接下来何去何从，精彩不容错过。曾大贤被传说给传说了，接下来的日子里，他就只能做这些事了，哎【MUSIC阿里路亚】 摸黑起床，叫兽整队，准备抗战。有的时候还没来得及刷牙洗脸，就匆匆忙忙赶去与英语口语决一死战。战罢方休，一个馒头一个大饼是战利品。军纪如律令，又赶忙去找营地，生怕触犯律令，有时不得不一边啃着个窝窝头一边找赶上军队去扎营。糊糊涂涂的坐在营里，听叫兽讲那些讲那些似懂非懂的军事理论知识，时间很快到了中午。战友总在催，不走快点，就要吃剩饭，呜呜，排队打饭订餐，弄得曾哥连吃饭的心情都没有了。好不容易吃完了午饭，曾哥本想舒舒服服睡上一觉，怎知社团活动来风急。曾哥可怜的午休时间那，就这么被无情的摧残了。 俗话说，中午不睡，下午崩溃。果不其然，曾哥整个下午都崩溃掉了【音乐伤不起啊伤不起】。顶着乏意，毫无生机。曾哥恹恹欲睡，却又不敢入睡。闭着眼睛也能跟着叫兽打军体拳，曾哥实在是太强大了！ 时间一晃而过，本来打算美美的洗个澡的，可是时间急迫啊。七点就要站岗放哨，又是军纪如律令，所以洗澡这事给挂了。一来省些水资源，二来嘛省钱，你懂的，哈哈。终于曾哥下岗了，夜生活真正开始了。手机上网畅无线，莺歌电影嗨翻天十一二点不算晚，就看你的肾好不好，额滴肾啊，哈哈。 大学生活就是沙场点兵，而曾哥却总还能打怪兽。一部手机可以有几多个怪兽，曾哥说菲尔普斯专用山寨机，就是牛。曾哥追师姐也真是牛，来一个杀一个，来两个杀一双。可是你懂的，曾哥最终还是情伤了【音乐响起我是个容易受伤的男人】，因为长得太帅了没办法，不知道选那一个啊。【音乐响起请你不要迷恋哥，嫂子会打你的】 曾哥受伤了，曾哥想家了。【音乐响起常回家看看】曾哥哭了【音乐男人哭吧哭吧不是罪】，曾哥想到了AK_47，想到了地雷，但只剩嘴里那根烟了，杀不回去了。 还好，周末给了曾哥继续下去的理由。叫兽说，睡觉是对周末的最起码的尊重。曾哥一向是守法的孩子，所以周末有事没事要找曾哥的孩子，请留言，曾哥已睡死，哈哈。 当然这是不可能的事，因为叫兽还说过，来到洛阳，你不去外面转转，就可惜了。河山大好，洛阳正好。老师说到曾哥就做到，所以周末成了曾哥的旅游时间。一个地方总会有一个地方的好，洛阳正是个好地方。大学你所在的城市，你对他有了解多少呢？嘿嘿，趁周末完，像曾哥一样，出去转转吧，别待在宿舍当懒虫。音乐响起许嵩的【河山大好：电脑看太久了脖子也会酸，数字时代貌似把生活节奏加快，也让人变得行动迟缓起来。忙忙忙，忙不出个所以然，地球就算累了它照样会公转自转。叹叹叹，弹指一挥人生苦短，终点不明沿途风景要好好看。你可以隐隐的期待，途中佳缘的带来，保持一个浪漫的心态，活着就不算坏】。 感谢大家一路相伴，本期节目到此结束。曾哥究竟会在大学有何作为呢？","categories":[],"tags":[{"name":"娱乐","slug":"娱乐","permalink":"http://www.1oveit.club/tags/娱乐/"},{"name":"怀旧","slug":"怀旧","permalink":"http://www.1oveit.club/tags/怀旧/"}]}]}